<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>hexo一些配置（不定期更新）</title>
      <link href="/stardust14.github.io/2020/08/10/hexo%E5%8D%9A%E5%AE%A2/"/>
      <url>/stardust14.github.io/2020/08/10/hexo%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h1>Front-matter</h1><p>这一部分是写博客时，档案最上方以<code>---</code>分隔的区域，用于指定个别参数。</p><h2 id="page-Front-matter"><a class="header-anchor" href="#page-Front-matter">¶</a>page Front-matter</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">updated:</span><br><span class="line">type:</span><br><span class="line">comments:</span><br><span class="line">description:</span><br><span class="line">keywords:</span><br><span class="line">top<span class="emphasis">_img:</span></span><br><span class="line"><span class="emphasis">mathjax:</span></span><br><span class="line"><span class="emphasis">katex:</span></span><br><span class="line"><span class="emphasis">aside:</span></span><br><span class="line"><span class="emphasis">aplayer：</span></span><br><span class="line"><span class="emphasis">---</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>写法</th><th>解释</th></tr></thead><tbody><tr><td>title</td><td>【必需】页面标题</td></tr><tr><td>date</td><td>【必需】页面创建日期</td></tr><tr><td>type</td><td>【必需】标籤、分类和友情链接三个页面需要配置</td></tr><tr><td>updated</td><td>【可选】页面更新日期</td></tr><tr><td>description</td><td>【可选】页面描述</td></tr><tr><td>keywords</td><td>【可选】页面关键字</td></tr><tr><td>comments</td><td>【可选】显示页面评论模块 (默认 true)</td></tr><tr><td>top_img</td><td>【可选】页面顶部图片</td></tr><tr><td>mathjax</td><td>【可选】显示 mathjax (当设置 mathjax 的 per_page: false 时，才需要配置，默认 false)</td></tr><tr><td>katex</td><td>【可选】显示 katex (当设置 katex 的 per_page: false 时，才需要配置，默认 false)</td></tr><tr><td>aside</td><td>【可选】显示侧边栏 (默认 true)</td></tr><tr><td>aplayer</td><td>【可选】在需要的页面加载 aplayer 的 js 和 css</td></tr><tr><td>highlight_shrink</td><td>【可选】配置代码框是否展开 (true/false)(默认为设置中 highlight_shrink 的配置)</td></tr></tbody></table><h2 id="Post-Front-matter"><a class="header-anchor" href="#Post-Front-matter">¶</a>Post Front-matter</h2><blockquote><p>这是基于Butterfly主题下的写法</p></blockquote><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">updated:</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">keywords:</span><br><span class="line">description:</span><br><span class="line">top<span class="emphasis">_img:</span></span><br><span class="line"><span class="emphasis">comments：</span></span><br><span class="line"><span class="emphasis">cover:  </span></span><br><span class="line"><span class="emphasis">toc:  </span></span><br><span class="line"><span class="emphasis">toc_</span>number:</span><br><span class="line">auto<span class="emphasis">_open:</span></span><br><span class="line"><span class="emphasis">copyright:</span></span><br><span class="line"><span class="emphasis">copyright_</span>author:</span><br><span class="line">copyright<span class="emphasis">_author_</span>href:</span><br><span class="line">copyright<span class="emphasis">_url:</span></span><br><span class="line"><span class="emphasis">copyright_</span>info:</span><br><span class="line">mathjax:</span><br><span class="line">katex:</span><br><span class="line">aplayer：</span><br><span class="line">highlight<span class="emphasis">_shrink：</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>写法</th><th>解释</th></tr></thead><tbody><tr><td>title</td><td>【必需】文章标题</td></tr><tr><td>date</td><td>【必需】文章创建日期</td></tr><tr><td>updated</td><td>【可选】文章更新日期</td></tr><tr><td>tags</td><td>【可选】文章标籤</td></tr><tr><td>categories</td><td>【可选】文章分类</td></tr><tr><td>keywords</td><td>【可选】文章关键字</td></tr><tr><td>description</td><td>【可选】文章描述</td></tr><tr><td>top_img</td><td>【可选】文章顶部图片</td></tr><tr><td>cover</td><td>【可选】文章缩略图 (如果没有设置  top_img, 文章页顶部将显示缩略图，可设为 false / 图片地址 / 留空)</td></tr><tr><td>comments</td><td>【可选】显示文章评论模块 (默认  true)</td></tr><tr><td>toc</td><td>【可选】显示文章 TOC (默认为设置中 toc 的 enable 配置)</td></tr><tr><td>toc_number</td><td>【可选】显示 toc_number (默认为设置中 toc 的 number 配置)</td></tr><tr><td>auto_open</td><td>【可选】是否自动打开 TOC (默认为设置中 toc 的 auto_open 配置)</td></tr><tr><td>copyright</td><td>【可选】显示文章版权模块 (默认为设置中 post_copyright 的 enable 配置)</td></tr><tr><td>copyright_author</td><td>【可选】文章版权模块的文章作者</td></tr><tr><td>copyright_author_href</td><td>【可选】文章版权模块的文章作者链接</td></tr><tr><td>copyright_url</td><td>【可选】文章版权模块的文章连结链接</td></tr><tr><td>copyright_info</td><td>【可选】文章版权模块的版权声明文字</td></tr><tr><td>mathjax</td><td>【可选】显示 mathjax (当设置 mathjax 的 per_page: false 时，才需要配置，默认 false)</td></tr><tr><td>katex</td><td>【可选】显示 katex (当设置  katex 的 per_page: false 时，才需要配置，默认 false)</td></tr><tr><td>aplayer</td><td>【可选】在需要的页面加载 aplayer 的 js 和 css, 请参考文章下面的音乐 配置</td></tr><tr><td>highlight_shrink</td><td>【可选】配置代码框是否展开 (true/false)(默认为设置中 highlight_shrink 的配置)</td></tr></tbody></table><h1>标签外挂</h1><h2 id="Note"><a class="header-anchor" href="#Note">¶</a>Note</h2><p>用法</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note [class] [no-icon] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">[class]   : default | primary | success | info | warning | danger.</span><br><span class="line">[no-icon] : Disable icon in note.</span><br><span class="line"></span><br><span class="line">All parameters are optional.</span><br></pre></td></tr></table></figure><div class="note info">            <p>info 直接写在markdown下就可以</p><p>标籤外挂虽然能为主题带来一些额外的功能和 UI 方面的强化，但是，标籤外挂也有明显的限制，使用时请留意。</p>          </div><p>例如：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note default %&#125;</span><br><span class="line">default 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary no-icon %&#125;</span><br><span class="line">primary 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success %&#125;</span><br><span class="line">success 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info %&#125;</span><br><span class="line">info 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning %&#125;</span><br><span class="line">warning 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger %&#125;</span><br><span class="line">danger 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><div class="note default">            <p>default 提示块标籤</p>          </div><div class="note primary no-icon">            <p>primary 提示块标籤</p>          </div><div class="note success">            <p>success 提示块标籤</p>          </div><div class="note info">            <p>info 提示块标籤</p>          </div><div class="note warning">            <p>warning 提示块标籤</p>          </div><div class="note danger">            <p>danger 提示块标籤</p>          </div><h2 id="Gallery-相册图库"><a class="header-anchor" href="#Gallery-相册图库">¶</a>Gallery(相册图库)</h2><p>写法：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-group-main&quot;</span>&gt;</span></span></span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li>name：图库名字</li><li>description：图库描述</li><li>link：连接到对应相册的地址</li><li>img-url：图库封面的地址</li></ul><p>example：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-group-main&quot;</span>&gt;</span></span></span><br><span class="line">&#123;% galleryGroup &#x27;壁纸&#x27; &#x27;收藏的一些壁纸&#x27; &#x27;/Gallery/wallpaper&#x27; https://i.loli.net/2019/11/10/T7Mu8Aod3egmC4Q.png %&#125;</span><br><span class="line">&#123;% galleryGroup &#x27;漫威&#x27; &#x27;关于漫威的图片&#x27; &#x27;/Gallery/marvel&#x27; https://i.loli.net/2019/12/25/8t97aVlp4hgyBGu.jpg %&#125;</span><br><span class="line">&#123;% galleryGroup &#x27;OH MY GIRL&#x27; &#x27;关于OH MY GIRL的图片&#x27; &#x27;/Gallery/ohmygirl&#x27; https://i.loli.net/2019/12/25/hOqbQ3BIwa6KWpo.jpg %&#125;</span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><div class="gallery-group-main">  <figure class="gallery-group">  <img class="gallery-group-img" src= "/stardust14.github.io/img/loading.gif" data-lazy-src='https://i.loli.net/2019/11/10/T7Mu8Aod3egmC4Q.png'>  <figcaption>  <div class="gallery-group-name">壁纸</div>  <p>收藏的一些壁纸</p>  <a href='/stardust14.github.io/Gallery/wallpaper'></a>  </figcaption>  </figure>    <figure class="gallery-group">  <img class="gallery-group-img" src= "/stardust14.github.io/img/loading.gif" data-lazy-src='https://i.loli.net/2019/12/25/8t97aVlp4hgyBGu.jpg'>  <figcaption>  <div class="gallery-group-name">漫威</div>  <p>关于漫威的图片</p>  <a href='/stardust14.github.io/Gallery/marvel'></a>  </figcaption>  </figure>    <figure class="gallery-group">  <img class="gallery-group-img" src= "/stardust14.github.io/img/loading.gif" data-lazy-src='https://i.loli.net/2019/12/25/hOqbQ3BIwa6KWpo.jpg'>  <figcaption>  <div class="gallery-group-name">OH MY GIRL</div>  <p>关于OH MY GIRL的图片</p>  <a href='/stardust14.github.io/Gallery/ohmygirl'></a>  </figcaption>  </figure>  </div><h2 id="Gallery相册"><a class="header-anchor" href="#Gallery相册">¶</a>Gallery相册</h2><p>区别于旧版的 Gallery 相册，新的 Gallery 相册会自动根据图片长度进行排版，书写也更加方便，与 markdown 格式一样。可根据需要插入到相应的 md。</p><p>写法：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% gallery %&#125;</span><br><span class="line">markdown 图片格式</span><br><span class="line">&#123;% endgallery %&#125;</span><br></pre></td></tr></table></figure><p>example:</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% gallery %&#125;</span><br><span class="line">![](https://i.loli.net/2019/12/25/Fze9jchtnyJXMHN.jpg)</span><br><span class="line">![](https://i.loli.net/2019/12/25/ryLVePaqkYm4TEK.jpg)</span><br><span class="line">![](https://i.loli.net/2019/12/25/gEy5Zc1Ai6VuO4N.jpg)</span><br><span class="line">![](https://i.loli.net/2019/12/25/d6QHbytlSYO4FBG.jpg)</span><br><span class="line">![](https://i.loli.net/2019/12/25/6nepIJ1xTgufatZ.jpg)</span><br><span class="line">![](https://i.loli.net/2019/12/25/E7Jvr4eIPwUNmzq.jpg)</span><br><span class="line">![](https://i.loli.net/2019/12/25/mh19anwBSWIkGlH.jpg)</span><br><span class="line">![](https://i.loli.net/2019/12/25/2tu9JC8ewpBFagv.jpg)</span><br><span class="line">&#123;% endgallery %&#125;</span><br></pre></td></tr></table></figure><h2 id="tag-hide"><a class="header-anchor" href="#tag-hide">¶</a>tag-hide</h2><p>如果你想把一些文字、内容隐藏起来，并提供按钮让用户点击显示。可以使用这个inline标签外挂。</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% hideInline content,display,bg,color %&#125;</span><br></pre></td></tr></table></figure><p>待续····</p><h2 id="Button"><a class="header-anchor" href="#Button">¶</a>Button</h2><blockquote><p>3.0以上适用</p></blockquote><p>使用方法</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% btn [url],[text],[icon],[color] [style] [layout] [position] [size] %&#125;</span><br><span class="line"></span><br><span class="line">[url]         : 链接</span><br><span class="line">[text]        : 按钮文字</span><br><span class="line">[icon]        : [可选] 图标</span><br><span class="line">[color]       : [可选] 按钮背景顔色(默认style时）</span><br><span class="line"><span class="code">                      按钮字体和边框顔色(outline时)</span></span><br><span class="line"><span class="code">                      default/blue/pink/red/purple/orange/green</span></span><br><span class="line"><span class="code">[style]       : [可选] 按钮样式 默认实心</span></span><br><span class="line"><span class="code">                      outline/留空</span></span><br><span class="line"><span class="code">[layout]      : [可选] 按钮佈局 默认为line</span></span><br><span class="line"><span class="code">                      block/留空</span></span><br><span class="line"><span class="code">[position]    : [可选] 按钮位置 前提是设置了layout为block 默认为左边</span></span><br><span class="line"><span class="code">                      center/right/留空</span></span><br><span class="line"><span class="code">[size]        : [可选] 按钮大小</span></span><br><span class="line"><span class="code">                      larger/留空</span></span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">This is my website, click the button &#123;% btn &#x27;https://stardust14.github.io/&#x27;,STAR %&#125;</span><br><span class="line">This is my website, click the button &#123;% btn &#x27;https://stardust14.github.io/&#x27;,STAR,far fa-hand-point-right %&#125;</span><br><span class="line">This is my website, click the button &#123;% btn &#x27;https://stardust14.github.io/&#x27;,STAR,,outline %&#125;</span><br><span class="line">This is my website, click the button &#123;% btn &#x27;https://stardust14.github.io/&#x27;,STAR,far fa-hand-point-right,outline %&#125;</span><br><span class="line">This is my website, click the button &#123;% btn &#x27;https://stardust14.github.io/&#x27;,STAR,far fa-hand-point-right,larger %&#125;</span><br></pre></td></tr></table></figure><p>This is my website, click the button <a class="btn-beautify button--animated " href="https://stardust14.github.io/"   title="STAR"><span>STAR</span></a><br>This is my website, click the button <a class="btn-beautify button--animated " href="https://stardust14.github.io/"   title="STAR"><i class="far fa-hand-point-right fa-fw"></i><span>STAR</span></a><br>This is my website, click the button <a class="btn-beautify button--animated outline" href="https://stardust14.github.io/"   title="STAR"><span>STAR</span></a><br>This is my website, click the button <a class="btn-beautify button--animated outline" href="https://stardust14.github.io/"   title="STAR"><i class="far fa-hand-point-right fa-fw"></i><span>STAR</span></a><br>This is my website, click the button <a class="btn-beautify button--animated larger" href="https://stardust14.github.io/"   title="STAR"><i class="far fa-hand-point-right fa-fw"></i><span>STAR</span></a></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% btn &#x27;https://stardust14.github.io&#x27;,STAR,far fa-hand-point-right,block %&#125;</span><br><span class="line">&#123;% btn &#x27;https://stardust14.github.io&#x27;,STAR,far fa-hand-point-right,block center larger %&#125;</span><br><span class="line">&#123;% btn &#x27;https://stardust14.github.io&#x27;,STAR,far fa-hand-point-right,block right outline larger %&#125;</span><br></pre></td></tr></table></figure><a class="btn-beautify button--animated block" href="https://stardust14.github.io"   title="STAR"><i class="far fa-hand-point-right fa-fw"></i><span>STAR</span></a><a class="btn-beautify button--animated block center larger" href="https://stardust14.github.io"   title="STAR"><i class="far fa-hand-point-right fa-fw"></i><span>STAR</span></a><a class="btn-beautify button--animated block right outline larger" href="https://stardust14.github.io"   title="STAR"><i class="far fa-hand-point-right fa-fw"></i><span>STAR</span></a>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础知识</title>
      <link href="/stardust14.github.io/2020/07/28/Python%E5%AD%A6%E4%B9%A0/"/>
      <url>/stardust14.github.io/2020/07/28/Python%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>Python是一种面向对象、 解释型、弱类型的脚本语言,它也是一种功能强大而完善的通用型语言。</p><p>Python的两大特色是<strong>清晰的语法</strong>和<strong>可扩展性</strong>:</p><pre><code>+    Python的语法非常清晰,它甚至不是一 种格式自由的语言。例如,它要求if语句的下一-行必须向右缩进,否则不能通过编译。+    Python的可扩展性体现为它的模块, Python具有脚本语言中最丰富和强大的类库(这些类库被形象地称为&quot;batteries included , 内置电池”), 这些类库覆盖 了文件I/O、GUI、 网络编程、数据库访问、文本操作等绝大部分应用场景。</code></pre><pre><code class="language-python"></code></pre><blockquote><p>+“空格” 出现小圆点</p></blockquote><h1>基础语法</h1><h2 id="变量命名规则"><a class="header-anchor" href="#变量命名规则">¶</a>变量命名规则</h2><ul><li>变量必须以字母(a-Z,A-Z)或下划线(_)开头</li><li>其他字符可以是字母，数字或</li><li>变量<em><strong>区分大小写</strong></em></li><li>Python关键字不能用作变量名。</li><li>变量的命名不能以数字来开头</li></ul><p>命名规范：</p><ul><li>见名知意，尽量使用有语义的单词命名。如使用password用作密码，<code>username</code>用户名。</li><li>小驼峰式命名法:第一个单词首字母小写其他单词首字母大写，如<code>userName</code></li><li>大驼峰式命名法:全部单词首字母都用大写， 如<code>UserName</code></li><li>下划线命名法:每个单词用_下划线连接，如<code>user_name</code>.</li></ul><h2 id="python保留字"><a class="header-anchor" href="#python保留字">¶</a>python保留字</h2><p>保留字即关键字，我们不能把它们用作任何标识符名称。Python 的标准库提供了一个 keyword 模块，可以输出当前版本的所有关键字：</p><pre><code class="language-python">&gt;&gt;&gt; import keyword&gt;&gt;&gt; keyword.kwlist['False', 'None', 'True', 'and', 'as', 'assert', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']</code></pre><h2 id="注释"><a class="header-anchor" href="#注释">¶</a>注释</h2><p>Python中单行注释以 <strong>#</strong> 开头</p><p>多行注释可以用多个 <strong>#</strong> 号，还有 <code>'''</code> 和 <code>&quot;&quot;&quot;</code></p><h2 id="多行语句"><a class="header-anchor" href="#多行语句">¶</a>多行语句</h2><p>Python 通常是一行写完一条语句，但如果语句很长，我们可以使用反斜杠()来实现多行语句。</p><p>在 [], {}, 或 () 中的多行语句，不需要使用反斜杠()</p><h2 id="等待用户输入"><a class="header-anchor" href="#等待用户输入">¶</a>等待用户输入</h2><p>执行下面的程序在按回车键后就会<strong>等待用户输入</strong>：</p><pre><code class="language-python">input(&quot;\n\n按下 enter 键后退出。&quot;)</code></pre><p>以上代码中 ，&quot;\n\n&quot;在结果输出前会输出两个新的空行。一旦用户按下 enter 键时，程序将退出。</p><h2 id="同一行显示多条语句"><a class="header-anchor" href="#同一行显示多条语句">¶</a>同一行显示多条语句</h2><p>Python可以在同一行中使用多条语句，语句之间使用分号(;)分割，以下是一个简单的实例：</p><pre><code class="language-python">import sys;x = 'hello';sys.stdout.write(x + '\n')</code></pre><h2 id="多个语句构成代码组"><a class="header-anchor" href="#多个语句构成代码组">¶</a>多个语句构成代码组</h2><p>缩进相同的一组语句构成一个代码块，我们称之代码组。</p><p>像if、while、def和class这样的复合语句，首行以关键字开始，以冒号( : )结束，该行之后的一行或多行代码构成代码组。</p><p>我们将首行及后面的代码组称为一个子句(clause)。</p><h2 id="Print-输出"><a class="header-anchor" href="#Print-输出">¶</a>Print 输出</h2><p>print 默认输出是换行的，如果要实现不换行需要在变量末尾加上 <strong>end=&quot;&quot;</strong>：</p><pre><code class="language-python">x=&quot;a&quot;y=&quot;b&quot;# 换行输出print( x )print( y ) print('---------')# 不换行输出print( x, end=&quot; &quot; )print( y, end=&quot; &quot; )print()</code></pre><h2 id="import-与-from…import"><a class="header-anchor" href="#import-与-from…import">¶</a>import 与 from…import</h2><p>在 python 用 <code>import</code> 或者 <code>from...import</code> 来导入相应的模块。</p><p>将整个模块(somemodule)导入，格式为： <code>import somemodule</code></p><p>从某个模块中导入某个函数,格式为： <code>from somemodule import somefunction</code></p><p>从某个模块中导入多个函数,格式为： <code>from somemodule import firstfunc, secondfunc, thirdfunc</code></p><p>将某个模块中的全部函数导入，格式为： <code>from somemodule import </code></p><h2 id="多个变量赋值"><a class="header-anchor" href="#多个变量赋值">¶</a>多个变量赋值</h2><p>Python允许同时为多个变量进行赋值。</p><h2 id="行与缩进"><a class="header-anchor" href="#行与缩进">¶</a>行与缩进</h2><p>python最具特色的就是使用缩进来表示代码块，不需要使用大括号 <strong>{}</strong> 。</p><p>缩进的空格数是可变的，但是同一个代码块的语句必须包含相同的缩进空格数。</p><h1>基本数据类型</h1><p>Python3 中有六个标准的数据类型：</p><ul><li>Number（数字）</li><li>String（字符串）</li><li>List（列表）</li><li>Tuple（元组）</li><li>Set（集合）</li><li>Dictionary（字典）</li></ul><p>Python3 的六个标准数据类型中：</p><ul><li>**不可变数据（3 个）：**Number（数字）、String（字符串）、Tuple（元组）；</li><li>**可变数据（3 个）：**List（列表）、Dictionary（字典）、Set（集合）。</li></ul><h2 id="字符串"><a class="header-anchor" href="#字符串">¶</a>字符串</h2><ul><li><p>python中单引号和双引号使用完全相同。</p></li><li><p>使用三引号(’’'或&quot;&quot;&quot;)可以指定一个多行字符串。</p></li><li><p>转义符 ‘’</p></li><li><p>反斜杠可以用来转义，使用r可以让反斜杠不发生转义。。 如 r&quot;this is a line with \n&quot; 则\n会显示，并不是换行。</p></li><li><p>按字面意义级联字符串，如&quot;this &quot; &quot;is &quot; &quot;string&quot;会被自动转换为this is string。</p></li><li><p>字符串可以用 + 运算符连接在一起，用 * 运算符重复。</p></li><li><p>Python 中的字符串有两种索引方式，从左往右以 0 开始，从右往左以 -1 开始。</p></li><li><p>Python中的字符串不能改变。</p></li><li><p>Python 没有单独的字符类型，一个字符就是长度为 1 的字符串。</p></li><li><p>字符串的截取的语法格式如下：<strong>变量[头下标:尾下标:步长]</strong></p></li></ul><pre><code class="language-python"> str = 'helloworld' print(str)  # 输出字符串 print(str[0:-1])  # 输出第一个到倒数第二个的所有字符 print(str[0])  # 输出字符串第一个字符 print(str[2:5])  # 输出从第三个开始到第五个的字符 print(str[2:])  # 输出从第三个开始后的所有字符 print(str * 2)  # 输出字符串两次 print(str + '你好')  # 连接字符串  print('------------------------------')  print('hello\nrunoob')  # 使用反斜杠(\)+n转义特殊字符 print(r'hello\nrunoob')  # 在字符串前面添加一个 r，表示原始字符串，不会发生转义</code></pre><p>另外，反斜杠<code>\</code>可以作为续行符，表示下一行是上一行的延续。也可以使用 <strong>“”&quot;…&quot;&quot;&quot;</strong> 或者 <strong>‘’’…’’’</strong> 跨越多行。</p><p>注意，Python 没有单独的字符类型，一个字符就是长度为1的字符串。</p><p><strong>注意：</strong></p><ul><li>1、反斜杠可以用来转义，使用r可以让反斜杠不发生转义。</li><li>2、字符串可以用+运算符连接在一起，用*运算符重复。</li><li>3、Python中的字符串有两种索引方式，从左往右以0开始，从右往左以-1开始。</li><li>4、Python中的字符串不能改变。</li></ul><h2 id="数字类型"><a class="header-anchor" href="#数字类型">¶</a>数字类型</h2><p>python中数字有四种类型：整数、布尔型、浮点数和复数。</p><ul><li><p><strong>int</strong> (整数), 如 1, 只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。</p></li><li><p><strong>bool</strong> (布尔), 如 True。</p></li><li><p><strong>float</strong> (浮点数), 如 1.23、3E-2</p></li><li><p><strong>complex</strong> (复数), 如 1 + 2j、 1.1 + 2.2j</p></li></ul><blockquote><p>删除了python2中的long类型</p></blockquote><h2 id="List（列表）"><a class="header-anchor" href="#List（列表）">¶</a>List（列表）</h2><p>List（列表） 是 Python 中使用最频繁的数据类型。</p><p>列表可以完成大多数集合类的数据结构实现。列表中元素的类型可以不相同，它支持数字，字符串甚至可以包含列表（所谓嵌套）。</p><p>列表是写在方括号 <strong>[]</strong> 之间、用逗号分隔开的元素列表。</p><p>和字符串一样，列表同样可以被索引和截取，列表被截取后返回一个包含所需元素的新列表。</p><p>列表截取的语法格式如下：</p><pre><code class="language-python">#变量[头下标:尾下标]</code></pre><p>索引值以 0 为开始值，-1 为从<strong>末尾</strong>的开始位置。</p><p>加号 <code>+</code> 是列表连接运算符，星号 <code>*</code> 是重复操作</p><p>与Python字符串不一样的是，列表中的元素是可以改变的：</p><pre><code class="language-python">#定义list列表的元素,索引从0开始list1 = ['Friends',1314]list = ['str', 'hexo', 'blog', 'study',list1,112]#还可以进行列表的嵌套list[0] =6list[1] = 'Hexo'print(list)  #输出整个字符串print(list[3]) #输出第四个列表元素print(list[1:4]) #输出第二个元素到第四个列表元素print(list * 2)  #输出两边列表元素print(list + list1)  #连接列表print(list[0:-1])  #输出第一个到倒数第二个元素之间的元素/除最后一个元素不输出，其他元素都输出print(list[2:])  #输出从第三个元素的所有元素</code></pre><p>Python 列表截取可以接收第三个参数，参数作用是截取的步长。如果第三个参数为负数表示逆向读取，以下实例用于翻转字符串：</p><p><strong>///！！！！！！！！待定</strong></p><h2 id="Tuple（元组）"><a class="header-anchor" href="#Tuple（元组）">¶</a>Tuple（元组）</h2><p>元组（tuple）与列表类似，不同之处在于元组的元素<strong>不能修改</strong>。元组写在小括号 <strong>()</strong> 里，元素之间用逗号隔开。</p><p>元组中的元素类型也可以不相同：</p><pre><code class="language-python">tuple = ('abcd', 'god', 123, 6.66) #不能嵌套元组tinytuple = ('hello', 3.415)print(tuple)  #输出整个元组print(tuple[2])  #输出第三个元素print(tuple[0:3])  #输出从第一个元素到第三个元素print(tuple[2:])  #输出第三个元素之后的元素print(tinytuple * 2) #输出两遍元素print(tuple + tinytuple) #连接元组</code></pre><p>元组与字符串类似，可以被索引且下标索引从0开始，-1 为从末尾开始的位置。也可以进行截取（看上面，这里不再赘述）。</p><p>其实，可以把字符串看作一种特殊的元组。</p><p>虽然tuple的元素不可改变，但它可以包含可变的对象，比如list列表。</p><blockquote><p>string、list 和 tuple 都属于 sequence（序列）。</p></blockquote><p><strong>注意：</strong></p><ul><li>1、与字符串一样，元组的元素<strong>不能修改</strong>。</li><li>2、元组也可以被索引和切片，方法一样。</li><li>3、注意构造包含 0 或 1 个元素的元组的特殊语法规则。</li><li>4、元组也可以使用+操作符进行拼接。</li></ul><h2 id="Set（集合）"><a class="header-anchor" href="#Set（集合）">¶</a>Set（集合）</h2><p>集合（set）是由一个或数个形态各异的大小整体组成的，构成集合的事物或对象称作元素或是成员。</p><p><strong>基本功能</strong>是进行成员关系测试和删除重复元素。</p><p>可以使用大括号 <code>&#123; &#125;</code> 或者 <code>set()</code> 函数创建集合，注意：创建一个空集合必须用 <code>set()</code> 而不是 <code>&#123; &#125;</code>，因为 <code>&#123; &#125;</code> 是用来创建一个<strong>空字典</strong>。</p><p>创建格式：</p><pre><code class="language-python">parame = &amp;#123;value01,value02,...&amp;#125;或者set(value)</code></pre><pre><code class="language-python">sites = &amp;#123;'oh', 'my','god', 'oh', 'no'&amp;#125;print(sites)  #输出集合，重复的元素被自动划去#成员测试if 'no' in sites :    print('no在sites集合中')else:    print('no不在sites集合中')print('===================')# set可以进行集合运算a = set('anvkajvbakb')#好像是随机单字符排列，去重复b = set('anfwbakb23')#好像不进行数字的比较print(a)print(b)print(a - b)  #a和b的差集print(a | b)  #a和b的并集print(a &amp; b)  #a和b的交集print(a ^ b)  #a和b中不同是存在的元素</code></pre><h2 id="Dictionary（字典）"><a class="header-anchor" href="#Dictionary（字典）">¶</a>Dictionary（字典）</h2><p>字典（dictionary）是Python中另一个非常有用的内置数据类型。</p><p><em>列表</em>是<strong>有序</strong>的对象集合，<em>字典</em>是<strong>无序</strong>的对象集合。两者之间的区别在于：字典当中的元素是通过<strong>键</strong>来存取的，而<strong>不是</strong>通过偏移存取。</p><p>字典是一种映射类型，字典用 <code>&#123; &#125;</code> 标识，它是<u>一个无序</u>的 <strong>键(key) : 值(value)</strong> 的集合。</p><p>键(key)必须使用不可变类型。</p><p>在同一个字典中，键(key)必须是唯一的。</p><pre><code class="language-python">dict = &amp;#123;&amp;#125;#空字典dict['one'] = &quot;hello&quot;dict[2] = 'world'tinydict = &amp;#123;'name' : 'my', 'code': 'god','site':'helloworld'&amp;#125;print(dict['one'])      # 输出键为 'one' 的值print(dict[2])          # 输出键为 2 的值print(tinydict)         # 输出完整的字典print(tinydict.keys()) # 输出所有键print(tinydict.values()) # 输出所有值</code></pre><p><strong>注意：</strong></p><ul><li>1、字典是一种映射类型，它的元素是键值对。</li><li>2、字典的关键字必须为不可变类型，且不能重复。</li><li>3、创建空字典使用 <code>&#123; &#125;</code>。</li></ul><blockquote><p>字典类型也有一些内置的函数，例如clear()、keys()、values()等。</p></blockquote><h2 id="Python数据类型转换"><a class="header-anchor" href="#Python数据类型转换">¶</a>Python数据类型转换</h2><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>[int(x [,base\])]</code></td><td style="text-align:left">将x转换为一个整数</td></tr><tr><td style="text-align:left"><code>[float(x)]</code></td><td style="text-align:left">将x转换到一个浮点数</td></tr><tr><td style="text-align:left"><code>[complex(real [,imag\])]</code></td><td style="text-align:left">创建一个复数</td></tr><tr><td style="text-align:left"><code>[str(x)]</code></td><td style="text-align:left">将对象 x 转换为字符串</td></tr><tr><td style="text-align:left"><code>[repr(x)]</code></td><td style="text-align:left">将对象 x 转换为表达式字符串</td></tr><tr><td style="text-align:left"><code>[eval(str)]</code></td><td style="text-align:left">用来计算在字符串中的有效Python表达式,并返回一个对象</td></tr><tr><td style="text-align:left"><code>[tuple(s)]</code></td><td style="text-align:left">将序列 s 转换为一个元组</td></tr><tr><td style="text-align:left"><code>[list(s)]</code></td><td style="text-align:left">将序列 s 转换为一个列表</td></tr><tr><td style="text-align:left"><code>[set(s)]</code></td><td style="text-align:left">转换为可变集合</td></tr><tr><td style="text-align:left"><code>[dict(d)]</code></td><td style="text-align:left">创建一个字典。d 必须是一个 (key, value)元组序列。</td></tr><tr><td style="text-align:left"><code>[frozenset(s)]</code></td><td style="text-align:left">转换为不可变集合</td></tr><tr><td style="text-align:left"><code>[chr(x)]</code></td><td style="text-align:left">将一个整数转换为一个字符</td></tr><tr><td style="text-align:left"><code>[ord(x)]</code></td><td style="text-align:left">将一个字符转换为它的整数值</td></tr><tr><td style="text-align:left"><code>[hex(x)]</code></td><td style="text-align:left">一个整数转换为一个十六进制字符串</td></tr><tr><td style="text-align:left"><code>[oct(x)]</code></td><td style="text-align:left">将一个整数转换为一个八进制字符串</td></tr></tbody></table><h1>运算符</h1><h2 id="算术运算符"><a class="header-anchor" href="#算术运算符">¶</a>算术运算符</h2><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">+</td><td style="text-align:left">加 - 两个对象相加</td></tr><tr><td style="text-align:left">-</td><td style="text-align:left">减 - 得到负数或是一个数减去另一个数</td></tr><tr><td style="text-align:left">*</td><td style="text-align:left">乘 - 两个数相乘或是返回一个被重复若干次的字符串</td></tr><tr><td style="text-align:left">/</td><td style="text-align:left">除 - x 除以 y</td></tr><tr><td style="text-align:left">%</td><td style="text-align:left">取模 - 返回除法的余数</td></tr><tr><td style="text-align:left">**</td><td style="text-align:left">幂 - 返回x的y次幂</td></tr><tr><td style="text-align:left">//</td><td style="text-align:left">取整除 - 向下取接近商的整数</td></tr></tbody></table><h2 id="比较运算符"><a class="header-anchor" href="#比较运算符">¶</a>比较运算符</h2><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">==</td><td style="text-align:left">等于 - 比较对象是否相等</td></tr><tr><td style="text-align:left">!=</td><td style="text-align:left">不等于 - 比较两个对象是否不相等</td></tr><tr><td style="text-align:left">&gt;</td><td style="text-align:left">大于 - 返回x是否大于y</td></tr><tr><td style="text-align:left">&lt;</td><td style="text-align:left">小于 - 返回x是否小于y。所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量True和False等价。注意，这些变量名的大写。</td></tr><tr><td style="text-align:left">&gt;=</td><td style="text-align:left">大于等于 - 返回x是否大于等于y。</td></tr><tr><td style="text-align:left">&lt;=</td><td style="text-align:left">小于等于 - 返回x是否小于等于y。</td></tr></tbody></table><h2 id="赋值运算符"><a class="header-anchor" href="#赋值运算符">¶</a>赋值运算符</h2><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">=</td><td style="text-align:left">简单的赋值运算符</td></tr><tr><td style="text-align:left">+=</td><td style="text-align:left">加法赋值运算符</td></tr><tr><td style="text-align:left">-=</td><td style="text-align:left">减法赋值运算符</td></tr><tr><td style="text-align:left">*=</td><td style="text-align:left">乘法赋值运算符</td></tr><tr><td style="text-align:left">/=</td><td style="text-align:left">除法赋值运算符</td></tr><tr><td style="text-align:left">%=</td><td style="text-align:left">取模赋值运算符</td></tr><tr><td style="text-align:left">**=</td><td style="text-align:left">幂赋值运算符</td></tr><tr><td style="text-align:left">//=</td><td style="text-align:left">取整除赋值运算符</td></tr><tr><td style="text-align:left">:=</td><td style="text-align:left">海象运算符，可在表达式内部为变量赋值。<strong>Python3.8 版本新增运算符</strong>。</td></tr></tbody></table><h2 id="位运算符"><a class="header-anchor" href="#位运算符">¶</a>位运算符</h2><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">&amp;</td><td style="text-align:left">按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0</td></tr><tr><td style="text-align:left">|</td><td style="text-align:left">按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。</td></tr><tr><td style="text-align:left">^</td><td style="text-align:left">按位异或运算符：当两对应的二进位相异时，结果为1</td></tr><tr><td style="text-align:left">~</td><td style="text-align:left">按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1。<strong>~x</strong> 类似于 <strong>-x-1</strong></td></tr><tr><td style="text-align:left">&lt;&lt;</td><td style="text-align:left">左移动运算符：运算数的各二进位全部左移若干位，由&quot;&lt;&lt;&quot;右边的数指定移动的位数，高位丢弃，低位补0。</td></tr><tr><td style="text-align:left">&gt;&gt;</td><td style="text-align:left">右移动运算符：把&quot;&gt;&gt;“左边的运算数的各二进位全部右移若干位，”&gt;&gt;&quot;右边的数指定移动的位数</td></tr></tbody></table><h2 id="逻辑运算符"><a class="header-anchor" href="#逻辑运算符">¶</a>逻辑运算符</h2><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">逻辑表达式</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">and</td><td style="text-align:left">x and y</td><td style="text-align:left">布尔&quot;与&quot; - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。</td></tr><tr><td style="text-align:left">or</td><td style="text-align:left">x or y</td><td style="text-align:left">布尔&quot;或&quot; - 如果 x 是 True，它返回 x 的值，否则它返回 y 的计算值。</td></tr><tr><td style="text-align:left">not</td><td style="text-align:left">not x</td><td style="text-align:left">布尔&quot;非&quot; - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。</td></tr></tbody></table><h2 id="成员运算符"><a class="header-anchor" href="#成员运算符">¶</a>成员运算符</h2><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">in</td><td style="text-align:left">如果在指定的序列中找到值返回 True，否则返回 False。</td></tr><tr><td style="text-align:left">not in</td><td style="text-align:left">如果在指定的序列中没有找到值返回 True，否则返回 False。</td></tr></tbody></table><h2 id="身份运算符"><a class="header-anchor" href="#身份运算符">¶</a>身份运算符</h2><p>身份运算符用于比较两个对象的存储单元</p><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">is</td><td style="text-align:left">is 是判断两个标识符是不是引用自一个对象</td></tr><tr><td style="text-align:left">is not</td><td style="text-align:left">is not 是判断两个标识符是不是引用自不同对象</td></tr></tbody></table><p>is 与 == 区别：</p><p>is 用于判断两个变量引用对象是否为同一个， == 用于判断引用变量的值是否相等。</p><h2 id="运算符优先级"><a class="header-anchor" href="#运算符优先级">¶</a>运算符优先级</h2><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">**</td><td style="text-align:left">指数 (最高优先级)</td></tr><tr><td style="text-align:left">~ + -</td><td style="text-align:left">按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@)</td></tr><tr><td style="text-align:left">* / % //</td><td style="text-align:left">乘，除，求余数和取整除</td></tr><tr><td style="text-align:left">+ -</td><td style="text-align:left">加法减法</td></tr><tr><td style="text-align:left">&gt;&gt; &lt;&lt;</td><td style="text-align:left">右移，左移运算符</td></tr><tr><td style="text-align:left">&amp;</td><td style="text-align:left">位 ‘AND’</td></tr><tr><td style="text-align:left">^ |</td><td style="text-align:left">位运算符</td></tr><tr><td style="text-align:left">&lt;= &lt; &gt; &gt;=</td><td style="text-align:left">比较运算符</td></tr><tr><td style="text-align:left">== !=</td><td style="text-align:left">等于运算符</td></tr><tr><td style="text-align:left">= %= /= //= -= += *= **=</td><td style="text-align:left">赋值运算符</td></tr><tr><td style="text-align:left">is is not</td><td style="text-align:left">身份运算符</td></tr><tr><td style="text-align:left">in not in</td><td style="text-align:left">成员运算符</td></tr><tr><td style="text-align:left">not and or</td><td style="text-align:left">逻辑运算符</td></tr></tbody></table><script src="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/WithoutLine.min.js"></script>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础知识学习笔记</title>
      <link href="/stardust14.github.io/2020/07/08/java%E5%AD%A6%E4%B9%A0/"/>
      <url>/stardust14.github.io/2020/07/08/java%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1>定义方法</h1><h3 id="1、定义一个方法（函数）的格式："><a class="header-anchor" href="#1、定义一个方法（函数）的格式：">¶</a>1、定义一个方法（函数）的格式：</h3><pre><code class="language-java">public static void 方法名称()&amp;#123;方法体&amp;#125;</code></pre><h3 id="2、调用方法（函数），格式："><a class="header-anchor" href="#2、调用方法（函数），格式：">¶</a>2、调用方法（函数），格式：</h3><p>方法名称();</p><p>对于byte/short/char三种类型来说，如果右侧赋值的数值没有超过范围，那么Java编译器将会自动隐含的为我们补上一个（byte）（short）（char）<!--强制转换--></p><h1>循环</h1><p><strong>三种循环的区别。</strong></p><p>1、如果条件判断从来没有满足过，那么for循环和while循环将会执行0次，但是do-while循环会执行至少一次。</p><p>2、for循环的变量在小括号当中定义，只有循环内部才可以使用。while循环和do-while循环初始化语句本来就在外面，所以出来循环之后还可以继续使用。</p><p><strong>break关键字的用法有常见的两种:</strong><br>1.可以用在switch语句当中，一旦执行，整个switch语句立刻结束。<br>2.还可以用在循环语句当中，-一 旦执行，整个循环语句立刻结束。打断循环。<br>关于循环的选择，有一个小建议:<br>凡是次数确定的场景多用for循环;否则多用while循环。|</p><p><strong>另一种循环控制语句是continue关键字。</strong><br>一旦执行，立刻跳过当前次循环剩余内容，马上开始下一次循环。</p><p>永远停不下来的循环，叫做<strong>死循环</strong>。<br>死循环的标准格式:<br>while (true) {<br>循环体</p><p>}</p><h1>IDEA的常用快捷键</h1><table><thead><tr><th>快捷键</th><th style="text-align:left">功能</th></tr></thead><tbody><tr><td><code>Alt+Enter</code></td><td style="text-align:left">导入包，自动修正代码</td></tr><tr><td><code>Ctrl+Y</code></td><td style="text-align:left">删除光标所在行</td></tr><tr><td><code>Ctrl+D</code></td><td style="text-align:left">复制光标所在行的内容，插入光标位置下面</td></tr><tr><td><code>Ctrl+Alt+L</code></td><td style="text-align:left">格式化代码（使代码规整）</td></tr><tr><td><code>Ctrl+/</code></td><td style="text-align:left">单行注释，再按取消注释</td></tr><tr><td><code>Ctrl+Shift+/</code></td><td style="text-align:left">选中代码注释，多行注释，再按取消注释</td></tr><tr><td><code>Alt+Ins</code></td><td style="text-align:left">自动生成代码，toString, get, set等方法</td></tr><tr><td><code>Alt+Shift+上下箭头</code></td><td style="text-align:left">移动当前代码行</td></tr><tr><td><code>Alt+4</code></td><td style="text-align:left">控制台调出</td></tr><tr><td><code>Alt+/</code></td><td style="text-align:left">缩写提示</td></tr><tr><td><code>shift+F6</code></td><td style="text-align:left">对每个相同的变量一次性改变</td></tr><tr><td><code>数字.fori</code></td><td style="text-align:left">for循环的快捷方式,【正序】</td></tr><tr><td><code>数字.forr</code></td><td style="text-align:left">for循环的快捷方式,【逆序】</td></tr></tbody></table><p><strong>注意事项:</strong><br>对于有返回值的方法，可以使用单独调用、打印调用或者赋值调用。<br>但是对于无返回值的方法，只能使用单独调用，不能使用打印调用或者赋值调用。</p><h1>方法</h1><p><strong>使用方法的时候，注意事项:</strong><br>1、方法应该定义在类当中，但是不能在方法当中再定义方法。不能嵌套。<br>2、方法定义的前后顺序无所谓。<br>3、方法定义之后不会执行，如果希望执行，- -定要调用:单独调用、打印调用、赋值调用。<br>4、如果方法有返回值，那么必须写.上“return 返回值;”，不能没有。</p><p>5、return后面的返回值数据，必须和方法的返回值类型，对应起来。<br>6、对于一个void没有返回值的方法，不能写return后面的返回值，只能写return自己。</p><p>7、对于void方法，对于方法当中最后一行的return可以省略不写。</p><p>8、一个方法当中可以有多个return语句，但是必须保证同时只有一个会被执行到，两个return不能连写。</p><p>判断是否一般用Boolean值</p><h2 id="方法重载（overload）"><a class="header-anchor" href="#方法重载（overload）">¶</a><strong>方法重载（overload）</strong></h2><p>多个方法的名称一样，但是参数列表不一样</p><p>好处是只需要记住唯一一个方法名称，就可以实现类似的多个功能。</p><p>在调用输出语句的时候，println方法其实就是进行了多种数据类型的重载形式。</p><p><strong>方法重载与下列因素相关:</strong><br>1、参数个数不同<br>2、参数类型不同<br>3、参数的多类型顺序不同<br><strong>方法重载与下列因素无关:</strong><br>1、与参数的名称无关<br>2、与方法的返回值类型无关</p><h3 id="练习题（方法重载）"><a class="header-anchor" href="#练习题（方法重载）">¶</a>练习题（方法重载）</h3><p>1、这题也包括了Boolean的是否判断的方法<img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/stardust14/picture/master/img/20200711220604.png" alt="image-20200711220601237"></p><p>2、判断是否是重载</p><pre><code class="language-java">public static void open()&amp;#123;&amp;#125; //正确重载public static void open(int a)&amp;#123;&amp;#125; //正确重载.static void open(int a,int b)&amp;#123;&amp;#125; //代码错误:和第8行冲突public static void open(double a,int b)&amp;#123;&amp;#125; //正确重载public static void open(int. a,double. b)&amp;#123;&amp;#125; //代码错误:和第6行冲突public void open(int i,double d)&amp;#123;&amp;#125; //代码错误:和第5行冲突public static void OPEN()&amp;#123;&amp;#125; //代码正确不会报错，但是并不是有效重载public static void. open(int i,int j)&amp;#123;&amp;#125; //代码错误:和第3行冲突</code></pre><h1>数组</h1><h2 id="数组的概念"><a class="header-anchor" href="#数组的概念">¶</a>数组的概念</h2><pre><code class="language-java">/*数组的初始化:在内存当中创建一个数组， 并且向其中赋予一些默认值。两种常见的初始化方式:1.动态初始化(指定长度)2.静态初始化(指定内容)动态初始化数组的格式:数据类型[]数组名称= new 数据类型[数组长度];解析含义:左侧数据类型:也就是数组当中保存的数据，全都是统-的什么类型左侧的中括号:代表我是一个数组左侧数组名称:给数组取一个名字右侧的new:代表创建数组的动作右侧数据类型:必须和左边的数据类型保持-致右侧中括号的长度:也就是数组当中，到底可以保存多少个数据，是一个int数字*/</code></pre><p><strong>区别</strong></p><pre><code class="language-java">/*动态初始化(指定长度) :在创建数组的时候，直接指定数组当中的数据元素个数。静态初始化(指定内容) :在创建数组的时候，不直接指定数据个数多少，而是直接将具体的数据内容进行指定。静态初始化基本格式:数据类型[]数组名称= new 数据类型[] &amp;#123;元素1,元素2，... &amp;#125;;*/</code></pre><p>使用静态初始化数组的时候，格式还可以省略一下。<br>标准格式:<br>数据类型[]数组名称= neW  数据类型[] {元素1,元素2，… };<br>省略格式:<br>数据类型[]数组名称= {元素1,元素2，… };</p><p><strong>注意事项:</strong><br>1.静态初始化没有直接指定长度，但是仍然会自动推算得到长度。<br>2.静态初始化标准格式可以拆分成为两个步骤。<br>3.动态初始化也可以拆分成为两个步骤。<br>4.静态初始化一 旦使用省略格式，就不能拆分成为两个步骤了。<br><strong>使用建议:</strong><br>如果不确定数组当中的具体内容，用动态初始化;否则，已经确定了具体的内容，用静态初始化。|</p><p>直接打印数组名称，得到的是数组对应的:内存地址哈希值<br>**访问数组元素的格式:**数组名称[索引值]<br>索引值:就是一个int数字，代表数组当中元素的编号。<br>[注意]索引值从开始，- -直到“数组的长度-1为止。</p><p>使用<strong>动态初始化数组</strong>的时候，其中的元素将会自动拥有一个默认值。规则如下:<br>如果是整数类型，那么默认为0;<br>如果是浮点类型，那么默认为0.0;<br>如果是字符类型，那么默认为’\u0000’;（看不见）<br>如果是布尔类型，那么默认为false;<br>如果是引用类型，那么默认为null。</p><p><strong>注意事项:</strong><br>静态初始化其实也有默认值的过程，只不过系统自动马.上将默认值替换成为了大括号当中的具体数值。</p><h2 id="内存划分"><a class="header-anchor" href="#内存划分">¶</a>内存划分</h2><p>Java的内存需要划分成为5个部分:<br>1.<strong>栈(Stack)</strong> :存放的都是方法中的局部变量。<br>局部变量:方法的参数，或者是方法{}内部的变量<br>作用域:一旦超出作用域，立刻从栈内存当中消失。<br>2.<strong>堆(Heap)</strong> :凡是new出来的东西,都在堆当中。<br>堆内存里面的东西都有一个地址值: 11 6进制<br>堆内存里面的数据，都有默认值。规则:<br>如果是整数默认为0<br>如果是浮点数默认为0.0<br>如果是字符默认为’\u0000’<br>如果是布尔默认为false<br>如果是引用类型默认为null<br>3.<strong>方法区(Method Area)</strong> :存储.class相关信息，包含方法的信息。<br>4.<strong>本地方法栈(Native Method Stack)</strong> :与操作系统相关。<br>5.**寄存器(**pc Register) :与CPU相关。</p><h2 id="数组的内存图"><a class="header-anchor" href="#数组的内存图">¶</a>数组的内存图</h2><p><strong>一个数组的内存图：</strong></p><p><img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/stardust14/picture/master/img/20200712164516.png" alt="image-20200712164514236"></p><p><strong>两个数组的内存图：</strong></p><p><img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/stardust14/picture/master/img/20200712165859.png" alt="image-20200712165123071"></p><p><strong>两个引用指向同一个数组的内存图</strong></p><p><img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/stardust14/picture/master/img/20200712165840.png" alt="image-20200712165838206"></p><h2 id="常见的问题"><a class="header-anchor" href="#常见的问题">¶</a>常见的问题</h2><h3 id="1、数组索引越界异常"><a class="header-anchor" href="#1、数组索引越界异常">¶</a><strong>1、数组索引越界异常</strong></h3><p>如果访问数组元素的时候，索引编号并不存在，那么将会发生数组索引越界异常<br><code>ArrayIndexOutOfBoundsException</code><br>原因:索引编号写错了。<br>解决:修改成为存在的正确索引编号。</p><h3 id="2、空指针异常"><a class="header-anchor" href="#2、空指针异常">¶</a>2、空指针异常</h3><p>所有的引用类型变量，都可以赋值为一-个null值。但是代表其中什么都没有。<br>数组必须进行new初始化才能使用其中的元素。<br>如果只是赋值了一个null，没有进行new创建，<br>那么将会发生:<br>空指针异常<code>NullPointerException</code><br><strong>原因</strong>:忘了new<br><strong>解决</strong>:补上new</p><h2 id="获取数组的长度"><a class="header-anchor" href="#获取数组的长度">¶</a>获取数组的长度</h2><p>如何获取数组的长度，格式:<br>数组名称. length<br>这将会得到一个int数字，代表数组的长度。<br>数组一旦创建，程序运行期间，<em><strong>长度不可改变</strong></em>。</p><p><img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/stardust14/picture/master/img/20200712171637.png" alt="image-20200712171219524"></p><p><strong>数组的遍历输出：使用for循环</strong></p><p><strong>数组的最值：使用for循环和if判断</strong></p><h2 id="数组元素反转"><a class="header-anchor" href="#数组元素反转">¶</a>数组元素反转</h2><p><img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/stardust14/picture/master/img/20200713111225.png" alt="image-20200713111223768"></p><pre><code class="language-java">pub1ic class Demo07ArrayReverse &amp;#123;public static void main(String[] args) &amp;#123;int[] array = &amp;#123; 10，20，30，40, 50 &amp;#125;;//遍历打印数组本来的样子for (int i = 0; i &lt; array.1ength; i++) &amp;#123;System. out. println(array[i]);System.out. println(&quot;===========&quot;);/*初始化语句: int min =日, max = array. length - 1条件判断: min &lt; max步进表达式: min+t, max--循环体:用第三个变量倒手*/for (int min = 0, max = array.1ength - 1; min &lt; max; min++, max--) &amp;#123;int temp = array[min] ;array[min] = array[max];array[max] = temp;&amp;#125;I//再次打印遍历输出数组后来的样子for (int i = 0; i &lt; array.1ength; i++) &amp;#123;System. out. println(array[i]);&amp;#125;&amp;#125;</code></pre><h2 id="数组作为方法参数"><a class="header-anchor" href="#数组作为方法参数">¶</a>数组作为方法参数</h2><pre><code class="language-java">/*数组可以作为方法的参数。当调用方法的时候，向方法的小括号进行传参，传递进去的其实是数组的地址值。*/pub1ic class Demo01ArrayParam &amp;#123;public static void main(String[] args) &amp;#123;int[]array=&amp;#123;_10，20，30，40，50&amp;#125;;System. out . println(array); //地址值printArray(array); //传递进去的就是array当中保存的地址值System . out. println(&quot;==========AAA==========&quot;);printArray(array);System. out. println(&quot;==========BBB-=========&quot;);printArray(array);&amp;#125;/*三要素返回值类型:只是进行打印而已，不需要进行计算，也没有结果，用void方法名称: printArray参数列表:必须给我数组，我才能打印其中的元素。int[] array*/public static void printArray(int[] array) &amp;#123;System . out. println(&quot;printArray方法收到的参数是: &quot;);System. out . println(array); //地址值for (int i = 0; i &lt; array. length; i++) &amp;#123;System. out. println(array[i]);&amp;#125;&amp;#125;</code></pre><p>得到的结果：</p><p><img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/stardust14/picture/master/img/20200713112817.png" alt="image-20200713112816224"></p><h2 id="数组作为方法返回值"><a class="header-anchor" href="#数组作为方法返回值">¶</a>数组作为方法返回值</h2><pre><code class="language-java">/*一个方法可以有0、1、多个参数;但是只能有0或者1个返回值，不能有多个返回值。如果希望一个方法当中产生了多个结果数据进行返回，怎么办?解决方案:使用一个数组作为返回值类型即可。任何数据类型都能作为方法的参数类型，或者返回值类型。数组作为方法的参数，传递进去的其实是数组的地址值。数组作为方法的返回值，返回的其实也是数组的地址值。*/public class Demo02ArrayReturn &amp;#123;public static void main(String[] args) &amp;#123;int[] result = calculate( a: 10，b: 20，C: 30);    System. out . println( &quot;main方法接收到的返回值数组是: &quot;);System. out. println(result);System. out. println(&quot;总和: &quot; + result[0]);System. out. println(&quot;平均数:&quot; + result[1]);public static int[] calculate(int a, int b，int c) &amp;#123;intsum=a+b+c;//总和intavg=sum/3;//平均数//两个结果都希望进行返回//需要一个数组，也就是一个塑料兜，数组可以保存多个结果/*这是一种方法int[] array = new int[2];array[0] = sum; //总和array[1] = avg; //平均数*/    //这是另一种方法int[ ] array = &amp;#123; sum， avg &amp;#125;;    System. out . println(&quot;calculate方法内部数组是: &quot;); System. out . println(array); //地址值return array;&amp;#125;&amp;#125;</code></pre><p>输出的结果：</p><p><img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/stardust14/picture/master/img/20200713113840.png" alt="image-20200713113838924"></p><h1>面向对象思想</h1><h2 id="概述"><a class="header-anchor" href="#概述">¶</a>概述</h2><pre><code class="language-java">/*面向过程:当需要实现-个功能的时候，每一一个具体的步骤都要亲力亲为，详细处理每一个细节 。面向对象:当需要实现一个功能的时候，不关心具体的步骤，而是找一个已经具有该功能的人，来帮我做事儿。*/public class Demo01PrintArray &amp;#123;public static void main(String[] args) &amp;#123;int[] array = &amp;#123; 10，20，30， 40， 50， 60 &amp;#125;;//要求打印格式为: [10, 20，30, 40, 50]//使用面向过程，每一个步骤细节都要 亲力亲为。System. out. print(&quot;[&quot;);for (int i = 0; i &lt; array.1ength; i++) &amp;#123;if (i == array. length - 1) &amp;#123; //如果是最后一个元素System. out . println(array[i] + &quot;]&quot;);&amp;#125; else &amp;#123; //如果不是最后一-个元素System. out . print(array[i] + &quot;，&quot;);&amp;#125;&amp;#125;System. out . print1n(&quot;============&quot;);//使用面向对象        //找一个JDk给我们提供好的Arrays类,//其中有一个toString方法，直接就能把数组变成想要的格式的字符串System. out . println(Arrays . toString(array));&amp;#125;&amp;#125;</code></pre><p>●面向过程:强调步骤。<br>●面向对象:强调对象，这里的对象就是洗衣机。</p><p>特点：</p><p>面向对象思想是一种更符合我们思考习惯的思想，它可以将复杂的事情简单化，并将我们从执行者变成了指挥者。<br>面向对象的语言中，包含了三大<strong>基本特征</strong>，即封装、继承和多态。</p><h2 id="类和对象"><a class="header-anchor" href="#类和对象">¶</a>类和对象</h2><h3 id="类"><a class="header-anchor" href="#类">¶</a>类</h3><p>●类:是一组相关属性和行为的集合。可以看成是一 类事物的模板,使用事物的属性特征和行为特征来描述该类<br>事物。<br>现实中，描述一类事物:<br>●属性:就是该事物的状态信息。<br>●行为:就是该事物能够做什么。</p><h3 id="对象"><a class="header-anchor" href="#对象">¶</a>对象</h3><p>●对象:是一类事物的具体体现。对象是类的一个实例(对象并不是找个女朋友) ,必然具备该类事物的属性和行为。</p><h3 id="类和对象的关系"><a class="header-anchor" href="#类和对象的关系">¶</a>类和对象的关系</h3><p>●类是对一类事物的描述,是抽象的。<br>●对象是一类事物的实例，是具体的。<br>●类是对象的模板，对象是类的实体。</p><h2 id="类的定义"><a class="header-anchor" href="#类的定义">¶</a>类的定义</h2><h3 id="事物与类的对比"><a class="header-anchor" href="#事物与类的对比">¶</a>事物与类的对比</h3><p>现实世界的一类事物:<br><strong>属性</strong>:事物的状态信息。<br><strong>行为</strong>:事物能够做什么。<br>Java中用class描述事物也是如此:<br><strong>成员变量</strong>:对应事物的属性<br><strong>成员方法</strong>:对应事物的行为</p><h3 id="类定义的格式"><a class="header-anchor" href="#类定义的格式">¶</a>类定义的格式</h3><pre><code class="language-java">public class ClassName &amp;#123;//成员变量//成员方法&amp;#125;</code></pre><p>●<strong>定义类:<strong>就是定义类的成员，包括成员变量和成员方法。<br>●</strong>成员量:<strong>和以前定义变量几乎是一样的。只不过位置发生了改变。<strong>在类中，方法外。</strong><br>●</strong>成员方法:<strong>和以前定义方法几乎是一样的。只不过把</strong>static</strong>去掉， <strong>static</strong>的作用在面向对象后面课程中再详细讲解。</p><p><strong>注意事项:</strong><br>1.成员变量是直接定义在类当中的，在方法外边。<br>2.成员方法不要写static关键字。</p><h2 id="对象的创建及其使用"><a class="header-anchor" href="#对象的创建及其使用">¶</a>对象的创建及其使用</h2><pre><code class="language-java">/*通常情况下，一个类并不能直接使用，需要根据类创建一个对象， 才能使用。1.导包:也就是指出需要使用的类，在什么位置。import包名称.类名称;import cn. itcast. day06. demo01. Student;对于和当前类属于同一-个包的情况，可以省略导包语句不写。2.创建,格式:类名称对象名= new类名称();Student stu = new Student();3.使用，分为两种情况:使用成员变量:对象名.成员变量名使用成员方法:对象名.成员方法名(参数)(也就是，想用谁，就用对象名点儿谁。)注意事项:如果成员变量没有进行赋值，那么将会有一个默认值，规则和数组一样。*/public static void main(String[] args) &amp;#123;// 1.导包。//我需要使用的Student类,和我自己Demo02Student位于同一一个包下，所以省略导包语句不写// 2.创建，格式://类名称对象名= new类名称();//根据Student类，创建了一个名， 为stu的对象Student stu = new Student();    // 3.使用其中的成员变量，格式://对象名.成员变量名.System. out. println(stu. name); // nullSystem. out . println(stu.age); //0System. out . print1n(&quot;==========&quot;);    //改变对象当中的成员变量数值内容//将右侧的字符串，赋值交给stu对象当中的name成员变量stu.name =“赵丽颖”;stu.age = 18;System. out . println(stu.name); //赵丽颖System. out . println(stu.age); // 18    System. out . print1n(&quot;==========&quot;);        // 4.使用对象的成员方法，格式://对象名.成员方法名()stu.eat();//吃饭饭！&amp;#125;</code></pre><h3 id="手机类的练习题"><a class="header-anchor" href="#手机类的练习题">¶</a>手机类的练习题</h3><pre><code class="language-java">/*这是手机类定义一个类，用来模拟“手机”事物。属性:品牌、价格、颜色行为:打电话、发短信对应到类当中:成员变量(属性) :String brand; //品牌double price; //价格.String color; //颜色成员方法(行为) :public void call(String who) &amp;#123;&amp;#125; //打电话public void sendMessage() &amp;#123;&amp;#125; //群发短信*/pub1ic class Phone &amp;#123;//成员变量String brand; //品牌double price; //价格String color; //颜色//成员方法public void call(String who) &amp;#123;System. out. println(&quot;给&quot; + who + &quot;打电话&quot;);&amp;#125;public void sendMessage() &amp;#123;System. out . println(&quot;群发短信&quot;);&amp;#125;&amp;#125;</code></pre><pre><code class="language-java">//调用phonepublic static void main(String[] args) &amp;#123;//根据Phone类，创建一个名为 one的对象//格式:类名称对象名= new类名称();Phone one = new Phone();System. out. println(one.brand); // nullSystem. out . println(one.price); // 0.0System. out . println(one.co1or); // nullSystem. out. println(&quot;=========&quot;);one.brand = &quot;苹果&quot;;one.price = 8388.0;one.color = &quot;黑色&quot;;System. out . println(one . brand); //苹果System. out. println(one.price); // 8388.0System. out . println(one.color); //黑色    System. out. println(&quot;=========&quot;);        one.call( who:&quot;乔布斯&quot;) ;one.sendMessage();&amp;#125;</code></pre><h2 id="一个对象的内存图"><a class="header-anchor" href="#一个对象的内存图">¶</a>一个对象的内存图</h2><p>new的东西全在堆之中</p><p>压栈，先来的在底下，后进先出，先进后出</p><p>黑色的X代表出栈</p><p><img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/stardust14/picture/master/img/20200715185054.png" alt="image-20200715184735566"></p><h2 id="两个对象使用同一个方法的内存图"><a class="header-anchor" href="#两个对象使用同一个方法的内存图">¶</a>两个对象使用同一个方法的内存图</h2><p><img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/stardust14/picture/master/img/20200715185842.png" alt="image-20200715185840625"></p><h2 id="两个引用指向同一个对象的内存图"><a class="header-anchor" href="#两个引用指向同一个对象的内存图">¶</a>两个引用指向同一个对象的内存图</h2><p><img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/stardust14/picture/master/img/20200715190554.png" alt="image-20200715190552009"></p><h2 id="使用对象类型作为方法的参数"><a class="header-anchor" href="#使用对象类型作为方法的参数">¶</a>使用对象类型作为方法的参数</h2><p><img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/stardust14/picture/master/img/20200716224605.png" alt="image-20200716223939500"></p><p><strong>注意：<strong>当一个对象作为参数，传递到方法当中时，实际上传递进去的是对象的</strong>地址值</strong>。</p><h2 id="使用对象类型作为方法的返回值"><a class="header-anchor" href="#使用对象类型作为方法的返回值">¶</a>使用对象类型作为方法的返回值</h2><p><img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="../../../picture/PicGo/copypicture/image-20200717164340634.png" alt="image-20200717164340634"></p><h2 id="成员变量和局部变量的区别"><a class="header-anchor" href="#成员变量和局部变量的区别">¶</a>成员变量和局部变量的区别</h2><p>局部变量和成员变量<br>1.定义的位置不一样[重点]<br>局部变量:在方法的内部<br>成员变量:在方法的外部，直接写在类当中<br>2.作用范围不一样[重点]<br>局部变量:只有方法当中才可以使用，出了方法就不能再用<br>成员变量:整个类全都可以通用,<br>3.默认值不一样[重点]<br>局部变量:没有默认值，如果要想使用，必须手动进行赋值<br>成员变量:如果没有赋值，会有默认值，规则和数组一样<br>方法的参数就是局部变量，参数在方法调用的时候，必然会被赋值的<br>4.内存的位置不一样(了解)<br>局部变量:位于栈内存<br>成员变量:位于堆内存<br>5.生命周期不一样(了解)<br>局部变量:随着方法进栈而诞生，随着方法出栈而消失<br>成员变量:随着对象创建而诞生，随着对象被垃圾回收而消失</p><h2 id="面向对象三大特征之封装性"><a class="header-anchor" href="#面向对象三大特征之封装性">¶</a>面向对象三大特征之封装性</h2><p>面向对象三大特征:封装、继承、多态。<br>封装性在Java当中的体现:<br>1.方法就是一种封装<br>2.关键字private也是一种封装<br>封装就是将一些细节信息隐藏起来， 对于外界不可见。</p><pre><code class="language-java">/*问题描述:定义Person的年龄时，无法阻止不合理的数值被设置进来。解决方案:用private关键字将需要保护的成员变量进行修饰。一旦使用了private进行修饰，那么本类当中仍然可以随意访问。但是!超出了本类范围之外就不能再直接访问了。间接访问private成员变量，就是定义一对儿Getter/Setter方法必须叫setXxx或者是getXxx命名规则。对于Getter来说，不能有参数，返回值类型和成员变量对应;对于Setter来说，不能有返回值，参数类型和成员变量对应。*/public class Person &amp;#123;    String name; // 姓名.private int age; //年龄pub1ic void show() &amp;#123;System. out . println(&quot;我叫:&quot;+ name + &quot;,年龄:&quot; + age);//这个成员方法，专门用于向age设置数据,往age里放public void setAge(int num) &amp;#123;//set必须有参数无返回值voidif(num&lt;100&amp;&amp;num&gt;=0)&amp;#123;//如果是合理情况age = num;&amp;#125; else &amp;#123;System. out. println( &quot;数据不合理! &quot;);&amp;#125;    &amp;#125;        //这个成员方法，专门私语获取age的数据public int getAge() &amp;#123;//get必须没有参数，有返回值return age;        &amp;#125;  &amp;#125;</code></pre><pre><code class="language-java">public class Demo03Person &amp;#123;public static void main(String[] args) &amp;#123;Person person = new Person();person. show( ) ;person. name =“赵丽颖&quot;;//person. age= -20; //直接访问private内容，错误写法!person. setAge(20) ;|person. show();&amp;#125;&amp;#125;</code></pre><h2 id="练习题"><a class="header-anchor" href="#练习题">¶</a>练习题</h2><pre><code class="language-java">/*对于基本类型当中的boolean值，Getter方法一 -定 要写成isXxx的形式，而setXxx规则不变。*/public class Student &amp;#123;    private String name; //姓名private int age; //年龄private boolean male; //是不是爷们儿    public void setMale(boolean b) &amp;#123;male=b;&amp;#125;    public boolean isMale() &amp;#123;return male ;    &amp;#125;    public void setName(String str) &amp;#123;name = str;&amp;#125;    public String getName() &amp;#123;return name;&amp;#125;    public void setAge(int num) &amp;#123;age = num;&amp;#125;&amp;#125;</code></pre><h2 id="this关键字的作用"><a class="header-anchor" href="#this关键字的作用">¶</a>this关键字的作用</h2><p>当方法的局部变量和类的成员变量重名的时候，根据“就近原则”，优先使用局部变量。<br>如果需要访问本类当中的成员变量，需要使用格式:<br>this.成员变量名<br>“通过谁调用的方法，谁就是this。”</p><pre><code class="language-java">publiC class Person &amp;#123;String name; //我自己的名字//参数name是对方的名字//成员变量name是自己的名字public void sayHello(String name) &amp;#123;System. out . println(name + &quot;,你好。我是&quot;+ this. name);&amp;#125;&amp;#125;</code></pre><h2 id="构造方法"><a class="header-anchor" href="#构造方法">¶</a>构造方法</h2><p>构造方法是专门用来创建对象的方法，当我们通过关键字new来创建对象时，其实就是在调用构造方法。<br>格式:<br>public类名称(参数类型参数名称) {<br>方法体<br>注意事项:<br>1.构造方法的名称必须和所在的类名称完全-样，就连大小写也要一样<br>2.构造方法不要写返回值类型，连void都不写<br>3.构造方法不能return一个具体的返回值<br>4.如果没有编写任何构造方法，那么编译器将会默认赠送一 个构造方法，没有参数、方法体什么事情都不做。<br>public Student() {}<br>5.一旦编写了至少一个构造方法，那么编译器将不再赠送。<br>6.构造方法也是可以进行重载的。<br>重载:方法名称相同，参数列表不同。</p><pre><code class="language-java">public class Student &amp;#123;private String name;private int age; public Student() &amp;#123;System. out . print1n(“无参构造方法执行啦! &quot;);&amp;#125;public Student(String name, int age) &amp;#123;System. out . println(&quot;全参构造方法执行啦! &quot;);this.name = name ;this.age = age;&amp;#125;    public void setName(String name) &amp;#123;this.name = name;&amp;#125;public String getName() &amp;#123;return name ;&amp;#125;public void setAge(int age) &amp;#123;this.age = age;&amp;#125;public int getAge() &amp;#123;return age;&amp;#125;&amp;#125;</code></pre><pre><code class="language-java">public class Demo02Student &amp;#123;public static void main(String[] args) &amp;#123;Student stul = new Student(); //无参构造System. out . println(&quot;===========&quot;);Student stu2 = new Student( name: “赵丽颖&quot;，age: 20); //全参构造System. out . println(&quot;姓名:”+ stu2. getName() + &quot;，年龄:”+ stu2.getAge());        //如果需要改变对象当中的成员变量数据内容，仍然还需要使用setXxx方法stu2. setAge(21); //改变年龄System. out . println(&quot;姓名:”+ stu2.getName() + &quot;，年龄:”+ stu2.getAge());               &amp;#125;&amp;#125;</code></pre><h2 id="定义一个标准的类"><a class="header-anchor" href="#定义一个标准的类">¶</a>定义一个标准的类</h2><p><strong>一个标准的类通常要拥有下面四个组成部分:</strong><br><strong>1.所有的成员变量都要使用private关键字修饰</strong><br><strong>2.为每一个成员变量编写一对儿Getter/Setter方法</strong><br><strong>3.编写一个无参数的构造方法</strong><br><strong>4.编写一个全参数的构造方法</strong><br><strong>这样标准的类也叫做Java Bean</strong></p><p><strong>自动生成</strong>*<u>Getter/Setter方法</u>*：Code----&gt;Generate(Alt+inset)-----&gt;Getter and Setter------&gt;全部选中（shift）+ok</p><p><strong>自动生成</strong>*<u>无参数的构造方法</u>*：Code----&gt;Generate(Alt+inset)-----&gt;Constructor-------&gt;Select None</p><p><strong>自动生成</strong>*<u>全参数的构造方法</u>*：Code----&gt;Generate(Alt+inset)-----&gt;Constructor-------&gt;全部选中（shift）+ok</p><pre><code class="language-java">public class Student &amp;#123;    private String name;//姓名    private int age;//年龄    public Student() &amp;#123;    &amp;#125;    public Student(String name, int age) &amp;#123;        this.name = name;        this.age = age;    &amp;#125;    public String getName() &amp;#123;        return name;    &amp;#125;    public void setName(String name) &amp;#123;        this.name = name;    &amp;#125;    public int getAge() &amp;#123;        return age;    &amp;#125;    public void setAge(int age) &amp;#123;        this.age = age;    &amp;#125;&amp;#125;</code></pre><pre><code class="language-java">public class Dome01Student &amp;#123;    public static void main(String[] args) &amp;#123;        Student stu1 = new Student();        stu1.setName(&quot;霉霉&quot;);        stu1.setAge(20);        System.out.println(&quot;姓名：&quot;+stu1.getName() +&quot;年龄：&quot;+stu1.getAge());        System.out.println(&quot;================&quot;);        Student stu2 = new Student(&quot;水果姐&quot;,20);        System.out.println(&quot;姓名：&quot;+stu2.getName() +&quot;年龄：&quot;+stu2.getAge());        stu2.setAge(22);        System.out.println(&quot;姓名：&quot;+stu2.getName() +&quot;年龄：&quot;+stu2.getAge());    &amp;#125;&amp;#125;</code></pre><h1>API</h1><h2 id="概述-v2"><a class="header-anchor" href="#概述-v2">¶</a>概述</h2><p>API(Application Programming Interface),应用程序编程接口。Java API是一本程序员的<code>字典</code>，是JDK中提供给我们使用的类的<strong>说明文档</strong>。这些类将底层的代码实现封装了起来，我们不需要关心这些类是如何实现的,只需要学习这些类如何使用即可。所以我们可以通过查询API的方式，来学习Java提供的类，并得知如何使用它们。</p><h2 id="API使用步骤"><a class="header-anchor" href="#API使用步骤">¶</a>API使用步骤</h2><p>1.打开帮助文档。<br>2.点击显示，找到索引，看到输入框。<br>3.你要找谁?在输入框里输入，然后回车。<br>4.看包。java.lang 下的类不需要导包，其他需要。<br>5.看类的解释和说明。<br>6.学习构造方法。<br>7.使用成员方法。</p><h2 id="Scanner类"><a class="header-anchor" href="#Scanner类">¶</a>Scanner类</h2><h3 id="概述-v3"><a class="header-anchor" href="#概述-v3">¶</a>概述</h3><p>一个可以解析基本类型和字符串的简单文本扫描器。<br>例如，以吓代码使用户能够从System.in中读取一个数:</p><pre><code class="language-java">Scanner sC = new Scanner(System. in);int i = sc.nextInt();</code></pre><blockquote><p>备注: <a href="http://System.in">System.in</a> 系统输入指的是通过键盘录入数据。</p></blockquote><h3 id="使用步骤"><a class="header-anchor" href="#使用步骤">¶</a>使用步骤</h3><pre><code class="language-java">import java. util . Scanner;// 1.导包/***Scanner类的功能:**可以实现键盘输入数据，到程序当中。引用类型的一般使用步骤: **1.导包**import包路径.类名称;如果需要使用的目标类，和当前类位于同- -个包下，则可以省略导包语句不写。只有java. lang包下的内容不需要导包，其他的包都需要import语句。**2.创建**类名称对象名= new 类名称();**3.使用**对象名.成员方法名()获取键盘输入的一个int数字: int num = sc. nextInt();获取键盘输入的一个字符串: String str =sc.next();*/public class Demo01Scanner &amp;#123;    public static void main(String[] args) &amp;#123;// 2.创建//备注: System. in代表从键盘进行输入Scanner sc = new Scanner(System. in);// 3.获取键盘输入的int数字int num = sc.nextInt( );System. out. println( &quot;输入的int数字是:&quot; + num);       // 4.获取键盘输入的字符串String str = sc.next( );System. out . println( &quot;输入的字符串是:&quot; + str);&amp;#125;&amp;#125;</code></pre><h4 id="练习题-v2"><a class="header-anchor" href="#练习题-v2">¶</a>练习题</h4><p>1、键盘输入两个int数字，并求出和值</p><pre><code class="language-java">import java.util.Scanner;public class Dome01ScannerSum &amp;#123;    public static void main(String[] args) &amp;#123;        Scanner src = new Scanner(System.in);        System.out.println(&quot;请输入第一个数字：&quot;);        int a = src.nextInt();        System.out.println(&quot;请输入第二个数字：&quot;);        int b = src.nextInt();        int result = a + b ;        System.out.println(&quot;结果是：&quot; + result);    &amp;#125;&amp;#125;</code></pre><p>2、键盘输入三个int数字，然后求出其中的最大值</p><pre><code class="language-java">import java.util.Scanner;/*题目:键盘输入三个int数字，然后求出其中的最大值。思路，芯岭:1.既然是键盘输入，肯定需要用到Scanner2. Scanner三个步骤:导包、创建、使用nextInt()方法3. 既然是三个数字，那么调用三次nextInt()方法，得到三个int变量4.无法同时判断三个数字谁最大，应该转换成为两个步骤:    4.1首先判断前两个当中谁最大，拿到前两个的最大值    4.2拿着前两个中的最大值，再和第三个数字比较，得到三个数字当中的最大值5.打印最终结果 */public class Dome01ScannerMax &amp;#123;    public static void main(String[] args) &amp;#123;        int [] array = new int[]&amp;#123;&amp;#125;;        Scanner src = new Scanner(System.in);        System.out.println(&quot;请输入第一个数字:&quot;);        int a = src.nextInt();        System.out.println(&quot;请输入第二个数字:&quot;);        int b = src.nextInt();        System.out.println(&quot;请输入第三个数字:&quot;);        int c = src.nextInt();       int temp = a &gt; b ? a:b;       int max = temp &gt; c ? temp:c;        System.out.println(&quot;结果：&quot;+max);    &amp;#125;&amp;#125;</code></pre><h2 id="匿名对象的说明"><a class="header-anchor" href="#匿名对象的说明">¶</a>匿名对象的说明</h2><pre><code class="language-java">/*创建对象的标准格式:类名称 对象名= new 类名称();匿名对象就是只有右边的对象，没有左边的名字和赋值运算符。new.类名称();注意事项：匿名对象只能使用唯一-的一 次，下次再用不得不再创建一个新对 象。使用建议:如果确定有一个对象只需要使用唯一 的一 次，就可以用匿名对象。*/public class Dome02Anonymous &amp;#123;    public static void main(String[] args) &amp;#123;        Person one = new Person();        one.name = &quot;泰勒斯威夫特&quot;;//我叫泰勒斯威夫特        one.ShowName();        System.out.println(&quot;=========&quot;);        new Person().name=&quot;Rose&quot;;        new Person().ShowName();//我叫null    &amp;#125;&amp;#125;</code></pre><h2 id="匿名对象作为方法的参数和返回值"><a class="header-anchor" href="#匿名对象作为方法的参数和返回值">¶</a>匿名对象作为方法的参数和返回值</h2><pre><code class="language-java">import java.util.Scanner;public class Dome03Anonymous &amp;#123;    public static void main(String[] args) &amp;#123;        //普通使用方式        Scanner src = new Scanner(System.in);        System.out.println(&quot;请输入数值：&quot;);        int num1 = src.nextInt();        System.out.println(&quot;===========&quot;);        System.out.println(&quot;输入的结果是：&quot;+ num1);        System.out.println(&quot;============&quot;);        //匿名对象的方式        System.out.println(&quot;请输入数值：&quot;);        int num2 = new Scanner(System.in).nextInt();        System.out.println(&quot;输入的结果是：&quot;+ num2);        System.out.println(&quot;============&quot;);        //使用一般方法传入参数//        Scanner sc = new Scanner(System.in);//        methodParam(sc);        //使用匿名对象来进行传递参数        methodParam(new Scanner(System.in));        Scanner sc = methodreturn();        int num3=sc.nextInt();        System.out.println(&quot;输出：&quot;+num3);        System.out.println(&quot;============&quot;);    &amp;#125;    public static void methodParam(Scanner sc)&amp;#123;        int num = sc.nextInt();        System.out.println(&quot;输入的是：&quot;+ num);        System.out.println(&quot;============&quot;);    &amp;#125;    public static Scanner methodreturn()&amp;#123;//        Scanner sc = new Scanner(System.in);//        return sc;        return new Scanner(System.in);    &amp;#125;&amp;#125;</code></pre><h2 id="Random"><a class="header-anchor" href="#Random">¶</a>Random</h2><h3 id="概述和基本使用"><a class="header-anchor" href="#概述和基本使用">¶</a>概述和基本使用</h3><pre><code class="language-java">/*Random类用来生成随机数字。使用起来也是三个步骤:1.导包import java . util . Random;2.创建Random r = new Random(); //小括号当中留空即可3.使用获取一个随机的int数字(范围是int所有范围，有正负两种) : int num =r.nextInt()获取一个随机的int数字(参数代表了范围，左闭右开区间) : int num = r. nextInt(3)实际上代表的含义是: [0,3)， 也就是0~2*/import java.util.Random;public class Dome01Random &amp;#123;    public static void main(String[] args) &amp;#123;        Random r = new Random();        int num = r.nextInt();        System.out.println(&quot;随机数为：&quot;+num);        System.out.println(&quot;============&quot;);        for (int i = 0; i &lt; 100; i++) &amp;#123;            int num1 = r.nextInt(10);            System.out.println(num1);        &amp;#125;    &amp;#125;&amp;#125;</code></pre><h4 id="练习题-v3"><a class="header-anchor" href="#练习题-v3">¶</a>练习题</h4><p>1、生成1-n之间的随机数</p><pre><code class="language-java">import java.util.Random;/*题目要求:根据int变量n的值，来获取随机数字，范围是[1,n]， 可以取到1也可以取到n。思路1.定义一个int变量n，随意赋值2.要使用Random: 三个步骤，导包、创建、使用3.如果写10，那么就是0~9，然而想要的是1~10，可以发现:整体+1即可。4.打印随机数字*/public class Dome02Random &amp;#123;    public static void main(String[] args) &amp;#123;        int n = 10;        Random r = new Random();        //第一种方法            int num = r.nextInt(n);            System.out.println(num + 1);        System.out.println(&quot;==========&quot;);        //第二种方法        int result = r.nextInt(n) + 1;        System.out.println(result);//本来范围是[0,1)，整体+1之后变成了[1,n+1)， 也就是[1,n]    &amp;#125;&amp;#125;</code></pre><p>2、猜数字小游戏</p><pre><code class="language-java">/*题目:用代码模拟猜数字的小游戏。思路:1.首先需要产生一个随机数字，并且- - 旦产生不再变化。用Random的nextInt方法2.需要键盘输入，所以用到了Scanner3.获取键盘输入的数字，用Scanner当中的nextInt方法4.已经得到了两个数字，判断(if) -下:    如果太大了，提示太大，并且重试;    如果太小了，提示太小，并且重试:    如果猜中了，游戏结束。5.重试就是再来一次， 循环次数不确定，用while(true)。*/import java.util.Random;import java.util.Scanner;public class Dome03RandomGame &amp;#123;    public static void main(String[] args) &amp;#123;        Random r = new Random();        int num = r.nextInt(100)+1;//范围是在[1，100]区间        Scanner sc = new Scanner(System.in);        while (true) &amp;#123;            System.out.println(&quot;请输入你猜测的数字：&quot;);            int num1 = sc.nextInt();//读取键盘输入的数字            if (num1 &lt; num) &amp;#123;                System.out.println(&quot;猜测的数字偏小，请重新输入！&quot;);            &amp;#125; else if (num1 &gt; num) &amp;#123;                System.out.println(&quot;猜测的数字偏大，请重新输入！&quot;);            &amp;#125; else&amp;#123;                System.out.println(&quot;恭喜你猜对了！！！！！&quot;);                break;//Game over 退出游戏            &amp;#125;        &amp;#125;    &amp;#125;&amp;#125;</code></pre><h2 id="对象数组"><a class="header-anchor" href="#对象数组">¶</a>对象数组</h2><pre><code class="language-java">/*题目:定义一个数组，用来存储3个Person对象。数组有一个缺点：一旦创建，程序运行期间长度不可以发生改变 */public class Dome04Array &amp;#123;    public static void main(String[] args) &amp;#123;        //首先创建一个长度为3的数组，里面用来存放Person类型的对象        Person [] array = new Person[3];        Person one = new Person(&quot;霉霉&quot;,18);        Person two = new Person(&quot;水果姐&quot;,18);        Person three = new Person(&quot;Rechel&quot;,20);        array[0] = one;  //将one当中的地址值赋值到数组的0号元素位置        array[1] = two;//将two当中的地址值赋值到数组的1号元素位置        array[2] = three;//将three当中的地址值赋值到数组的2号元素位置        System.out.println(array[0].getName() + &quot;  &quot;+ array[0].getAge());        System.out.println(array[1].getName() + &quot;  &quot; + array[1].getAge());        System.out.println(array[2].getName() + &quot;  &quot; + array[2].getAge());    &amp;#125;&amp;#125;</code></pre><h2 id="ArrayList类"><a class="header-anchor" href="#ArrayList类">¶</a>ArrayList类</h2><p><code>java.util. Arraylist</code> 是<strong>大小可变的数组</strong>的实现，存储在内的数据称为元素。此类提供一 些方法来操作内部存储的元素。<code>ArrayList</code> 中可不断添加元素，其大小也自动增长。</p><blockquote><p>和数组的区别：<br>数组的长度不可以发生改变。<br>但是ArrayList集合的长度是可以随意变化的。</p></blockquote><h3 id="基本使用和概述"><a class="header-anchor" href="#基本使用和概述">¶</a>基本使用和概述</h3><pre><code class="language-java">import java.util.ArrayList;/*对于ArrayList来说，有一个尖括号&lt;E&gt;代表泛型。泛型:也就是装在集合当中的所有元素，全都是统- -的什么类型。注意:泛型只能是引用类型，不能是基本类型。注意事项:对于ArrayList集合来说，直接打印得到的不是地址值，而是内容。如果内容是空，得到的是空的中括号: [] */public class Dome05ArrayList &amp;#123;    public static void main(String[] args) &amp;#123;        //创建了一个ArrayList集合，集合的名称是list， 里面装的全都是String字符串类型的数据        //备注:从JDK 1.7+开始，右侧的尖括号内部可以不写内容，但是&lt;&gt;本身还是要写的。        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();        System.out.println(list);        //向集合中放一些数据，需要用到add方法        list.add(&quot;Rose&quot;);        System.out.println(list);        System.out.println(&quot;===========&quot;);        list.add(&quot;Rechel&quot;);        list.add(&quot;Manica&quot;);        list.add(&quot;Jeoy&quot;);        list.add(&quot;Phobe&quot;);        list.add(&quot;Bing&quot;);        System.out.println(list);        //list.add(100);//错误写法!因为创建的时候尖括号泛型已经说了是字符串，                         // 添加进去的元素就必须都是字符串才行    &amp;#125;&amp;#125;</code></pre><h3 id="常用方法和遍历"><a class="header-anchor" href="#常用方法和遍历">¶</a>常用方法和遍历</h3><pre><code class="language-java">import java.util.ArrayList;/*ArrayL ist当中的常用方法有:public boolean add(E e): 向集合当中添加元素，参数的类型和泛型一致。备注:对于ArrayL ist集合来说，add添加动作一定是成功的，所以返回值可用可不用。但是对于其他集合(今后学习)来说，add添加动作不一定成功。public E get(int index): 从集合当中获取元素，参数是索引编号，返回值就是对应位置的元素。public E remove(int index): 从集合当中删除元素，参数是索引编号，返回值就是被删除掉的元素。public int size(): 获取集合的尺寸长度，返回值是集合中包含的元素个数。 */public class Dome01ArrayListMethod &amp;#123;    public static void main(String[] args) &amp;#123;        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();        System.out.println(list);        //向集合中添加元素：add        boolean success = list.add(&quot;柳岩&quot;);        System.out.println(list);        System.out.println(&quot;添加的动作是否成功&quot; + success);        System.out.println(&quot;============&quot;);        list.add(&quot;Rose&quot;);        list.add(&quot;Rechel&quot;);        list.add(&quot;Bing&quot;);        list.add(&quot;Jeoy&quot;);        System.out.println(list);//[柳岩, Rose, Rechel, Bing, Jeoy]        //从集合中获取元素: get。 索引值从开始0开始        String name = list.get(2);        System.out.println(&quot;第二号位索引值为：&quot; + name);//Rechel        System.out.println(&quot;=============&quot;);        //从集合中删除元素：remove。索引值从0开始        String whoRemove = list.remove(0);        System.out.println(list);        System.out.println(&quot;被删除的是：&quot; + whoRemove);        System.out.println(&quot;===========&quot;);        //获取集合的长度，也就是集合中的元素数        int size = list.size();        System.out.println(&quot;集合的长度是：&quot; + size);        System.out.println(list);    &amp;#125;&amp;#125;</code></pre><pre><code class="language-java">import java.util.ArrayList;public class Dome01ArrayListEach &amp;#123;    public static void main(String[] args) &amp;#123;        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();        list.add(&quot;Rose&quot;);        list.add(&quot;Rechel&quot;);        list.add(&quot;Manica&quot;);        list.add(&quot;Chandler&quot;);        list.add(&quot;Pheebs&quot;);        list.add(&quot;Joey&quot;);        //遍历集合        for (int i = 0; i &lt; list.size(); i++) &amp;#123;            System.out.println(list.get(i));        &amp;#125;    &amp;#125;&amp;#125;</code></pre><h3 id="集合存储基本数据类型"><a class="header-anchor" href="#集合存储基本数据类型">¶</a>集合存储基本数据类型</h3><pre><code class="language-java">/*如果希望向集合ArrayList当中存储基本类型数据，必须使用基本类型对应的“包装类”。从JDK 1.5+开始， 支持自动装箱、自动拆箱。自动装箱:基本类型--&gt; 包装类型（引用类型）自动拆箱:包装类型--&gt;基本类型 */import java.util.ArrayList;public class Dome01ArrayListBasic &amp;#123;    public static void main(String[] args) &amp;#123;        ArrayList&lt;String&gt; listA = new ArrayList&lt;&gt;();        //错误写法!泛型只能是引用类型，不能是基本类型       //ArrayList&lt;int&gt; listB = new ArrayList&lt;&gt;();        ArrayList&lt;Integer&gt; listC = new ArrayList&lt;&gt;();        listC.add(1000);        listC.add(18888);        listC.add(300);        int num = listC.get(1);        System.out.println(&quot;第一号元素是：&quot; + num);    &amp;#125;&amp;#125;</code></pre><table><thead><tr><th>基本类型</th><th>包装类(引用类型，包装类都位于<code>java. lang</code>包下)</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer          <strong>[特殊]</strong></td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>char</td><td>Character      <strong>[特殊]</strong></td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table><h3 id="练习题-v4"><a class="header-anchor" href="#练习题-v4">¶</a>练习题</h3><h4 id="1、存储随机数字"><a class="header-anchor" href="#1、存储随机数字">¶</a>1、存储随机数字</h4><pre><code class="language-java">import java.util.ArrayList;import java.util.Random;/*题目:生成6个1~33之间的随机整数，添加到集合，并遍历集合。思路:1.需要存储6个数字，创建一个集合， &lt;Integer&gt;2.产生随机数，需要用到Random3.用循环6次，来产生6个随机数字: for循环4.循环内调用r. nextInt(int n)，参数是33，0~32，整体+1才是1~335.把数字添加到集合中: add6.遍历集合: for、size、 get */public class Dome02ArrayListRandom &amp;#123;    public static void main(String[] args) &amp;#123;        ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();        Random r = new Random();        for (int i = 0; i &lt; 6; i++) &amp;#123;            int num = r.nextInt(33);            list.add(num);        &amp;#125;        //遍历集合        for (int j = 0; j &lt; list.size(); j++) &amp;#123;            System.out.println(&quot;第&quot; +j+ &quot;号元素为：&quot; + list.get(j));        &amp;#125;    &amp;#125;&amp;#125;</code></pre><h4 id="2、存储自定义对象"><a class="header-anchor" href="#2、存储自定义对象">¶</a>2、存储自定义对象</h4><pre><code class="language-java">import java.util.ArrayList;/*题目:自定义4个学生对象，添加到集合，并遍历。思路:1.自定义Student学生类， 四个部分。2.创建一个集合，用来存储学生对象。泛型: &lt;Student&gt;3.根据类，创建4个学生对象。4.将4个学生对象添加到集合中: add5.遍历集合: for、size、 get */public class Dome03ArrayListStudent &amp;#123;    public static void main(String[] args) &amp;#123;        ArrayList&lt;Student&gt; list = new ArrayList&lt;&gt;();        Student stu1 = new Student(&quot;Rose&quot;,18);        Student stu2 = new Student(&quot;Pheebs&quot;,23);        Student stu3 = new Student(&quot;Manica&quot;,26);        Student stu4 = new Student(&quot;Rayray&quot;,18);        list.add(stu1);        list.add(stu2);        list.add(stu3);        list.add(stu4);        //遍历集合        for (int i = 0; i &lt; list.size(); i++) &amp;#123;            Student one = list.get(i);            System.out.println(&quot;第&quot; + i + &quot;名学生是：&quot; + one.getName() + &quot;，年龄是：&quot; + one.getAge());        &amp;#125;    &amp;#125;&amp;#125;</code></pre><pre><code class="language-java">public class Student &amp;#123;    private String name;    private int age;    public Student() &amp;#123;    &amp;#125;    public Student(String name, int age) &amp;#123;        this.name = name;        this.age = age;    &amp;#125;    public String getName() &amp;#123;        return name;    &amp;#125;    public void setName(String name) &amp;#123;        this.name = name;    &amp;#125;    public int getAge() &amp;#123;        return age;    &amp;#125;    public void setAge(int age) &amp;#123;        this.age = age;    &amp;#125;&amp;#125;</code></pre><h4 id="3、按指定格式遍历集合"><a class="header-anchor" href="#3、按指定格式遍历集合">¶</a>3、按指定格式遍历集合</h4><pre><code class="language-java">import java.util.ArrayList;/*题目:定义以指定格式打印集合的方法(ArrayList类型作为参数)，使用&amp;#123;&amp;#125;扩起集合，使用@分隔每个元素。格式参照&amp;#123;元素@元素@元素&amp;#125;。System. out. println(list);     [10, 20, 30]printArrayList(list);           &amp;#123;10@20@30&amp;#125; */public class Dome04ArrayListPrint &amp;#123;    public static void main(String[] args) &amp;#123;        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();        list.add(&quot;Rose&quot;);        list.add(&quot;Rachel&quot;);        list.add(&quot;Monica&quot;);        list.add(&quot;Chandler&quot;);        list.add(&quot;Pheebs&quot;);        list.add(&quot;Joey&quot;);        System.out.println(list);        printArraylist(list);    &amp;#125;    /*    定义方法的三要素    返回值类型:只是进行打印而已，没有运算，没有结果，所以用void    方法名称: printArraylist    参数列表: Arraylist     */    public static void printArraylist(ArrayList&lt;String&gt; list)&amp;#123;        System.out.print(&quot;&amp;#123;&quot;);        for (int i = 0; i &lt; list.size(); i++) &amp;#123;            String name = list.get(i);        if (i == list.size() - 1)&amp;#123;            System.out.println(name + &quot;&amp;#125;&quot;);        &amp;#125;else &amp;#123;            System.out.print(name + &quot;@&quot;);        &amp;#125;        &amp;#125;    &amp;#125;&amp;#125;</code></pre><h4 id="4、筛选集合中的随机数"><a class="header-anchor" href="#4、筛选集合中的随机数">¶</a>4、筛选集合中的随机数</h4><pre><code class="language-java">import java.util.ArrayList;import java.util.Random;/*题目:用一个大集合存入20个随机数字，然后筛选其中的偶数元素，放到小集合当中。要求使用自定义的方法来实现筛选。分析:1.需要创建一个大集合，用来存储int数字: &lt;Integer&gt;2.随机数字就用Random nextInt3.循环20次，把随机数字放入大集合: for循环、add方法4.定义一个方法，用来进行筛选。筛选:根据大集合，筛选符合要求的元素，得到小集合。三要素返回值类型: ArrayLlist小集合(里面元素个数不确定)方法名称: getSmalllist参数列表: ArrayList大集合(装着20个随机数字)5.判断(if)是偶数:num%2==06.如果是偶数，就放到小集合当中，否则不放。 */public class Dome05ArrayListReturn &amp;#123;    public static void main(String[] args) &amp;#123;        ArrayList&lt;Integer&gt; biglist = new ArrayList&lt;&gt;();        Random r = new Random();        for (int i = 0; i &lt; 20; i++) &amp;#123;            int num1 = r.nextInt(100) + 1;//1~100            biglist.add(num1);        &amp;#125;        System.out.println(&quot;大集合是：&quot; + biglist);        System.out.println(&quot;==============================&quot;);        //调用方法，me        selectMethod(biglist);        System.out.println(&quot;=============&quot;);        //teacher        ArrayList&lt;Integer&gt; SmallList = getsmallList(biglist);        for (int i = 0; i &lt; SmallList.size(); i++) &amp;#123;            System.out.println(SmallList.get(i));        &amp;#125;        System.out.println(&quot;==================&quot;);        System.out.println(SmallList);        System.out.println(&quot;偶数一共&quot;+ SmallList.size() + &quot;个&quot;);    &amp;#125;    //定义筛选方法，me    public static void selectMethod(ArrayList&lt;Integer&gt; biglist)&amp;#123;        ArrayList&lt;Integer&gt; smallList = new ArrayList&lt;&gt;();        for (int i = 0; i &lt; biglist.size(); i++) &amp;#123;            if (biglist.get(i) % 2 ==0)&amp;#123;                int num2 = biglist.get(i);                smallList.add(num2);            &amp;#125;        &amp;#125;            System.out.println(&quot;小集合是：&quot; + smallList);            System.out.println(&quot;偶数一共&quot; + smallList.size() + &quot;个&quot;);    &amp;#125;    //接收大集合参数，返回小集合结果,teacher    public static ArrayList&lt;Integer&gt; getsmallList(ArrayList&lt;Integer&gt; biglist)&amp;#123;        //创建一个小集合，用来装偶数结果        ArrayList&lt;Integer&gt; SmallList = new ArrayList&lt;&gt;();        for (int i = 0; i &lt; biglist.size(); i++) &amp;#123;            int num3 = biglist.get(i);            if (num3%2 == 0)&amp;#123;                SmallList.add(num3);            &amp;#125;        &amp;#125;        return SmallList;    &amp;#125;&amp;#125;</code></pre><h2 id="字符串（String）"><a class="header-anchor" href="#字符串（String）">¶</a>字符串（String）</h2><h3 id="概述和特点"><a class="header-anchor" href="#概述和特点">¶</a>概述和特点</h3><p><code>java. lang. String</code>类代表字符串。<br>API当中说: Java程序中的所有字符串字面值(如&quot;abc&quot; )都作为此类的实例实现。<br>其实就是说:程序当中所有的双引号字符串，都是String类的对象。(就算没有new， 也照样是。)<br>字符串的特点:<br>1.字符串的内容<strong>永不可变</strong>。[重点]<br>2.正是因为字符串不可改变，所以字符串是可以共享使用的。<br>3.字符串效果上相当于是char[ ]字符数组， 但是底层原理是byte[]字节数组。</p><h3 id="构造方法和直接创建"><a class="header-anchor" href="#构造方法和直接创建">¶</a>构造方法和直接创建</h3><p>创建字符串的常见3+1种方式。<br>三种构造方法:<br>public String(): 创建一个空白字符串， 不含有任何内容。<br>public String(char[] array): 根据字符数组的内容，来创建对应的字符串。<br>public String(byte[] array): 根据字节数组的内容，来创建对应的字符串。<br>一种直接创建:<br><code>String str = &quot;Hello&quot;; //右边直接用双引号</code></p><pre><code class="language-java">public class Dome01String &amp;#123;    public static void main(String[] args) &amp;#123;        //使用空参构造        String str1 = new String();        System.out.println(&quot;第一个字符串：&quot; + str1);        //根据字符数组创建字符串        char[] charArry = &amp;#123;'4', '5' ,'6'&amp;#125;;        String str2 = new String(charArry);        System.out.println(&quot;第二个字符串：&quot; + str2);        //根据字节数组创建字符串        byte[] byteArray = &amp;#123;97,98,99&amp;#125;;        String str3 = new String(byteArray);        System.out.println(&quot;第三个字符串：&quot; + str3);        //直接创建字符串        String str = &quot;hello&quot;;        System.out.println(&quot;第四个字符串：&quot; + str);    &amp;#125;&amp;#125;</code></pre><h3 id="字符串的常量池"><a class="header-anchor" href="#字符串的常量池">¶</a>字符串的常量池</h3><pre><code class="language-java">public class Dome01StringPool &amp;#123;    public static void main(String[] args) &amp;#123;        String str1 = &quot;abc&quot;;        String str2 = &quot;abc&quot;;        char[] charArray = &amp;#123;'a','b','c'&amp;#125;;        String str3 = new String(charArray);        System.out.println(str1 == str2);//true        System.out.println(str1 == str3);//false        System.out.println(str2 == str3);//false    &amp;#125;&amp;#125;</code></pre><p><img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/stardust14/picture/master/img/20200726121234.png" alt="image-20200726121231535"></p><h3 id="字符串的比较方法"><a class="header-anchor" href="#字符串的比较方法">¶</a>字符串的比较方法</h3><pre><code class="language-java">/*==是进行对象的地址值比较，如果确买需要子符串的内容比较，可以使用两个方法:public. boolean equals(Object. obj): 参数可以是任何对象，只有参数是一个字符串并 且内容相同的才会给true;否则返回false。备注:任何对象都能用object进行接收。注意事项:1.任何对象都能用object进行接收。2. equals方法具有 对称性，也就是a. equals(b)和b. equals(a)效果-样。3.如果比较双方一个常量-一个变量，推荐把常量字符串写在前面。推荐: &quot;abc&quot;. equals(str)不推荐: str. equals(&quot;abc&quot;)public boolean equalsIgnoreCase(String str): 忽略大小写，进行内容比较。 */public class Dome01StringEquals &amp;#123;    public static void main(String[] args) &amp;#123;        String str1 = &quot;Hello&quot;;        String str2 = &quot;Hello&quot;;        char[] charArray = &amp;#123;'H','e','l','l','o'&amp;#125;;        String str3 = new String(charArray);        System.out.println(str1.equals(str2));//true        System.out.println(str1.equals(str3));//true        System.out.println(str3.equals(&quot;Hello&quot;));//true        System.out.println(&quot;Hello&quot;.equals(str3));//true        System.out.println(&quot;================&quot;);        String str4 = &quot;hello&quot;;        System.out.println(str1.equals(str4));//false        System.out.println(&quot;================&quot;);        String str5 = null;        System.out.println(&quot;abc&quot;.equals(str5));//推荐：false        //System.out.println(str5.equals(&quot;abc&quot;));//不推荐，报错，空指针异常NullPointerException        System.out.println(&quot;=============&quot;);        System.out.println(str1.equalsIgnoreCase(str4));//true,忽略大小写        //注意：只有英文字母区分大小写，汉字不区分    &amp;#125;&amp;#125;</code></pre><h3 id="字符串获取相关方法"><a class="header-anchor" href="#字符串获取相关方法">¶</a>字符串获取相关方法</h3><pre><code class="language-java">/*String当中与获取相关的常用方法有:public int length(); 获取字符串当中含有的字符个数，拿到字符串长度。public String concat(String str): 将当前字符串和参数字符串拼接成为返回值新的字符串。public char charAt(int index): 获取指定索引位置的单个字符。( 索引从开始。)public int index0f(String str): 查找参数字符串在本字符串当中首次出现的索引位置，如果没有返回-1值。 */public class Dome01StringGet &amp;#123;    public static void main(String[] args) &amp;#123;        //获取字符串长度        int length = &quot;askkjfbakjkjdbajhvbajbvn&quot;.length();        System.out.println(&quot;字符串的个数：&quot; + length);        //拼接字符串        String str1 = &quot;Hello&quot;;        String str2 = &quot;World&quot;;        String str3 = str1.concat(str2);        System.out.println(str1);//Hello        System.out.println(str2);//World        System.out.println(str3);//HelloWorld,新的字符串        System.out.println(&quot;====================&quot;);        //获取指定索引位置的单个字符        char ch = &quot;Hello&quot;.charAt(0);        System.out.println(&quot;第零号索引位置的字符是：&quot; + ch);//H        System.out.println(&quot;=================&quot;);        //查找参数字符串在本来字符串当中出现的第一次索引的位置        //如果没有，返回-1值        String original = &quot;HelloWorldHelloWorld&quot;;        int index = original.indexOf(&quot;llo&quot;);        System.out.println(&quot;第一次索引值：&quot; + index);//2        System.out.println(&quot;HelloWorld&quot;.indexOf(&quot;abc&quot;));//-1    &amp;#125;&amp;#125;</code></pre><h3 id="字符串的截取方法"><a class="header-anchor" href="#字符串的截取方法">¶</a>字符串的截取方法</h3><blockquote><p>字符串的截取方法: .<br>public String substring(int index): 截取从参数位置- -直到字符串末尾，返回新字符串。<br>public String substring(int begin, int end): 截取从begin开始， 一直到end结束，中间的字符串。<br>备注: [begin,end)， 包含左边，不包含右边。</p></blockquote><pre><code class="language-java">public class Dome01SubString &amp;#123;    public static void main(String[] args) &amp;#123;        String str1 = &quot;HelloWorld&quot;;        String str2 = str1.substring(5);        System.out.println(str1);//原封不动        System.out.println(str2);//World,新字符串        System.out.println(&quot;=============&quot;);        String str3 = str1.substring(4,7);        System.out.println(str3);//oWo        System.out.println(&quot;==============&quot;);        //下面这种写法，字符串的内容仍然是没有改变的        //下面有两个字符串: &quot;Hello&quot;，&quot;Java&quot;        //strA当中保存的是地址值。        //本来地址值是Hello的0x666,        //后来地址值变成了Java的0x999        String strA = &quot;Hello&quot;;        System.out.println(strA);//Hello        strA = &quot;Java&quot;;        System.out.println(strA);//Java    &amp;#125;&amp;#125;</code></pre><h3 id="字符串的转换相关方法"><a class="header-anchor" href="#字符串的转换相关方法">¶</a>字符串的转换相关方法</h3><blockquote><p>String当中与转换相关的常用方法有:</p><p>public char[] toCharArray(): 将当前字符串拆分成为字符数组作为返回值。<br>public byte[] getBytes(): 获得当前字符串底层的字节数组。<br>public String replace(CharSequence oldString, CharSequence newString):<br>将所有出现的老字符串替换成为新的字符串，返回替换之后的结果新字符串。<br>备注: CharSequence意思就是说可以接受字符串类型。</p></blockquote><pre><code class="language-java">public class Dome01StringConvert &amp;#123;    public static void main(String[] args) &amp;#123;        //转换成字符数组        char[] chars = &quot;Hello&quot;.toCharArray();        System.out.println(chars[0]);//H        System.out.println(chars.length);//5        System.out.println(&quot;===========&quot;);        //转换成字节数组        byte[] bytes = &quot;abc&quot;.getBytes();        System.out.println(bytes);        for (int i = 0; i &lt; bytes.length; i++) &amp;#123;            System.out.println(bytes[i]);        &amp;#125;        System.out.println(&quot;===================&quot;);        //字符串的内容替换        String str1 = &quot;How you doing?&quot;;        String str2 = str1.replace(&quot;?&quot;, &quot;(·——·)&quot;);        System.out.println(str1);//How you doing?        System.out.println(str2);//How you doing(·——·)        System.out.println(&quot;++++++++++++++++&quot;);        String lang1 = &quot;你他妈的会不会玩，我操,我操！！！&quot;;        String lang2 = lang1.replace(&quot;我操&quot;, &quot;我*&quot;);        String lang3 = lang2.replace(&quot;他妈的&quot;, &quot;***&quot;);        System.out.println(lang3);//你***会不会玩，我*,我*！！！    &amp;#125;&amp;#125;</code></pre><h3 id="字符串的分割方法"><a class="header-anchor" href="#字符串的分割方法">¶</a>字符串的分割方法</h3><p>分割字符串的方法: .<br>public String[] split(String regex): 按照参数的规则，将字符串切分成为若干部分。</p><p><strong>注意事项</strong>:<br>split方法的参数其实是一个“<strong>正则表达式</strong>”，今后学习。<br>今天要注意:如果按照英文句点**“.”**进行切分，必须写<code>&quot;\\.&quot;</code></p><pre><code class="language-java">public class Dome01StringSplit &amp;#123;    public static void main(String[] args) &amp;#123;        String str1 = &quot;a,bb,ccc,dddd,eeeee&quot;;        String[] str2 = str1.split(&quot;,&quot;);//以逗号为规则进行切割        System.out.println(str2);        for (int i = 0; i &lt; str2.length; i++) &amp;#123;            System.out.println(str2[i]);        &amp;#125;        System.out.println(&quot;============&quot;);        String str3 = &quot;A BB CCC DDDD EEEEE FFFFFF&quot;;        String[] str4 = str3.split(&quot; &quot;);//以空格为规则进行切割        for (int i = 0; i &lt; str4.length; i++) &amp;#123;            System.out.println(str4[i]);        &amp;#125;        System.out.println(&quot;------------------&quot;);        //以“.”必须用“\\.”表示，比较特殊的切割        String str5 = &quot;XXXX.YYYY.ZZZZ&quot;;        String[] str6 = str5.split(&quot;\\.&quot;);        for (int i = 0; i &lt; str6.length; i++) &amp;#123;            System.out.println(str6[i]);        &amp;#125;    &amp;#125;&amp;#125;</code></pre><h3 id="练习题-v5"><a class="header-anchor" href="#练习题-v5">¶</a>练习题</h3><h4 id="1、按指定格式拼接字符串"><a class="header-anchor" href="#1、按指定格式拼接字符串">¶</a>1、按指定格式拼接字符串</h4><pre><code class="language-java">/*题目:定义一个方法，把数组&amp;#123;1, 2, 3&amp;#125;按照指定格式拼接成一个字符串 。格式参照如下: [word1#word2#word3]。分析:1.首先准备一个int[]数组，内容是: 1、2、32.定义一个方法，用来将数组变成字符串三要素返回值类型: String方法名称: fromArrayToString参数列表: int[]3.格式: [word1 #word2#word3]用到: for循环、字符串拼接、每个数组元素之前都有-个word字样、分隔使用的是#、区分- -下是不是最后-一个4.调用方法，得到返回值，并打印结果字符串 */public class Dome02StringPractise &amp;#123;    public static void main(String[] args) &amp;#123;        int[] Array = &amp;#123;1,2,3&amp;#125;;        String result = fromArrayToString(Array);        System.out.println(result);    &amp;#125;    public static String fromArrayToString(int[] Array)&amp;#123;        String str = &quot;[&quot;;        for (int i = 0; i &lt; Array.length; i++) &amp;#123;            if (i ==Array.length - 1 )&amp;#123;                str += &quot;word&quot; + Array[i] + &quot;]&quot;;            &amp;#125;else &amp;#123;                str += &quot;word&quot; + Array[i] + &quot;#&quot;;            &amp;#125;        &amp;#125;        return str;    &amp;#125;&amp;#125;</code></pre><h4 id="2、统计输入的字符串中各种字符的个数"><a class="header-anchor" href="#2、统计输入的字符串中各种字符的个数">¶</a>2、统计输入的字符串中各种字符的个数</h4><pre><code class="language-java">/*题目:键盘输入一个字符串，并且统计其中各种字符出现的次数。种类有:大写字母、小写字母、数字、其他思路:1.既然用到键盘输入，肯定是Scanner2.键盘输入的是字符串，那么: String str = sc.next();3.定义四个变量，分别代表四种字符各自的出现次数。4.需要对字符串一个字、一个字检查，String--&gt;char[],方法就是toCharArray()5.遍历char[ ]字符数组，对当前字符的种类进行判断，并且用四个变量进行++动作。6.打印输出四个变量，分别代表四种字符出现次数。 */public class Dome02StringCount &amp;#123;    public static void main(String[] args) &amp;#123;        Scanner sc = new Scanner(System.in);        System.out.println(&quot;请输入一个字符串：&quot;);        String input = sc.next();        int countUpper = 0;//大写字母        int countLower = 0;//小写字母        int countNumber = 0;//数字        int countOther = 0;//其他字符        char[] Array = input.toCharArray();        for (int i = 0; i &lt; Array.length; i++) &amp;#123;            char ch = Array[i];//当前单个字符            if ('A' &lt;= ch &amp;&amp; ch &lt;='Z')&amp;#123;                countUpper++;            &amp;#125;else if ('a' &lt;= ch &amp;&amp; ch &lt;= 'z')&amp;#123;                countLower++;            &amp;#125;else if ('0' &lt;=ch &amp;&amp; ch&lt;='9')&amp;#123;                countNumber++;            &amp;#125;else &amp;#123;                countOther++;            &amp;#125;        &amp;#125;        System.out.println(&quot;大写字母的个数：&quot; + countUpper);        System.out.println(&quot;小写字母的个数：&quot; + countLower);        System.out.println(&quot;数字的个数：&quot; + countNumber);        System.out.println(&quot;其他字符的个数：&quot; + countOther);    &amp;#125;&amp;#125;</code></pre><blockquote><p>输入的字符串不能有空格存在</p></blockquote><h2 id="静态static关键字"><a class="header-anchor" href="#静态static关键字">¶</a>静态static关键字</h2><h3 id="概述-v4"><a class="header-anchor" href="#概述-v4">¶</a>概述</h3><p><img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/stardust14/picture/master/img/20200727143324.png" alt="image-20200726215716336"></p><h3 id="修饰成员变量"><a class="header-anchor" href="#修饰成员变量">¶</a>修饰成员变量</h3><pre><code class="language-java">/*如果一个成员变量使用了static关键字， 那么这个变量不再属于对象自己，而是属于所在的类。多个对象共享同一-份数据。. */public class Dome01StaticField &amp;#123;    public static void main(String[] args) &amp;#123;        Student one = new Student(&quot;霉霉&quot;,18);        one.room = &quot;101教室&quot;;        System.out.println(&quot;姓名：&quot; + one.getName() + &quot;,年龄：&quot;                + one.getAge() + &quot;,教室：&quot; + one.room        +&quot;，学号：&quot; + one.getId());        Student two = new Student(&quot;水果姐&quot; ,20);//        System.out.println();        System.out.println(&quot;姓名：&quot; + two.getName() + &quot;,年龄：&quot;                + two.getAge()+ &quot;,教室：&quot; + two.room                +&quot;，学号：&quot; + two.getId());    &amp;#125;&amp;#125;</code></pre><pre><code class="language-java">/*Student类*/public class Student &amp;#123;    private int id;//学号    private String name;//姓名    private int age;//年龄    static String room;//教室    static int idcounter = 0;//学号计数器    public Student() &amp;#123;        this.id = ++idcounter;    &amp;#125;    public Student(String name, int age) &amp;#123;        this.name = name;        this.age = age;        this.id = ++idcounter;    &amp;#125;    public int getId() &amp;#123;        return id;    &amp;#125;    public void setId(int id) &amp;#123;        this.id = id;    &amp;#125;    public String getName() &amp;#123;        return name;    &amp;#125;    public void setName(String name) &amp;#123;        this.name = name;    &amp;#125;    public int getAge() &amp;#123;        return age;    &amp;#125;    public void setAge(int age) &amp;#123;        this.age = age;    &amp;#125;&amp;#125;</code></pre><h3 id="修饰成员方法"><a class="header-anchor" href="#修饰成员方法">¶</a>修饰成员方法</h3><pre><code class="language-java">public class MyClass &amp;#123;    int num;//成员变量    static int numStatic;//静态变量    //成员方法    public void method()&amp;#123;        System.out.println(&quot;这是一个成员方法&quot;);        //成员方法可以访问成员变量        System.out.println(num);        //成员方法可以访问静态变量        System.out.println(numStatic);    &amp;#125;    //静态方法    public static void methodStatic()&amp;#123;        System.out.println(&quot;这是一个静态方法&quot;);        //静态方法可以访问静态变量        System.out.println(numStatic);        //静态方法不可以访问成员变量//        System.out.println(num);//        System.out.println(this);静态方法不能用this（当前方法调用）关键字    &amp;#125;&amp;#125;</code></pre><pre><code class="language-java">/*一旦使用static修饰成员方法，那么这就成为了静态方法。静态方法不属于对象，而是属于类的。如果没有static关键字，那么必须首先创建对象，然后通过对象才能使用它。无论是成员变量，还是成员方法。如果有了static,都推荐使用类名称进行调用。静态变量:类名称.静态变量静态方法:类名称.静态方法()注意事项:1.静态不能直接访问非静态。原因:因为在内存当中是[先]有的静态内容，[后] 有的非静态内容。“先人不知道后人，但是后人知道先人。”2.静态方法当中不能用this。原因: this代表当前对象，通过谁调用的方法，谁就是当前对象。 */public class Dome02StaticMethod &amp;#123;    public static void main(String[] args) &amp;#123;        MyClass obj = new MyClass();//首先创建对象        //然后才能用没有static关键字的内容        obj.method();        //对于静态方法来说，可以通过对象名进行调用，也可以直接通过类名称来调用。        obj.methodStatic();//正确，不推荐；这种写法在编译之后也会被javac翻译成为“类名称.静态方法名”        MyClass.methodStatic();//正确，推荐        //对于本来当中的静态方法，可以省略类名称        Memethod();        Dome02StaticMethod.Memethod();    &amp;#125;    public static void Memethod()&amp;#123;        System.out.println(&quot;自己的方法&quot;);    &amp;#125;&amp;#125;</code></pre><h3 id="内存图"><a class="header-anchor" href="#内存图">¶</a>内存图</h3><p><img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/stardust14/picture/master/img/20200727143255.png" alt="image-20200727143244285"></p><h3 id="静态代码块"><a class="header-anchor" href="#静态代码块">¶</a>静态代码块</h3><pre><code class="language-java">/*静态代码块的格式是:public class 类名称&amp;#123;static &amp;#123;//静态代码块的内容&amp;#125;&amp;#125;特点:当第一次用到本类时，静态代码块执行唯一的一 次。静态内容总是优先于非静态，所以静态代码块比构造方法先执行。静态代码块的典型用途:用来一次性地对静态成员变量进行赋值。*/</code></pre><h2 id="数组工具类Arrays"><a class="header-anchor" href="#数组工具类Arrays">¶</a>数组工具类Arrays</h2><pre><code class="language-java">import java.util.Arrays;/*java. util.Arrays是一个与 数组相天的工具类，里面提供I大重静念万法，用来头现数组常见的操作。public static String toString(数组): 将参数数组变成字符串(按照默认格式: [元素1, 元素2,元素3...]) .public static void sort(数组):按照默认升序(从小到大)对数组的元素进行排序。备注:1.如果是数值，sort默认按照升序从小到大29如果是字符串，sort默认按照字母升序3.如果是自定义的类型，那么这个自定义的类需要有Comparable或者Comparator接口的支持。 (今后学习) */public class Dome03Arrays &amp;#123;    public static void main(String[] args) &amp;#123;        int[] intArray = &amp;#123;10, 20, 30&amp;#125;;        //将int[]数组按照默认格式变成字符串        String intStr = Arrays.toString(intArray);        System.out.println(intStr);        int[] array1 =&amp;#123;1,6,8,9,2,3,5,4,7&amp;#125;;        Arrays.sort(array1);        System.out.println(Arrays.toString(array1));        String[] str = &amp;#123;&quot;a&quot;,&quot;q&quot;,&quot;z&quot;,&quot;e&quot;,&quot;w&quot;,&quot;s&quot;,&quot;d&quot;,&quot;x&quot;,                    &quot;c&quot;,&quot;f&quot;,&quot;r&quot;,&quot;t&quot;,&quot;g&quot;,&quot;v&quot;,&quot;b&quot;                ,&quot;t&quot;,&quot;y&quot;,&quot;u&quot;,&quot;h&quot;,&quot;j&quot;,&quot;n&quot;,&quot;k&quot;,&quot;m&quot;,&quot;l&quot;,&quot;i&quot;,&quot;o&quot;,&quot;p&quot;&amp;#125;;        Arrays.sort(str);        System.out.println(Arrays.toString(str));    &amp;#125;&amp;#125;</code></pre><h4 id="练习题-v6"><a class="header-anchor" href="#练习题-v6">¶</a>练习题</h4><pre><code class="language-java">import java.util.Arrays;import java.util.Scanner;/*题目:请使用Arrays相关的API, 将一个随机字符串中的所有字符升序排列，并倒序打印。 */public class Dome02ArraysPractise &amp;#123;    public static void main(String[] args) &amp;#123;        //升级：用键盘读取输入的字符串        Scanner sc = new Scanner(System.in);        System.out.println(&quot;请输入一个字符串：&quot;);        String str = sc.next();        //如何进行升序排列: sort        //必须是一个数组，才能用Arrays. sort方法        // String --&gt;数组，用toCharArray        char[] chars = str.toCharArray();        Arrays.sort(chars);        System.out.println(Arrays.toString(chars));//这是顺序排列        System.out.println(&quot;===============&quot;);                //接下来需要逆序排列，倒序遍历        for (int i = chars.length - 1; i &gt;= 0; i--) &amp;#123;            System.out.print(chars[i]);        &amp;#125;    &amp;#125;&amp;#125;</code></pre><h2 id="数学工具类"><a class="header-anchor" href="#数学工具类">¶</a>数学工具类</h2><pre><code class="language-java">/*java.lang.Math类是数学相关的工具类，里面提供了大量的静态方法，完成与数学运算相关的操作public static double abs(double num): 获取绝对值。public static double ceil(double num): 向.上取整。public static double floor(double num):向下取整。public static long round(double num): 四舍五入。Math. PI代表近似的圆周率常量(double)。 */public class Dome04Math &amp;#123;    public static void main(String[] args) &amp;#123;        //获取绝对值        System.out.println(Math.abs(3.14));//3.14        System.out.println(Math.abs(-8));//8        System.out.println(Math.abs(-5.1));//5.1        System.out.println(&quot;==================&quot;);        //向上取整        System.out.println(Math.ceil(3.9));//4.0        System.out.println(Math.ceil(3.0));//3.0        System.out.println(Math.ceil(3.00000001));//4.0        System.out.println(Math.ceil(3.0000000000000000001));//3.0        System.out.println(&quot;===================&quot;);        //向下取整，抹零        System.out.println(Math.floor(6.666));//6.0        System.out.println(Math.floor(6.00));//6.0        System.out.println(Math.floor(6.999));//6.0        System.out.println(&quot;==================&quot;);        //四舍五入        System.out.println(Math.round(5.5));//6.0        System.out.println(Math.round(5.40000001));//5.0        System.out.println(Math.round(5.3));//5.0        System.out.println(&quot;=================&quot;);                //pi        System.out.println(Math.PI);//3.141592653589793    &amp;#125;&amp;#125;</code></pre><h4 id="练习题-v7"><a class="header-anchor" href="#练习题-v7">¶</a>练习题</h4><p><img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/stardust14/picture/master/img/20200727155149.png" alt="image-20200727155147074"></p><pre><code class="language-java">/*题目:计算在-10.8到5.9之间，绝对值大于6或者小于2.1的整数有多少个?分析:1.既然已经确定了范围，for循环2.起点位置-10.8应该转换成为-10， 两种办法:    2.1可以使用Math.ceil方法，向上(向正方向)取整    2.2强转成为int，自动舍弃所有小数位3.每一个数字都是整数，所以步进表达式应该是num++， 这样每次都是+1的。4.如何拿到绝对值: Math. abs方法。.5.一旦发现了一个数字，需要让计数器+ +进行统计。 */public class Dome04MathPractise &amp;#123;    public static void main(String[] args) &amp;#123;        int count = 0;        double min = -10.9;        double max = 5.9;        for (int i = (int) min; i &lt; max; i++) &amp;#123;            int abs = Math.abs(i);            if (abs &gt; 6 || abs &lt; 2.1) &amp;#123;                System.out.println(&quot;符合要求的数字为：&quot; + i);                count++;            &amp;#125;        &amp;#125;        System.out.println(&quot;符合要求的个数为：&quot; + count + &quot;个&quot;);    &amp;#125;&amp;#125;</code></pre><h1>继承性</h1><h2 id="概述-v5"><a class="header-anchor" href="#概述-v5">¶</a>概述</h2><p><img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/stardust14/picture/master/img/20200728102030.png" alt="image-20200728102028290"></p><h2 id="格式"><a class="header-anchor" href="#格式">¶</a>格式</h2><pre><code class="language-java">/*在继承的关系中，“子类就是一一个父类”。也就是说，子类可以被当做父类看待。例如父类是员工，子类是讲师，那么“讲师就是一个员工”。 关系: is-a。定义父类的格式: (一个普通的类定义)public class 父类名称&amp;#123;    //...&amp;#125;定义子类的格式:public class 子类名称extends 父类名称&amp;#123;    //....&amp;#125; */</code></pre><h2 id="成员变量的访问特点"><a class="header-anchor" href="#成员变量的访问特点">¶</a>成员变量的访问特点</h2><pre><code class="language-java">public class Fu &amp;#123;    int numFu = 10;    int num = 100;    public void methodFu()&amp;#123;        //使用本类之中，不会向下找子类的        System.out.println(num);    &amp;#125;&amp;#125;</code></pre><pre><code class="language-java">public class Zi extends Fu &amp;#123;    int numZi = 20;    int num = 2000;    public void methodZi()&amp;#123;        //因为本类之中有num，所以优先使用本类中的num        System.out.println(num);    &amp;#125;&amp;#125;</code></pre><pre><code class="language-java">/*在父子类的继承关系当中，如果成员变量重名，则创建子类对象时，访问有两种方式:直接通过子类对象访问成员变量:    等号左边是谁，就优先用谁，没有则向上找。间接通过成员方法访问成员变量:该方法属于谁，就优先用谁，没有则向上找。 */public class Dome01ExtendsField &amp;#123;    public static void main(String[] args) &amp;#123;        Fu fu =new Fu();//创建父类对象        System.out.println(fu.numFu);//10，只能使用父类的东西，没有任何子类内容        System.out.println(&quot;============&quot;);        Zi zi=new Zi();        System.out.println(zi.numZi);//20        System.out.println(zi.numFu);//10        System.out.println(&quot;============&quot;);        //等号左边是谁，就优先用谁        System.out.println(zi.num);//优先子类，2000//        System.out.println(zi.aba);//到处都没有，编译报错        System.out.println(&quot;++++++++&quot;);        System.out.println(fu.num);//100        System.out.println(&quot;=============&quot;);        //这个方法是子类的，优先子类的，没有再向上找        zi.methodZi();//2000        //这个方法是在父类当中定义的        zi.methodFu();//100    &amp;#125;&amp;#125;</code></pre><h2 id="区分子类方法中重名的三种方法"><a class="header-anchor" href="#区分子类方法中重名的三种方法">¶</a>区分子类方法中重名的三种方法</h2><pre><code class="language-java">public class Zi extends Fu &amp;#123;    int num = 20;    public void method()&amp;#123;        int num = 30;        System.out.println(num);//30,局部变量        System.out.println(this.num);//20，本类中的成员变量        System.out.println(super.num);//10,父类中的成员变量    &amp;#125;&amp;#125;</code></pre><pre><code class="language-java">/*局部变量:           直接写成员变量名本类的成员变量:      this.成员变量名父类的成员变量:      super.成员变量名 */public class Dome02ExtendsField &amp;#123;    public static void main(String[] args) &amp;#123;        Zi zi = new Zi();        zi.method();    &amp;#125;&amp;#125;</code></pre><h2 id="成员方法的访问特点"><a class="header-anchor" href="#成员方法的访问特点">¶</a>成员方法的访问特点</h2><pre><code class="language-java">public class Fu01 &amp;#123;    public void methodFu01()&amp;#123;        System.out.println(&quot;父类方法执行！！！！！&quot;);    &amp;#125;    public void method()&amp;#123;        System.out.println(&quot;父类重名方法执行！！！&quot;);    &amp;#125;&amp;#125;</code></pre><pre><code class="language-java">public class Zi01 extends Fu01&amp;#123;    public void methodZi01()&amp;#123;        System.out.println(&quot;子类方法执行！！！！！&quot;);    &amp;#125;    public void method()&amp;#123;        System.out.println(&quot;子类重名方法执行！！！&quot;);    &amp;#125;&amp;#125;</code></pre><pre><code class="language-java">/*在父子类的继承关系当中，创建子类对象，访问成员方法的规则:    创建的对象是谁，就优先用谁，如果没有则向上找。   注意事项:无论是成员方法还是成员变量，如果没有都是向上找父类，绝对不会向下找子类的。 */public class Dome03ExtendsField01 &amp;#123;    public static void main(String[] args) &amp;#123;        Zi01 zi = new Zi01();        zi.methodFu01();//父类方法执行！！！！！        zi.methodZi01();//子类方法执行！！！！！        //创建的是new了子类对象，所以优先用子类方法        zi.method();//子类重名方法执行！！！    &amp;#125;&amp;#125;</code></pre><h2 id="方法的覆盖重写"><a class="header-anchor" href="#方法的覆盖重写">¶</a>方法的覆盖重写</h2><h3 id="概念与特点"><a class="header-anchor" href="#概念与特点">¶</a>概念与特点</h3><pre><code class="language-java">/*重写(Override)概念:在继承关系当中，方法的名称一样，参数列表也一样。重写(Override):方法的名称一样，参数列表[也一样]。覆盖、覆写。重载(Overload) :方法的名称一样，参数列表[不一样]。方法的覆盖重写特点:创建的是子类对象，则优先用子类方法。*/</code></pre><h3 id="注意事项"><a class="header-anchor" href="#注意事项">¶</a>注意事项</h3><pre><code class="language-java">/*方法覆盖重写的注意事项:1.必须保证父子类之间方法的名称相同，参数列表也相同。@Override:写在方法前面，用来检测是不是有效的正确覆盖重写。这个注解就算不写，只要满足要求，也是正确的方法覆盖重写。2.子类方法的返回值必须[小于等于]父类方法的返回值范围。小扩展提示: java. lang . object类是所有类的公共最高父类(祖宗类)，java. lang. String就是object的子类3.子类方法的权限必须[大于等于]父类方法的权限修饰符。小扩展提示: public &gt; protected &gt; (default) &gt; private备注: (default)不是关键字default， 而是什么都不写，留空。*/</code></pre><h3 id="应用场景"><a class="header-anchor" href="#应用场景">¶</a>应用场景</h3><p><img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/stardust14/picture/master/img/20200728145141.png" alt="image-20200728143931983"></p><pre><code class="language-java">//本来的老款手机public class Phone &amp;#123;    public void call()&amp;#123;        System.out.println(&quot;打电话&quot;);    &amp;#125;    public void send()&amp;#123;        System.out.println(&quot;发短信&quot;);    &amp;#125;    public void show()&amp;#123;        System.out.println(&quot;显示号码&quot;);    &amp;#125;&amp;#125;</code></pre><pre><code class="language-java">//定义一个新手机，使用老手机作为父类public class NewPhone extends Phone &amp;#123;    @Override    public void show() &amp;#123;        super.show();//把父类中的show方法拿过来重复使用        //自己子类再添加新的内容        System.out.println(&quot;显示姓名&quot;);        System.out.println(&quot;显示头像&quot;);    &amp;#125;&amp;#125;</code></pre><pre><code class="language-java">public class Dome04Phone &amp;#123;    public static void main(String[] args) &amp;#123;        Phone phone = new Phone();        phone.call();        phone.send();        phone.show();        System.out.println(&quot;==================&quot;);        NewPhone newPhone = new NewPhone();        newPhone.call();        newPhone.send();        newPhone.show();    &amp;#125;&amp;#125;</code></pre><h2 id="构造方法的访问特点"><a class="header-anchor" href="#构造方法的访问特点">¶</a>构造方法的访问特点</h2><pre><code class="language-java">/*继承关系中，父子类构造方法的访问特点:1.子类构造方法当中有一一个默认隐含的“super()&quot;调用，所以一-定是先调用的父类构造，后执行的子类构造。2.子类构造可以通过super关键字来调用父类重载构造。3. super的父类构造调用，必须是子类构造方法的第一个语句。 不能一个子类构造调用多次super构造。总结:子类必须调，用父类构造方法，不写则赠送super();写了则用写的指定的super调用，super只能有一个，还必须是第一个。*/</code></pre><h2 id="super关键字的三种用法"><a class="header-anchor" href="#super关键字的三种用法">¶</a>super关键字的三种用法</h2><pre><code class="language-java">/*super关键字的用法有三种:1.在子类的成员方法中，访问父类的成员变量。2.在子类的成员方法中，访问父类的成员方法。3.在子类的构造方法中，访问父类的构造方法。 */public class Zi02 extends Fu02 &amp;#123;    int num = 20;    public Zi02()&amp;#123;        super();    &amp;#125;    public void methodZi02()&amp;#123;        System.out.println(super.num);//父类中的num    &amp;#125;    public void method()&amp;#123;        super.method();//访问父类中的method方法        System.out.println(&quot;子类方法&quot;);//    &amp;#125;&amp;#125;</code></pre><pre><code class="language-java">public class Fu02 &amp;#123;    int num = 10;    public void method()&amp;#123;        System.out.println(&quot;父类方法&quot;);    &amp;#125;&amp;#125;</code></pre><h2 id="this关键字的三种用法"><a class="header-anchor" href="#this关键字的三种用法">¶</a>this关键字的三种用法</h2><pre><code class="language-java">/*super关键字用来访问父类内容，而this关键字用来访问本类内容。用法也有三种:1.在本类的成员方法中，访问本类的成员变量。2.在本类的成员方法中，访问本类的另一个成员方法。3.在本类的构造方法中，访问本类的另- -个构造方法。在第三种用法当中要注意:    A. this(... )调用也必须是构造方法的第一个语句， 唯一-个。    B. super和thi s两种构造调用，不能同时使用。 */public class Zi03 extends Fu03 &amp;#123;    int num = 10;    public Zi03()&amp;#123;//        super();//这一行不再赠送        this(100);//本类的无参构造，调用本类的有参构造//        this(1,3);//错误写法/    &amp;#125;    public Zi03(int n)&amp;#123;            &amp;#125;    public Zi03(int n,int m)&amp;#123;    &amp;#125;    public void showNum()&amp;#123;        int num = 20;        System.out.println(num);//局部变量        System.out.println(this.num);//本类中的成员变量        System.out.println(super.num);//父类中的成员变量    &amp;#125;    public void methodA()&amp;#123;        System.out.println(&quot;你最帅！&quot;);    &amp;#125;    public void methodB()&amp;#123;        this.methodA();        System.out.println(&quot;我最帅！！&quot;);    &amp;#125;&amp;#125;</code></pre><h2 id="super和this关键字图解"><a class="header-anchor" href="#super和this关键字图解">¶</a>super和this关键字图解</h2><p><img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/stardust14/picture/master/img/20200728205348.png" alt="image-20200728205347121"></p><h2 id="Java继承的三个特点"><a class="header-anchor" href="#Java继承的三个特点">¶</a>Java继承的三个特点</h2><p><img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/stardust14/picture/master/img/20200728210954.png" alt="image-20200728210017817"></p><h2 id="抽象"><a class="header-anchor" href="#抽象">¶</a>抽象</h2><h3 id="概念"><a class="header-anchor" href="#概念">¶</a>概念</h3><p><img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/stardust14/picture/master/img/20200728210946.png" alt="image-20200728210458257"></p><h3 id="抽象方法和抽象类的格式和使用"><a class="header-anchor" href="#抽象方法和抽象类的格式和使用">¶</a>抽象方法和抽象类的格式和使用</h3><pre><code class="language-java">/*抽象方法:就是加上abstract关键字，然后去掉大括号，直接分号结束。抽象类:抽象方法所在的类，必须是抽象类才行。在class之前写上abstract即可。如何使用抽象类和抽象方法:19不能直接创建new抽象类对象。2.必须用一个子类来继承抽象父类。3.子类必须覆盖重写抽象父类当中所有的抽象方法。覆盖重写(实现) :子类去掉抽象方法的abstract关键字，然后补上方法体大括号。4.创建子类对象进行使用。 */public abstract class Animal &amp;#123;    //这是一个抽象方法，代表吃东西，但是具体吃什么(大括号的内容)不确定。    public abstract void eat();    //这是一个普通的成员方法    public void method()&amp;#123;    &amp;#125;&amp;#125;</code></pre><pre><code class="language-java">public class Cat extends Animal &amp;#123;    public void eat()&amp;#123;        System.out.println(&quot;猫吃鱼&quot;);    &amp;#125;&amp;#125;</code></pre><pre><code class="language-java">public class Dome05Main &amp;#123;    public static void main(String[] args) &amp;#123;        Cat cat = new Cat();        cat.eat();    &amp;#125;&amp;#125;</code></pre><h3 id="注意事项-v2"><a class="header-anchor" href="#注意事项-v2">¶</a>注意事项</h3><p>关于抽象类的使用，以下为语法上要注意的细节，虽然条目较多,但若理解了抽象的本质，无需死记硬背。<br>1.抽象类<strong>不能创建对象</strong>，如果创建,编译无法通过而报错。只能创建其非抽象子类的对象。</p><blockquote><p>理解: 假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。</p></blockquote><p>2.抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。</p><blockquote><p>理解: 子类的构造方法中，有默认的super(),需要访问父类构造方法。</p></blockquote><p>3.抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</p><blockquote><p>理解:未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。</p></blockquote><p>4.抽象类的子类，必须重写抽象父类中<strong>所有的</strong>抽象方法，否则，编译无法通过而报错。除非该子类也是抽象类。</p><blockquote><p>理解:假设不重写所有抽象方法,则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义。</p></blockquote><h2 id="练习题-v8"><a class="header-anchor" href="#练习题-v8">¶</a>练习题</h2><h3 id="综合案例-群主发普通红包"><a class="header-anchor" href="#综合案例-群主发普通红包">¶</a>综合案例:群主发普通红包</h3><p>群主发普通红包。某群有多名成员，群主给成员发普通红包。普通红包的规则:<br>1.群主的一笔金额，从群主余额中扣除，平均分成n等份，让成员领取。<br>2.成员领取红包后，保存到成员余额中。<br>请根据描述,完成案例中所有类的定义以及指定类之间的继承关系，并完成发红包的操作。</p><p><img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/stardust14/picture/master/img/20200728214035.png" alt="image-20200728214033747"></p><h4 id="实现："><a class="header-anchor" href="#实现：">¶</a>实现：</h4><pre><code class="language-java">public class User &amp;#123;    private String name;//姓名    private int money;//余额，也就是当前的所拥有的钱数    public User() &amp;#123;    &amp;#125;    public User(String name, int money) &amp;#123;        this.name = name;        this.money = money;    &amp;#125;    //展示一下用户有多少钱    public void show()&amp;#123;        System.out.println(&quot;我叫：&quot; + name + &quot;,我有&quot; + money + &quot;钱&quot;);    &amp;#125;    public String getName() &amp;#123;        return name;    &amp;#125;    public void setName(String name) &amp;#123;        this.name = name;    &amp;#125;    public int getMoney() &amp;#123;        return money;    &amp;#125;    public void setMoney(int money) &amp;#123;        this.money = money;    &amp;#125;&amp;#125;</code></pre><pre><code class="language-java">import java.util.ArrayList;//群主的类public class Manager extends User &amp;#123;    public Manager()&amp;#123;    &amp;#125;    public Manager(String name, int money) &amp;#123;        super(name, money);    &amp;#125;    public ArrayList&lt;Integer&gt; send(int totalMoney,int count)&amp;#123;        //首先需要一个集合，用来存储若干个红包的余额        ArrayList&lt;Integer&gt; redList = new ArrayList&lt;&gt;();        //先看一下群主自己的余额        int leftMoney = super.getMoney();//群主当前余额        if (totalMoney &gt;leftMoney)&amp;#123;            System.out.println(&quot;您的余额不足，请及时充值！！！&quot;);            return redList;//返回空集合        &amp;#125;        //扣钱，就是重新设置余额        super.setMoney(leftMoney - totalMoney);        //发红包需要平均拆分成count份        int avg = totalMoney/count;        int mod  = totalMoney % count;//余数，也就是剩下的零头        //除不开的零头放在最后一个红包里        //下面把红包一个一个放在集合里        for (int i = 0; i &lt; count - 1; i++) &amp;#123;            redList.add(avg);        &amp;#125;        //最后一个红包        int last = avg + mod;        redList.add(last);        return redList;    &amp;#125;&amp;#125;</code></pre><pre><code class="language-java">import java.util.ArrayList;import java.util.Random;//群员的类public class Member extends User &amp;#123;    public Member() &amp;#123;    &amp;#125;    public Member(String name, int money) &amp;#123;        super(name, money);    &amp;#125;    public void receive(ArrayList&lt;Integer&gt; list)&amp;#123;        //从多个红包当中随便抽取一个，给我自己。        //随机获取一一个集合当中的索引编号        int index = new Random().nextInt(list.size());        //根据索引，从集合当中删除，并且得到被删除的红包，给我自己        int delta = list.remove(index);        //当前成员有多少钱        int money = super.getMoney();        //加法，并重新设置回去        super.setMoney(delta + money);    &amp;#125;&amp;#125;</code></pre><pre><code class="language-java">import java.util.ArrayList;public class MainRedPacket &amp;#123;    public static void main(String[] args) &amp;#123;        Manager manager = new Manager(&quot;乔布斯&quot;,1000000000);        Member one = new Member(&quot;比尔·盖茨&quot;,999999);        Member two = new Member(&quot;巴菲特&quot;,8888888);        Member three = new Member(&quot;库克&quot;,666666);        Member four = new Member(&quot;川普&quot;,222222);        manager.show();        one.show();        two.show();        three.show();        four.show();        System.out.println(&quot;===============&quot;);        //群主总共发66666块钱，分成四个红包        ArrayList&lt;Integer&gt; redList = manager.send(66666,4);        //四个普通成员收红包        one.receive(redList);        two.receive(redList);        three.receive(redList);        four.receive(redList);        manager.show();//随机分排        one.show();        two.show();        three.show();        four.show();    &amp;#125;&amp;#125;</code></pre><h1>接口</h1><h2 id="概述与生活例举"><a class="header-anchor" href="#概述与生活例举">¶</a>概述与生活例举</h2><p><img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/stardust14/picture/master/img/20200729214057.png" alt="image-20200729214055457"></p><h2 id="定义的基本格式"><a class="header-anchor" href="#定义的基本格式">¶</a>定义的基本格式</h2><pre><code class="language-java">/*在任何放本的Java中，接口都能正义抽象万法。格式:public abstract返回值类型方法名称(参数列表);主意事项:1.接口当中的抽象方法，修饰符必须是两个固定的关键字: public abstract2.这两个关键字修饰符，可以选择性地省略。(今天刚学， 所以不推荐。)3.方法的三要素，可以随意定义。 */</code></pre><blockquote><p>与类名相同才是构造方法</p><p>接口主要是做一些规范</p></blockquote><h2 id="接口的抽象方法的使用"><a class="header-anchor" href="#接口的抽象方法的使用">¶</a>接口的抽象方法的使用</h2><pre><code class="language-java">/*接口使用步骤:1.接口不能直接使用，必须有一个“实现类&quot;来“实现&quot;该接口。格式:public class 实现类名称implements 接口名称&amp;#123;    //.....&amp;#125;2.接口的实现类必须覆盖重写(实现)接口中所有的抽象方法。实现:去掉abstract关键字，加上方法体大括号。3.创建实现类的对象，进行使用。注意事项:如果实现类并没有覆盖重写接口中所有的抽象方法，那么这个实现类自己就必须是抽象类。 */public class Dome01Interface &amp;#123;    public static void main(String[] args) &amp;#123;        //错误写法！不能直接new接口对象使用。//        MyInterfaceAbstract inter = new MyInterfaceAbstract();        //创建实现类的对象使用        MyInterfaceAbstractImpl impl = new MyInterfaceAbstractImpl();        impl.methodAbs();    &amp;#125;&amp;#125;</code></pre><pre><code class="language-java">public interface MyInterfaceAbstract &amp;#123;    public abstract void methodAbs();//public和abstract可以省略其一，或着全部省略&amp;#125;</code></pre><pre><code class="language-java">public class MyInterfaceAbstractImpl  implements MyInterfaceAbstract&amp;#123;    @Override//辨识重写    public void methodAbs() &amp;#123;        System.out.println(&quot;implements方法执行了！&quot;);    &amp;#125;&amp;#125;</code></pre><h2 id="接口的默认方法定义与使用"><a class="header-anchor" href="#接口的默认方法定义与使用">¶</a>接口的默认方法定义与使用</h2><pre><code class="language-java">/*从Java 8开始，接口里允许定义默认方法。格式:public default 返回值类型方法名称(参数列表) &amp;#123;    方法体&amp;#125;备注:接口当中的默认方法，可以解决接口升级的问题。 */public interface MyInterfaceDefault &amp;#123;    //抽象方法    public abstract void methodAbsA();    //新添加一个抽象方法//    public abstract void methodAbsB();    //新添加的方法，改写为默认方法    //新添加的这个方法，不需要去修改AorB    public default void methodDefault()&amp;#123;        System.out.println(&quot;这是新添加的默认方法&quot;);    &amp;#125;&amp;#125;</code></pre><pre><code class="language-java">public class MyInterfaceDefaultA implements MyInterfaceDefault &amp;#123;    @Override    public void methodAbsA() &amp;#123;        System.out.println(&quot;这个抽象方法执行了：AAAAAAAAAA&quot;);    &amp;#125;&amp;#125;</code></pre><pre><code class="language-java">public class MyInterfaceDefaultB implements MyInterfaceDefault &amp;#123;    @Override    public void methodAbsA() &amp;#123;        System.out.println(&quot;这个抽象方法执行了：BBBBBBBB&quot;);    &amp;#125;    @Override    public void methodDefault() &amp;#123;        System.out.println(&quot;实现B类覆盖重写了接口的默认方法&quot;);    &amp;#125;&amp;#125;</code></pre><pre><code class="language-java">public class Dome02Interface &amp;#123;    public static void main(String[] args) &amp;#123;        MyInterfaceDefaultA a = new MyInterfaceDefaultA();        a.methodAbsA();//调用抽象方法，实际运行的是右侧实现类。        //调用默认方法，如果实现类当中没有，会向上找接口        a.methodDefault();//这是新添加的默认方法        System.out.println(&quot;===========&quot;);        MyInterfaceDefaultB b = new MyInterfaceDefaultB();        b.methodAbsA();//这个抽象方法执行了：BBBBBBBB        b.methodDefault();//实现B类覆盖重写了接口的默认方法    &amp;#125;&amp;#125;</code></pre><blockquote><p>抽象类利于代码的复写，接口利于代码的维护</p><p>接口可以看成一种特殊的抽象类</p></blockquote><h2 id="接口的静态方法定义与使用"><a class="header-anchor" href="#接口的静态方法定义与使用">¶</a>接口的静态方法定义与使用</h2><pre><code class="language-java">/*从Java 8开始，接口当中允许定义静态方法。格式:public static 返回值类型方法名称(参数列表) &amp;#123;    方法体&amp;#125;提示:就是将abstract或者default换成static即可，带上方法体。 */public interface MyInterfaceStatic &amp;#123;    public static void method()&amp;#123;        System.out.println(&quot;这是接口的静态方法&quot;);    &amp;#125;&amp;#125;</code></pre><pre><code class="language-java">/*注意事项:不能通过接口实现类的对象来调用接口当中的静态方法。正确用法:通过接口名称，直接调用其中的静态方法。格式:接口名称.静态方法名(参数); */public class Dome03Interface &amp;#123;    public static void main(String[] args) &amp;#123;        //直接通过接口名称调用静态方法        MyInterfaceStatic.method();    &amp;#125;&amp;#125;</code></pre><h2 id="接口的私有方法定义与使用"><a class="header-anchor" href="#接口的私有方法定义与使用">¶</a>接口的私有方法定义与使用</h2><pre><code class="language-java">/*问题描述:我们需要抽取一个共有方法，用来解快两个默认方法之间重复代码的问题。但是这个共有方法不应该让实现类使用，应该是私有化的。解决方案:从Java 9开始，接口当中允许定义私有方法。1. 普通私有方法，解决多个默认方法之间重复代码问题格式:private 返回值类型方法名称(参数列表) &amp;#123;    方法体&amp;#125;2.静态私有方法，解决多个静态方法之间重复代码问题格式:private static 返回值类型方法名称(参数列表) &amp;#123;    方法体&amp;#125; */public interface MyInterfacePrivateA &amp;#123;    public default void methodDefacult1()&amp;#123;        System.out.println(&quot;默认方法1&quot;);        methodCommon();    &amp;#125;    public default void methodDefacult2()&amp;#123;        System.out.println(&quot;默认方法2&quot;);        methodCommon();    &amp;#125;    private void methodCommon()&amp;#123;        System.out.println(&quot;AAAA&quot;);        System.out.println(&quot;BBBB&quot;);        System.out.println(&quot;CCCC&quot;);    &amp;#125;&amp;#125;</code></pre><pre><code class="language-java">public interface MyInterfacePrivateB &amp;#123;    public static void methodStatic1()&amp;#123;        System.out.println(&quot;静态方法1&quot;);        methodStaticCommon();    &amp;#125;    public static void methodStatic2()&amp;#123;        System.out.println(&quot;静态方法2&quot;);        methodStaticCommon();    &amp;#125;    private static void methodStaticCommon()&amp;#123;        System.out.println(&quot;AAAA&quot;);        System.out.println(&quot;BBBB&quot;);        System.out.println(&quot;CCCC&quot;);    &amp;#125;&amp;#125;</code></pre><h2 id="接口的常量定义和使用"><a class="header-anchor" href="#接口的常量定义和使用">¶</a>接口的常量定义和使用</h2><pre><code class="language-java">/*接口:当中也可以定义“成员变量”，但是必须使用public static final三个关键字进行修饰。从效果上看，这其实就是接口的【常量】。格式:public static final 数据类型常量名称=数据值;备注:一旦使用final关键字进行修饰，说明不可改变。注意事项:1.接口当中的常量，可以省略public static final, 注意:不写也照样是这样。2.接口当中的常量，必须进行赋值;不能不赋值。3.接口中常量的名称，使用完全大写的字母，用下划线进行分隔。(推荐命名规则) */public interface MyInterfaceConst &amp;#123;    public static final int NUM_OF_MYCLASS= 10;&amp;#125;</code></pre><h2 id="小结"><a class="header-anchor" href="#小结">¶</a>小结</h2><p>在Java 9+版本中，接口的内容可以有:<br>1.成员变量其实是常量，格式:[public] [static] [final] 数据类型常量名称=数据值;</p><blockquote><p>注意:<br>常量必须进行赋值，而且一旦赋值不能改变。<br>常量名称完全大写，用下划线进行分隔。</p></blockquote><p>2.接口中最重要的就是抽象方法，格式:<br>[public] [abstract] 返回值类型方法名称(参数列表);</p><blockquote><p>注意:实现类必须覆盖重写接口所有的抽象方法，除非实现类是抽象类。</p></blockquote><p>3.从Java 8开始，接口里允许定义默认方法，格式:<br>[public] default 返回值类型方法名称(参数列表) {方法体}</p><blockquote><p>注意:默认方法也可以被覆盖重写</p></blockquote><p>4.从Java 8开始，接口里允许定义静态方法，格式:<br>[public] static 返回值类型方法名称(参数列表) {方法体}</p><blockquote><p>注意:应该通过接口名称进行调用，不能通过实现类对象调用接口静态方法</p></blockquote><p>5.从Java 9开始，接口里允许定义私有很乏，格式:<br>普通私有方法: private 返回值类型方法名称(参数列表) {方法体}<br>静态私有方法: private static 返回值类型方法名称(参数列表) {方法体}</p><blockquote><p>注意:private的方法只有接口自己才能调用，不能被实现类或别人使用。</p></blockquote><h2 id="继承父类并实现多种接口"><a class="header-anchor" href="#继承父类并实现多种接口">¶</a>继承父类并实现多种接口</h2><pre><code class="language-java">/*使用接口的时候，需要注意:1.接口是没有静态代码块或者构造方法的。2.一个类的直接父类是唯一的，但是一个类可以同时实现多个接口。格式:public class MyInterfaceImpl impl ements MyInterfaceA, MyInterfaceB &amp;#123;//覆盖重写所有抽象方法&amp;#125;3.如果实现类所实现的多个接口当中，存在重复的抽象方法，那么只需要覆盖重写一次即可。4.如果实现类没有覆盖重写所有接口当中的所有抽象方法，那么实现类就必须是一个抽象类。5.如果实现类锁实现的多个接口当中，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写。6.一个类如果直接父类当中的方法，和接口当中的默认方法产生了冲突，优先用父类当中的方法。*/</code></pre><h2 id="接口之间的多继承"><a class="header-anchor" href="#接口之间的多继承">¶</a>接口之间的多继承</h2><p>1.类与类之间是单继承的。直接父类只有一个 。<br>2.类与接口之间是多实现的。一个类可以实现多个接口。<br>3.接口与接口之间是多继承的。</p><p>注意事项:<br>1.多个父接口当中的抽象方法如果重复，没关系。<br>2.多个父接口当中的默认方法如果重复，那么子接口必须进行默认方法的覆盖重写， <strong>【而且带着default关键字】</strong>。</p><h1>多态性</h1><h2 id="概述-v6"><a class="header-anchor" href="#概述-v6">¶</a>概述</h2><p><img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/stardust14/picture/master/img/20200802215932.png" alt="image-20200802215928812"></p><h2 id="格式与使用"><a class="header-anchor" href="#格式与使用">¶</a>格式与使用</h2><pre><code class="language-java">/*代码当中体现多态性，其实就是一句话: 父类引用指向子类对象。格式:父类名称对象名= new 子类名称();或者:接口名称对象名= new 实现类名称();*/</code></pre><blockquote><p>左父右子</p></blockquote><h2 id="成员变量的使用特点"><a class="header-anchor" href="#成员变量的使用特点">¶</a>成员变量的使用特点</h2><p>访问成员变量的两种方式:<br>1.直接通过对象名称访问成员变量:看等号左边是谁，优先用谁，没有则向上找。<br>2.间接通过成员方法访问成员变量:看该方法属于谁，优先用谁，没有则向上找。</p><blockquote><p>访问成员变量不能覆盖重写，访问成员方法可以覆盖重写</p><p>永远不会向下找</p></blockquote><h2 id="成员方法的使用特点"><a class="header-anchor" href="#成员方法的使用特点">¶</a>成员方法的使用特点</h2><p>在多态的代码当中，成员方法的访问规则是:<br>看new的是谁，就优先用谁，没有则向上找。</p><blockquote><p>口诀:编译看左边，运行看右边。成员变量不在此列，规则不同</p></blockquote><p><em>对比一下:</em><br>成员变量:编译看左边，运行还看左边。<br>成员方法:编译看左边，运行看右边。</p><h2 id="使用多态的好处"><a class="header-anchor" href="#使用多态的好处">¶</a>使用多态的好处</h2><p><img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/stardust14/picture/master/img/20200802223437.png" alt="image-20200802223149584"></p><h2 id="对象的向上转型和向下转型"><a class="header-anchor" href="#对象的向上转型和向下转型">¶</a>对象的向上转型和向下转型</h2><p><img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/stardust14/picture/master/img/20200803144143.png" alt="image-20200803144141656"></p><h2 id="用instanceof关键字进行判断"><a class="header-anchor" href="#用instanceof关键字进行判断">¶</a>用instanceof关键字进行判断</h2><p>如何才能知道-个父类引用的对象，本来是什么子类?<br><strong>格式:</strong><br>对象<code>instanceof</code> 类名称<br>这将会得到一个<strong>boolean值</strong>结果， 也就是判断前面的对象能不能当做后面类型的实例。</p><blockquote><p>这样的好处：向下转型防止发生异常</p></blockquote><h2 id="笔记本USB接口案例"><a class="header-anchor" href="#笔记本USB接口案例">¶</a>笔记本USB接口案例</h2><h3 id="笔记本电脑"><a class="header-anchor" href="#笔记本电脑">¶</a>笔记本电脑</h3><p>笔记本电脑(laptop) 通常具备使用USB设备的功能。在生产时，笔记本都预留了可以插入USB设备的USB接口,<br>但具体是什么USB设备，笔记本厂商并不关心，只要符合USB规格的设备都可以。</p><p>定义USB接口，具备最基本的开启功能和关闭功能。鼠标和键盘要想能在电脑上使用，那么鼠标和键盘也必须遵守<br>USB规范，实现USB接口，否则鼠标和键盘的生产出来也无法使用。</p><h3 id="案例分析"><a class="header-anchor" href="#案例分析">¶</a>案例分析</h3><p>进行描述笔记本类，实现笔记本使用USB鼠标、USB键盘<br>●USB接口，包含打开设备功能、关闭设备功能<br>●笔记本类，包含开机功能、关机功能、使用USB设备功能<br>●鼠标类，要实现USB接口,并具备点击的方法<br>●键盘类，要实现USB接口，具备敲击的方法</p><p><img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/stardust14/picture/master/img/20200803232808.png" alt="image-20200803145842708"></p><h3 id="案例实现"><a class="header-anchor" href="#案例实现">¶</a>案例实现</h3><pre><code class="language-java">public interface USB &amp;#123;    public abstract void open();//打开设备    public abstract void close();//关闭设备&amp;#125;</code></pre><pre><code class="language-Java">public class Computer &amp;#123;    public void poweron()&amp;#123;        System.out.println(&quot;笔记本电脑开机&quot;);    &amp;#125;    public void poweroff()&amp;#123;        System.out.println(&quot;笔记本电脑关机&quot;);    &amp;#125;    public void useDevice(USB usb)&amp;#123;        usb.open();//打开设备        if (usb instanceof Mouse)&amp;#123;//一定要先进行判断            Mouse mouse = (Mouse) usb;//向下转型            mouse.click();        &amp;#125;        if (usb instanceof Keyboard)&amp;#123;            Keyboard keyboard =(Keyboard) usb;//向下转型            keyboard.type();        &amp;#125;        usb.close();//关闭设备    &amp;#125;&amp;#125;</code></pre><pre><code class="language-java">//鼠标就是一个USB设备public class Mouse implements USB &amp;#123;    @Override    public void open() &amp;#123;        System.out.println(&quot;打开鼠标&quot;);    &amp;#125;    @Override    public void close() &amp;#123;        System.out.println(&quot;关闭鼠标&quot;);    &amp;#125;    public void click()&amp;#123;        System.out.println(&quot;点击鼠标&quot;);    &amp;#125;&amp;#125;</code></pre><pre><code class="language-java">//键盘就是一个USB设备public class Keyboard implements USB &amp;#123;    @Override    public void open() &amp;#123;        System.out.println(&quot;打开键盘&quot;);    &amp;#125;    @Override    public void close() &amp;#123;        System.out.println(&quot;关闭键盘&quot;);    &amp;#125;    public void type()&amp;#123;        System.out.println(&quot;键盘输入&quot;);    &amp;#125;&amp;#125;</code></pre><pre><code class="language-java">public class DomeMain &amp;#123;    public static void main(String[] args) &amp;#123;        //首先创建一个笔记本电脑        Computer compuer = new Computer();        compuer.poweron();        //准备一个竖标，供电脑使用//        Mouse mouse = new Mouse();//这是一种方法        //首先准备向上转型        USB usbMouse = new Mouse();//这是另一种方法,多态写法        //参数是USB类型，我正好传递进去的就是USB鼠标        compuer.useDevice(usbMouse);        Keyboard keyboard = new Keyboard();//没有使用多态写法        //方法参数是USB类型，传递进去的是实现类对象        compuer.useDevice(keyboard);//正确写法!也发生了向上转型        ////        compuer.useDevice(new Keyboard());//这也是正确写法        compuer.poweroff();        System.out.println(&quot;============&quot;);        //对于没有使用多态写法的解释        method(10.0);//正确写法，double --&gt; double        method(20);//正确写法，int--&gt;double        int a = 30;        method(a);//正确写法，int--&gt;double    &amp;#125;    public static void method(double num)&amp;#123;        System.out.println(num);    &amp;#125;&amp;#125;</code></pre><h1>final关键字</h1><h2 id="概念及用法"><a class="header-anchor" href="#概念及用法">¶</a>概念及用法</h2><p>final关键字代表最终、不可改变的。<br>常见四种用法:<br>1.可以用来修饰一个类<br>2.可以用来修饰一个方法<br>3.可以用来修饰一个局部变量<br>4.还可以用来修饰一一个成员变量</p><h2 id="用于修饰类"><a class="header-anchor" href="#用于修饰类">¶</a>用于修饰类</h2><pre><code class="language-java">/*当final天键字用来修饰一个类的时候，格式:public final class类名称&amp;#123;    //...&amp;#125;含义:当前这个类不能有任何的子类。(太监类)注意:一个类如果是final的，那么其中所有的成员方法都无法进行覆盖重写(因为没儿子。) */public final class Myclass &amp;#123;    public void method()&amp;#123;        System.out.println(&quot;final方法类&quot;);    &amp;#125;&amp;#125;</code></pre><h2 id="用于修饰成员方法"><a class="header-anchor" href="#用于修饰成员方法">¶</a>用于修饰成员方法</h2><pre><code class="language-java">/*当final关键字用来修饰一一个方法的时候，这个方法就是最终方法，也就是不能被覆盖重写。格式:修饰符final 返回值类型方法名称(参数列表) &amp;#123;    //方法体&amp;#125;注意事项:对于类、方法来说，abstract关键字和final关键字不能同时使用，因为矛盾。 */public abstract class Fu &amp;#123;    public final void method()&amp;#123;        System.out.println(&quot;父类方法执行&quot;);    &amp;#125;        public abstract /*final*/ void methodAbs();&amp;#125;</code></pre><h2 id="用于修饰局部变量"><a class="header-anchor" href="#用于修饰局部变量">¶</a>用于修饰局部变量</h2><pre><code class="language-java">public class Dome01Final &amp;#123;    public static void main(String[] args) &amp;#123;        int num1 = 10;        System.out.println(num1);//10        num1 = 20;        System.out.println(num1);//20        //一旦使用final用来修饰局部变量，那么这个变量就不能进行更改。        //“一次赋值，终生不变        final int num2 = 100;        System.out.println(num2);//        num2 = 250;//错误写法，不能改变//        num2 = 100;//错误写法！        //正确写法，只要保证有唯一一次赋值即可        final int num3;        num3 = 300;        //对于基本类型来说， 不可变说的是变量当中的数据不 可改变        //对于引用类型来说，不可变说的是变量当中的地址值不可改变        Student stu1 = new Student(&quot;Rose&quot;);        System.out.println(stu1.getName());//Rose        System.out.println(stu1);        stu1 = new Student(&quot;Rechal&quot;);        System.out.println(stu1);        System.out.println(stu1.getName());//Rechal        System.out.println(&quot;==========&quot;);        final Student stu2 = new Student(&quot;Jeoy&quot;);//Jeoy        //错误写法！final的引用类型变量，其中的地址不可改变//        stu2 = new Student(&quot;Pheebs&quot;);        stu2.setName(&quot;Chandler&quot;);//Chandler    &amp;#125;&amp;#125;</code></pre><h2 id="用于修饰成员变量"><a class="header-anchor" href="#用于修饰成员变量">¶</a>用于修饰成员变量</h2><pre><code class="language-java">/*对于成员变量来说，如果使用final关键字修饰，那么这个变量也照样是不可变。1.由于成员变量具有默认值，所以用了final之后必须手动赋值，不会再给默认值了。2.对于final的成员变量，要么使用直接赋值，要么通过构造方法赋值。二者选其一3.必须保证类当中所有重载的构造方法，都最终会对final的成员变量进行赋值。 */public class Person &amp;#123;    final private String name/* = &quot;Mon&quot;*/;    public Person() &amp;#123;        name =&quot;Chandler&quot;;    &amp;#125;    public Person(String name) &amp;#123;        this.name = name;    &amp;#125;    public String getName() &amp;#123;        return name;    &amp;#125;   /* public void setName(String name) &amp;#123;        this.name = name;    &amp;#125;*/&amp;#125;</code></pre><h2 id="四种权限修饰符"><a class="header-anchor" href="#四种权限修饰符">¶</a>四种权限修饰符</h2><p><strong>Java中有四种权限修饰符:</strong></p><table><thead><tr><th></th><th>public &gt;</th><th>protected &gt;</th><th>(default) &gt;</th><th style="text-align:center">private</th></tr></thead><tbody><tr><td>同一个类(我自己)</td><td>YES</td><td>YES</td><td>YES</td><td style="text-align:center">YES</td></tr><tr><td>同一个包(我邻居)</td><td>YES</td><td>YES</td><td>YES</td><td style="text-align:center">NO</td></tr><tr><td>不同包子类(我儿子)</td><td>YES</td><td>YES</td><td>NO</td><td style="text-align:center">NO</td></tr><tr><td>不同包非子类(陌生人)</td><td>YES</td><td>NO</td><td>NO</td><td style="text-align:center">NO</td></tr></tbody></table><blockquote><p>注意事项: (default)并不是关键字“default&quot;， 而是根本不写。</p></blockquote><h1>内部类</h1><h2 id="概念与分类"><a class="header-anchor" href="#概念与分类">¶</a>概念与分类</h2><p>如果一个事物的内部包含另一个事物，那么这就是一个类内部包含另一个类。<br>例如:身体和心脏的关系。又如:汽车和发动机的关系。</p><p>分类:<br>1.成员内部类<br>2.局部内部类(包含匿名内部类)</p><h2 id="成员内部类的定义"><a class="header-anchor" href="#成员内部类的定义">¶</a>成员内部类的定义</h2><p>成员内部类的定义格式:<br>修饰符class 外部类名称{<br>修饰符class 内部类名称{<br>//…<br>}<br>//…<br>}</p><pre><code class="language-java">public class Body &amp;#123;//外部类    public class Heart&amp;#123;//成员内部类        //内部类的方法        public void beat()&amp;#123;            System.out.println(&quot;心脏跳动：咚咚咚~~~&quot;);            System.out.println(&quot;我叫&quot; + name);        &amp;#125;    &amp;#125;    //外部类的成员变量    private String name;    //外部类的方法    public void methodBody()&amp;#123;        System.out.println(&quot;外部类的方法&quot;);    &amp;#125;    public String getName() &amp;#123;        return name;    &amp;#125;    public void setName(String name) &amp;#123;        this.name = name;    &amp;#125;&amp;#125;</code></pre><blockquote><p>注意:内用外，随意访问;外用内，需要内部类对象。需要命令Recompile命令Ctrl+Shift+F9</p></blockquote><h2 id="成员内部类的使用"><a class="header-anchor" href="#成员内部类的使用">¶</a>成员内部类的使用</h2><pre><code class="language-java">public class Body &amp;#123;//外部类    public class Heart&amp;#123;//成员内部类        //内部类的方法        public void beat()&amp;#123;            System.out.println(&quot;心脏跳动：咚咚咚~~~&quot;);            System.out.println(&quot;我叫&quot; + name);        &amp;#125;    &amp;#125;    //外部类的成员变量    private String name;    //外部类的方法    public void methodBody()&amp;#123;        System.out.println(&quot;外部类的方法&quot;);        //新添加的调用内部类的一种方法        /*Heart heart = new Heart();        heart.beat();*/        new Heart().beat();//这是另一种方法    &amp;#125;    public String getName() &amp;#123;        return name;    &amp;#125;    public void setName(String name) &amp;#123;        this.name = name;    &amp;#125;&amp;#125;</code></pre><pre><code class="language-java">/*如何使用成员内部类?有两种方式:1.间接方式:在外部类的方法当中，使用内部类;然后main只是调用外部类的方法。2.直接方式，公式:类名称对象名= new类名称();【外部类名称.内部类名称对象名= new 外部类名称().new内部类名称();】 */public class Dome01InnerClass &amp;#123;    public static void main(String[] args) &amp;#123;        Body body = new Body();//外部类的对象        //通过外部类的对象，调用外部类的方法，里面间接在使用内部类Heart        body.methodBody();        System.out.println(&quot;=============&quot;);        //按照公式写        Body.Heart heart = new Body().new Heart();        heart.beat();    &amp;#125;&amp;#125;</code></pre><h2 id="内部类的同名变量访问"><a class="header-anchor" href="#内部类的同名变量访问">¶</a>内部类的同名变量访问</h2><pre><code class="language-java">/*如果出现了重名现象，那么格式是:外部类名称. this .外部类成员变量名 */public class Outer &amp;#123;    int num = 10;//外部类的成员变量    public class Inner&amp;#123;        int num = 20;        public void methodInner()&amp;#123;            int num = 30;//内部类方法的局部变量            System.out.println(num);//局部变量，就近原则            System.out.println(this.num);//内部类的成员变量            System.out.println(Outer.this.num);//外部类的成员变量        &amp;#125;    &amp;#125;&amp;#125;</code></pre><pre><code class="language-java">public class Dome02InnerClass &amp;#123;    public static void main(String[] args) &amp;#123;        //外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称();        Outer.Inner obj = new Outer().new Inner();        obj.methodInner();    &amp;#125;&amp;#125;</code></pre><h2 id="局部内部类定义"><a class="header-anchor" href="#局部内部类定义">¶</a>局部内部类定义</h2><pre><code class="language-java">/*如果一个类是定义在一 个方法内部的，那么这就是一个局部内部类。“局部”:只有当前所属的方法才能使用它，出了这个方法外面就不能用了。定义格式:修饰符class外部类名称&amp;#123;    修饰符返回值类型外部类方法名称(参数列表) &amp;#123;        class局部内部类名称&amp;#123;            // ...        &amp;#125;    &amp;#125;&amp;#125;小节一下类的权限修饰符:public &gt; protected &gt; (default) &gt; private定义一个类的时候，权限修饰符规则:1.外部类: public / (default)2.成员内部类: public / protected / (default) / private3.局部内部类:什么都不能写 */public class Outer01 &amp;#123;    public void methodOuter()&amp;#123;        class Inner&amp;#123;//局部内部类            int num = 10;            public void mothodInner()&amp;#123;                System.out.println(num);//10            &amp;#125;        &amp;#125;        //使用局部类，除了当前方法，谁用都不行        Inner inner = new Inner();        inner.mothodInner();    &amp;#125;&amp;#125;</code></pre><pre><code class="language-java">public class DomeMain &amp;#123;    public static void main(String[] args) &amp;#123;        Outer01 obj = new Outer01();        obj.methodOuter();    &amp;#125;&amp;#125;</code></pre><h2 id="局部内部类的final问题"><a class="header-anchor" href="#局部内部类的final问题">¶</a>局部内部类的final问题</h2><pre><code class="language-java">/*局部内部类，如果希望访问所在方法的局部变量，那么这个局部变量必须是【有效final的】。备注:从Java 8+开始，只要局部变量事实不变，那么final关键字可以省略。原因:1. new出来的对象在堆内存当中。2.局部变量是跟着方法走的，在栈内存当中。3.方法运行结束之后，立刻出栈，局部变量就会立刻消失。4.但是new出来的对象会在堆当中持续存在，直到垃圾回收消失。 */public class MyOuter &amp;#123;    public void methodOuter()&amp;#123;        int num = 10;//所在方法的局部变量        class MyInnner&amp;#123;            public void methodInner()&amp;#123;                System.out.println(num);            &amp;#125;        &amp;#125;    &amp;#125;&amp;#125;</code></pre><h2 id="匿名内部类及其注意事项"><a class="header-anchor" href="#匿名内部类及其注意事项">¶</a>匿名内部类及其注意事项</h2><pre><code class="language-java">/*如果接口的实现类(或者是父类的子类)只需要使用唯一的一次，那么这种情况下就可以省略掉该类的定义，而改为使用【匿名内部类】匿名内部类的定义格式:接口名称对象名= new 接口名称() &amp;#123;    // 覆盖重写所有抽象方法&amp;#125;;对格式“new接口名称() &amp;#123;... &amp;#125;进行解析:1. new代表创建对象的动作2.接口名称就是匿名内部类需要实现哪个接口3. &amp;#123;... &amp;#125;这才是匿名内部类的内容另外还要注意几点问题:1.匿名内部类，在【创建对象】的时候，只能使用唯一次。如果希望多次创建对象，而且类的内容一样的话， 那么就必须使用单独定义的实现类了。2.匿名对象，在【调用方法】的时候，只能调用唯一次。如果希望同一个对象，调用多次方法，那么必须给对象起个名字。3.匿名内部类是省略了【实现类子类名称】，但是匿名对象是省略了【对象名称】强调:匿名内部类和匿名对象不是一回事！！！ */public class Dome01Main &amp;#123;    public static void main(String[] args) &amp;#123;        //使用匿名内部类,但不是匿名对象，对象名称就叫objA        MyInterface objA = new MyInterface() &amp;#123;            @Override            public void method1() &amp;#123;                System.out.println(&quot;匿名内部类实现了方法!111-A&quot;);            &amp;#125;            @Override            public void method2() &amp;#123;                System.out.println(&quot;匿名内部类实现了方法！222-A&quot;);            &amp;#125;        &amp;#125;;        objA.method1();        objA.method2();        System.out.println(&quot;==========&quot;);    //使用了匿名对象类，而且省略了对象名称，也是匿名对象    new MyInterface() &amp;#123;        @Override        public void method1() &amp;#123;            System.out.println(&quot;匿名内部类实现了方法!111-B&quot;);        &amp;#125;        @Override        public void method2() &amp;#123;            System.out.println(&quot;匿名内部类实现了方法！222-B&quot;);        &amp;#125;    &amp;#125;.method1();    //因为匿名对象无法调用第二次方法，所以需要在创建一个匿名内部类的匿名对象        new MyInterface() &amp;#123;            @Override            public void method1() &amp;#123;                System.out.println(&quot;匿名内部类实现了方法!111-B&quot;);            &amp;#125;            @Override            public void method2() &amp;#123;                System.out.println(&quot;匿名内部类实现了方法！222-B&quot;);            &amp;#125;        &amp;#125;.method2();    &amp;#125;&amp;#125;</code></pre><h2 id="类作为成员变量类型"><a class="header-anchor" href="#类作为成员变量类型">¶</a>类作为成员变量类型</h2><pre><code class="language-java">//游戏当中的英雄角色类public class Hero &amp;#123;    private String name;//英雄的名字    private int age;//英雄的年龄    private Weapon weapon;//英雄的武器    public Hero() &amp;#123;    &amp;#125;    public Hero(String name, int age, Weapon weapon) &amp;#123;        this.name = name;        this.age = age;        this.weapon = weapon;    &amp;#125;    public void attack()&amp;#123;        System.out.println(&quot;年龄为&quot; + age + &quot;的&quot; + name + &quot;用&quot; +weapon.getCode() + &quot;击败了敌方英雄&quot;);    &amp;#125;    public String getName() &amp;#123;        return name;    &amp;#125;    public void setName(String name) &amp;#123;        this.name = name;    &amp;#125;    public int getAge() &amp;#123;        return age;    &amp;#125;    public void setAge(int age) &amp;#123;        this.age = age;    &amp;#125;    public Weapon getWeapon() &amp;#123;        return weapon;    &amp;#125;    public void setWeapon(Weapon weapon) &amp;#123;        this.weapon = weapon;    &amp;#125;&amp;#125;</code></pre><pre><code class="language-java">//英雄的武器类public class Weapon &amp;#123;    private String code;//英雄的武器代号    public Weapon() &amp;#123;    &amp;#125;    public Weapon(String code) &amp;#123;        this.code = code;    &amp;#125;    public String getCode() &amp;#123;        return code;    &amp;#125;    public void setCode(String code) &amp;#123;        this.code = code;    &amp;#125;&amp;#125;</code></pre><pre><code class="language-java">public class Dome02Main &amp;#123;    public static void main(String[] args) &amp;#123;        //创建一个英雄角色        Hero hero = new Hero();        //为英雄起一个名字，并设置年龄        hero.setName(&quot;盖伦&quot;);        hero.setAge(20);        //创建一个英雄武器        Weapon weapon = new Weapon(&quot;多兰剑&quot;);        hero.setWeapon(weapon);        hero.attack();    &amp;#125;&amp;#125;</code></pre><h2 id="接口作为成员变量类型"><a class="header-anchor" href="#接口作为成员变量类型">¶</a>接口作为成员变量类型</h2><pre><code class="language-java">public class Hero01 &amp;#123;    private String name;//英雄的名字    private Skill skill;//英雄的技能    public Hero01() &amp;#123;    &amp;#125;    public Hero01(String name, Skill skill) &amp;#123;        this.name = name;        this.skill = skill;    &amp;#125;    public void attack()&amp;#123;        System.out.println(&quot;我叫&quot; + name + &quot;,开始释放技能：&quot;);        skill.use();//调用接口中的抽象方法        System.out.println(&quot;释放技能完成！&quot;);    &amp;#125;    public String getName() &amp;#123;        return name;    &amp;#125;    public void setName(String name) &amp;#123;        this.name = name;    &amp;#125;    public Skill getSkill() &amp;#123;        return skill;    &amp;#125;    public void setSkill(Skill skill) &amp;#123;        this.skill = skill;    &amp;#125;&amp;#125;</code></pre><pre><code class="language-java">public interface Skill &amp;#123;    void use();//释放技能的抽象方法&amp;#125;</code></pre><pre><code class="language-java">public class SkillImpl implements Skill &amp;#123;    @Override    public void use() &amp;#123;        System.out.println(&quot;Biu~Biu~Biu~&quot;);    &amp;#125;&amp;#125;</code></pre><pre><code class="language-java">public class DomeGame &amp;#123;    public static void main(String[] args) &amp;#123;        Hero01 hero01 = new Hero01();        hero01.setName(&quot;艾希&quot;);        //设置英雄技能//        hero01.setSkill(new SkillImpl());//使用单独定义的实现类        //还可以改成使用匿名内部类        /*Skill skill = new Skill() &amp;#123;            @Override            public void use() &amp;#123;                System.out.println(&quot;Pia~Pia~Pia~&quot;);            &amp;#125;        &amp;#125;;        hero01.setSkill(skill);*/        //进一步简化        hero01.setSkill(new Skill() &amp;#123;            @Override            public void use() &amp;#123;                System.out.println(&quot;Biu~Pia~Biu~Pia~&quot;);            &amp;#125;        &amp;#125;);        hero01.attack();    &amp;#125;&amp;#125;</code></pre><h2 id="接口作为方法的参数或返回值"><a class="header-anchor" href="#接口作为方法的参数或返回值">¶</a>接口作为方法的参数或返回值</h2><pre><code class="language-java">import java.util.ArrayList;import java.util.List;/*java.util.List正是ArrayList所实现的接口。 */public class DomeInterface &amp;#123;    public static void main(String[] args) &amp;#123;        //左边是接口名称，右边是实现类名称，这就是多态写法        List&lt;String&gt; list = new ArrayList&lt;&gt;();        List&lt;String&gt; result = addNames(list);        for (int i = 0; i &lt; result.size(); i++) &amp;#123;            System.out.println(result.get(i));        &amp;#125;    &amp;#125;        //给了一个空集合，进来之后添加了，出去之后就有新东西了    public static List&lt;String&gt; addNames(List&lt;String&gt; list)&amp;#123;        list.add(&quot;Rose&quot;);        list.add(&quot;Rechal&quot;);        list.add(&quot;霉霉&quot;);        return list;    &amp;#125;&amp;#125;</code></pre><h2 id="发红包案例"><a class="header-anchor" href="#发红包案例">¶</a>发红包案例</h2><h3 id="分析"><a class="header-anchor" href="#分析">¶</a>分析</h3><pre><code class="language-java">import cn.itcast.day.demo01.red.OpenMode;/*场景说明:    红包发出去之后，所有人都有红包，大家抢完了之后，最后一个红包给群主自己。大多数代码都是现成的，我们需要做的就是填空题。我们自己要做的事情有:    1.设置一下程序的标题，通过构造方法的字符串参数    2.设置群主名称I    3.设置分发策略:平均，还是随机? |红包分发的策略:    1.普通红包(平均) : totalMoney / totalCount, 余数放在最后一个红包当 中。    2.手气红包(随机);最少1分钱，最多不超过平均数的2倍。应该越发越少。 */public class Bootstrap &amp;#123;    public static void main(String[] args) &amp;#123;        MyRed red = new MyRed(&quot;红包发发发&quot;);        //设置群主名称        red.setOwnerName(&quot;乔布斯&quot;);        /*//普通红包        OpenMode normal = new NormalMode();        red.setOpenWay(normal);*/        //手气红包        OpenMode random = new RandomMode();        red.setOpenWay(random);    &amp;#125;&amp;#125;</code></pre><h3 id="普通红包平均分发"><a class="header-anchor" href="#普通红包平均分发">¶</a>普通红包平均分发</h3><p><img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/stardust14/picture/master/img/20200804215918.png" alt="image-20200804215912112"></p><p><img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/stardust14/picture/master/img/20200804215944.png" alt="image-20200804215943078"></p><p><img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/stardust14/picture/master/img/20200804220210.png" alt="image-20200804220009753"></p><pre><code class="language-java">import cn.itcast.day.demo01.red.OpenMode;import java.util.ArrayList;public class NormalMode implements OpenMode &amp;#123;    @Override    public ArrayList&lt;Integer&gt; divide(final int totalMoney, final int totalCount) &amp;#123;        ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();        int avg = totalMoney / totalCount;//平均值        int mod = totalMoney % totalCount;//余数，模，零头        //注意totallCount - 1代表，最后一个先留着        for (int i = 0; i &lt; totalCount - 1; i++) &amp;#123;            list.add(avg);        &amp;#125;        //有零头，需要先放在最后一个红包里        list.add(avg + mod);        return list;    &amp;#125;&amp;#125;</code></pre><h3 id="手气红包随机分发"><a class="header-anchor" href="#手气红包随机分发">¶</a>手气红包随机分发</h3><p><img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/stardust14/picture/master/img/20200804222622.png" alt="image-20200804222621272"></p><p><img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/stardust14/picture/master/img/20200804222641.png" alt="image-20200804222639346"></p><p><img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/stardust14/picture/master/img/20200804222835.png" alt="image-20200804222655186"></p><pre><code class="language-java">import cn.itcast.day.demo01.red.OpenMode;import java.util.ArrayList;import java.util.Random;public class RandomMode implements OpenMode &amp;#123;    @Override    public ArrayList&lt;Integer&gt; divide(int totalMoney, int totalCount) &amp;#123;        ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();        //随机分配，有可能多，有可能少        //最少一分钱，最多不超过“剩下金额平均数的2倍”        // 第一次友红包，随札范围是0. 01元~6.66元        //第一次发完之后，剩下的至少是3.34元。        //此时还需要再发2个红包        //此时的再发范围应该是0.01元~3.34元(取不到右边，剩下0. 01)        //总结一下，范围的[公式]是: 1 + random. nextInt(leftMoney / leftCount * 2);        Random r = new Random();//首先创建一个随机数生成器        // totalMoney是 总金额，totalCount是总份数，不变        //额外定义两个变量，分别代表剩下多少钱，剩下多少份        int leftMoney = totalMoney;        int leftCount = totalCount;        //随机发n - 1个，最后一个不需要随机        for (int i = 0; i &lt; totalCount - 1; i++) &amp;#123;            //按照公式生成随机金额            int money = r.nextInt(leftMoney / leftCount * 2) + 1;            list.add(money);//将一个随机红包包好放入集合            leftMoney -=money;//剩下的金额越发越少            leftCount--;//剩下还应该再发的红包个数，递减        &amp;#125;        //最后一个不需要随机，直接放进去就行了        list.add(leftMoney);        return list;    &amp;#125;&amp;#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo出现的问题</title>
      <link href="/stardust14.github.io/2020/07/06/hexo%E5%8D%9A%E5%AE%A2%E9%81%87%E5%88%B0%E7%9A%84%E9%94%99%E8%AF%AF/"/>
      <url>/stardust14.github.io/2020/07/06/hexo%E5%8D%9A%E5%AE%A2%E9%81%87%E5%88%B0%E7%9A%84%E9%94%99%E8%AF%AF/</url>
      
        <content type="html"><![CDATA[<h1>在进行博客编写过程中，出现了一些问题。</h1><h2 id="1、出现hexo无法识别"><a class="header-anchor" href="#1、出现hexo无法识别">¶</a>1、出现hexo无法识别</h2><p>‘hexo’ 不是内部或外部命令，也不是可运行的程序 或批处理文件。<br>或着是<code>bash: hexo: command not found</code></p><p>参考网上的经验贴,修改环境变量</p><p><img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/stardust14/picture/master/img/20200707174137.png" alt="image-20200707174134036"></p><h2 id="2、出现cnpm不能识别"><a class="header-anchor" href="#2、出现cnpm不能识别">¶</a>2、出现cnpm不能识别</h2><p>‘cnpm’ 不是内部或外部命令，也不是可运行的程序 或批处理文件。</p><p>把C盘的一些文件复制到博客安装的目录中去</p><p><img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/stardust14/picture/master/img/20200707174434.png" alt="image-20200707174432439"></p><h2 id="3、图片无法加载"><a class="header-anchor" href="#3、图片无法加载">¶</a>3、图片无法加载</h2><p>使用<strong>typora+picgo</strong>插入图片，部署到github上去。</p><p>出现了好多错误，直接剪切上传后正常，保存后在上传加载不出，但是下面也有加载出来的。。。</p><p>参考网上的解决方案，修改了hosts文件，配置了一些picgo的设置。</p><p><img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/stardust14/picture/master/img/20200707175357.png" alt="image-20200707175355687"></p><h2 id="4、-出现本地4000端口占用问题"><a class="header-anchor" href="#4、-出现本地4000端口占用问题">¶</a>4、  出现本地4000端口占用问题</h2><p>打开cmd输入 <code>netstat -nao | findstr 4000</code>查询4000端口占用的程序</p><p><img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/stardust14/picture/master/img/20200707171831.png" alt="Image"></p><p>可以看到 PID为 24016 的进程占用了4000端口，如果进一步你想知道它的进程名称，你可以使用如下命令： <code>tasklist | findstr 24016</code> 执行终止程序</p><h2 id="5、-git-bush中ctrl-c退出不了（bug）"><a class="header-anchor" href="#5、-git-bush中ctrl-c退出不了（bug）">¶</a>5、  git bush中ctrl+c退出不了（bug）</h2><p>打开cmd，输入：<code>taskkill /F /IM node.exe</code></p><p><img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/stardust14/picture/master/img/20200707171737.png" alt="Image"></p><p>搞定~~~~</p><h2 id="6、部署到GitHub上电脑无法访问的问题"><a class="header-anchor" href="#6、部署到GitHub上电脑无法访问的问题">¶</a>6、部署到GitHub上电脑无法访问的问题</h2><p>这是由于<code>https：//</code>这个格式</p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何修改blog</title>
      <link href="/stardust14.github.io/2020/01/05/%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9blog/"/>
      <url>/stardust14.github.io/2020/01/05/%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9blog/</url>
      
        <content type="html"><![CDATA[<h1>学习怎么进行主题设置</h1><h2 id="参考网上的教程，进行学习"><a class="header-anchor" href="#参考网上的教程，进行学习">¶</a>参考网上的教程，进行学习</h2><p>基本的使用:</p><h1>一级标题（# ）</h1><h2 id="二级标题（-）"><a class="header-anchor" href="#二级标题（-）">¶</a>二级标题（## ）</h2><h3 id="三级标题（-）"><a class="header-anchor" href="#三级标题（-）">¶</a>三级标题（### ）</h3><blockquote><p>以此类推（引用&gt;）</p></blockquote><p>虚线（—、***）</p><ul><li>列表1<br>a 字列表<br><a href="https://www.baidu.com/?tn=98012088_5_dg&amp;ch=12">百度</a></li></ul><blockquote><p>超链接</p></blockquote><p><em>斜体</em><br><strong>粗体</strong></p><p><code>&lt;html&gt;&lt;/html&gt;</code></p><pre><code>&lt;html&gt;  &lt;head&gt;&lt;title&gt;代码引用，直接敲&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>first blog</title>
      <link href="/stardust14.github.io/2020/01/04/first-blog/"/>
      <url>/stardust14.github.io/2020/01/04/first-blog/</url>
      
        <content type="html"><![CDATA[<p>first blog</p><p>内容：又重新来了一遍！</p><hr><p>second</p><p>内容：太不容易了。</p><hr><p>参考：</p><p>来自B站codecheeep</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/stardust14.github.io/2020/01/04/hello-world/"/>
      <url>/stardust14.github.io/2020/01/04/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a class="header-anchor" href="#Quick-Start">¶</a>Quick Start</h2><h3 id="Create-a-new-post"><a class="header-anchor" href="#Create-a-new-post">¶</a>Create a new post</h3><pre><code class="language-bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a class="header-anchor" href="#Run-server">¶</a>Run server</h3><pre><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a class="header-anchor" href="#Generate-static-files">¶</a>Generate static files</h3><pre><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a class="header-anchor" href="#Deploy-to-remote-sites">¶</a>Deploy to remote sites</h3><pre><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
