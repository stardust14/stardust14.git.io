<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>C语言基础 | STAR</title><meta name="keywords" content="C"><meta name="author" content="stardust,邮箱"><meta name="copyright" content="stardust"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="引言 基于VS2019版，编写练习代码，基础中的基础。通过菜鸟教程上的知识学习。 C语言基本 ¶基本语法 ¶标识符 C 标识符是用来标识变量、函数，或任何其他用户自定义项目的名称。一个标识符以字母 A-Z 或 a-z 或下划线 _ 开始，后跟零个或多个字母、下划线和数字（0-9）。 C 标识符内不允许出现标点字符，比如 @、$ 和 %。C 是区分大小写的编程语言。因此，在 C 中，Manpower">
<meta property="og:type" content="article">
<meta property="og:title" content="C语言基础">
<meta property="og:url" content="http://stardust14.com/2020/09/08/C%E8%AF%AD%E8%A8%80/index.html">
<meta property="og:site_name" content="STAR">
<meta property="og:description" content="引言 基于VS2019版，编写练习代码，基础中的基础。通过菜鸟教程上的知识学习。 C语言基本 ¶基本语法 ¶标识符 C 标识符是用来标识变量、函数，或任何其他用户自定义项目的名称。一个标识符以字母 A-Z 或 a-z 或下划线 _ 开始，后跟零个或多个字母、下划线和数字（0-9）。 C 标识符内不允许出现标点字符，比如 @、$ 和 %。C 是区分大小写的编程语言。因此，在 C 中，Manpower">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/stardust14/picture/img/Number_one_gril.jpg">
<meta property="article:published_time" content="2020-09-08T11:58:34.000Z">
<meta property="article:modified_time" content="2020-10-27T09:06:55.968Z">
<meta property="article:author" content="stardust">
<meta property="article:tag" content="C">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/stardust14/picture/img/Number_one_gril.jpg"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/stardust14/picture/img/blogstar.png"><link rel="canonical" href="http://stardust14.com/2020/09/08/C%E8%AF%AD%E8%A8%80/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2020-10-27 17:06:55'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/stardust14/CDN/HexoStatic/css/newboth.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/stardust14/CDN/HexoStatic/css/hideCategory.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/stardust14/CDN/HexoStatic/css/scrollBar.css"><link rel="stylesheet" href="/css/mouse.css"><link rel="stylesheet" href="/css/icon.css" media="defer" onload="this.media='all"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/swiper/swiper-bundle.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/css/main.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/hexo-electric-clock@1.0.6/clock.css"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.0.0"><link rel="alternate" href="/atom.xml" title="STAR" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/images/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 放松一下</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page child" href="/photograph"><i class="fa-fw fa fa-globe"></i><span> Photograph</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-book"></i><span> 专栏</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/pdf/"><i class="fa-fw fa fa-file-pdf"></i><span> pdf</span></a></li><li><a class="site-page child" href="/%E9%9A%8F%E7%AC%94"><i class="fa-fw fas fa-pencil-alt"></i><span> 随笔</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于me</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/stardust14/picture/img/Number_one_gril.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">STAR</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 放松一下</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page child" href="/photograph"><i class="fa-fw fa fa-globe"></i><span> Photograph</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-book"></i><span> 专栏</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/pdf/"><i class="fa-fw fa fa-file-pdf"></i><span> pdf</span></a></li><li><a class="site-page child" href="/%E9%9A%8F%E7%AC%94"><i class="fa-fw fas fa-pencil-alt"></i><span> 随笔</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于me</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">C语言基础<a class="post-edit-link" href="null_posts/C语言.md" title="编辑" target="_blank"><i class="fas fa-pencil-alt"></i></a></h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-09-08T11:58:34.000Z" title="发表于 2020-09-08 19:58:34">2020-09-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-10-27T09:06:55.968Z" title="更新于 2020-10-27 17:06:55">2020-10-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/">C</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">38.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>143分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C语言基础"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>引言</h1>
<p>基于VS2019版，编写练习代码，基础中的基础。通过菜鸟教程上的知识学习。</p>
<h1>C语言基本</h1>
<h2 id="基本语法"><a class="header-anchor" href="#基本语法">¶</a>基本语法</h2>
<h3 id="标识符"><a class="header-anchor" href="#标识符">¶</a>标识符</h3>
<p>C 标识符是用来标识变量、函数，或任何其他用户自定义项目的名称。一个标识符以字母 A-Z 或 a-z 或下划线 _ 开始，后跟零个或多个字母、下划线和数字（0-9）。</p>
<p>C 标识符内不允许出现标点字符，比如 @、$ 和 %。C 是<strong>区分大小写</strong>的编程语言。因此，在 C 中，<em>Manpower</em> 和 <em>manpower</em> 是两个不同的标识符。下面列出几个有效的标识符：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">mohd       zara    abc   move<span class="emphasis">_name  a_</span>123</span><br><span class="line">myname50   <span class="emphasis">_temp   j     a23b9      retVal</span></span><br></pre></td></tr></table></figure>
<h3 id="关键字"><a class="header-anchor" href="#关键字">¶</a>关键字</h3>
<p>下表列出了 C 中的保留字。这些保留字不能作为常量名、变量名或其他标识符名称。</p>
<table>
<thead>
<tr>
<th style="text-align:left">关键字</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">auto</td>
<td style="text-align:left">声明自动变量</td>
</tr>
<tr>
<td style="text-align:left">break</td>
<td style="text-align:left">跳出当前循环</td>
</tr>
<tr>
<td style="text-align:left">case</td>
<td style="text-align:left">开关语句分支</td>
</tr>
<tr>
<td style="text-align:left">char</td>
<td style="text-align:left">声明字符型变量或函数返回值类型</td>
</tr>
<tr>
<td style="text-align:left">const</td>
<td style="text-align:left">定义常量，如果一个变量被 const 修饰，那么它的值就不能再被改变</td>
</tr>
<tr>
<td style="text-align:left">continue</td>
<td style="text-align:left">结束当前循环，开始下一轮循环</td>
</tr>
<tr>
<td style="text-align:left">default</td>
<td style="text-align:left">开关语句中的&quot;其它&quot;分支</td>
</tr>
<tr>
<td style="text-align:left">do</td>
<td style="text-align:left">循环语句的循环体</td>
</tr>
<tr>
<td style="text-align:left">double</td>
<td style="text-align:left">声明双精度浮点型变量或函数返回值类型</td>
</tr>
<tr>
<td style="text-align:left">else</td>
<td style="text-align:left">条件语句否定分支（与 if 连用）</td>
</tr>
<tr>
<td style="text-align:left">enum</td>
<td style="text-align:left">声明枚举类型</td>
</tr>
<tr>
<td style="text-align:left">extern</td>
<td style="text-align:left">声明变量或函数是在其它文件或本文件的其他位置定义</td>
</tr>
<tr>
<td style="text-align:left">float</td>
<td style="text-align:left">声明浮点型变量或函数返回值类型</td>
</tr>
<tr>
<td style="text-align:left">for</td>
<td style="text-align:left">一种循环语句</td>
</tr>
<tr>
<td style="text-align:left">goto</td>
<td style="text-align:left">无条件跳转语句</td>
</tr>
<tr>
<td style="text-align:left">if</td>
<td style="text-align:left">条件语句</td>
</tr>
<tr>
<td style="text-align:left">int</td>
<td style="text-align:left">声明整型变量或函数</td>
</tr>
<tr>
<td style="text-align:left">long</td>
<td style="text-align:left">声明长整型变量或函数返回值类型</td>
</tr>
<tr>
<td style="text-align:left">register</td>
<td style="text-align:left">声明寄存器变量</td>
</tr>
<tr>
<td style="text-align:left">return</td>
<td style="text-align:left">子程序返回语句（可以带参数，也可不带参数）</td>
</tr>
<tr>
<td style="text-align:left">short</td>
<td style="text-align:left">声明短整型变量或函数</td>
</tr>
<tr>
<td style="text-align:left">signed</td>
<td style="text-align:left">声明有符号类型变量或函数</td>
</tr>
<tr>
<td style="text-align:left">sizeof</td>
<td style="text-align:left">计算数据类型或变量长度（即所占字节数）</td>
</tr>
<tr>
<td style="text-align:left">static</td>
<td style="text-align:left">声明静态变量</td>
</tr>
<tr>
<td style="text-align:left">struct</td>
<td style="text-align:left">声明结构体类型</td>
</tr>
<tr>
<td style="text-align:left">switch</td>
<td style="text-align:left">用于开关语句</td>
</tr>
<tr>
<td style="text-align:left">typedef</td>
<td style="text-align:left">用以给数据类型取别名</td>
</tr>
<tr>
<td style="text-align:left">unsigned</td>
<td style="text-align:left">声明无符号类型变量或函数</td>
</tr>
<tr>
<td style="text-align:left">union</td>
<td style="text-align:left">声明共用体类型</td>
</tr>
<tr>
<td style="text-align:left">void</td>
<td style="text-align:left">声明函数无返回值或无参数，声明无类型指针</td>
</tr>
<tr>
<td style="text-align:left">volatile</td>
<td style="text-align:left">说明变量在程序执行中可被隐含地改变</td>
</tr>
<tr>
<td style="text-align:left">while</td>
<td style="text-align:left">循环语句的循环条件</td>
</tr>
</tbody>
</table>
<h3 id="C-中的空格"><a class="header-anchor" href="#C-中的空格">¶</a>C 中的空格</h3>
<p>只包含空格的行，被称为空白行，可能带有注释，C 编译器会完全忽略它。</p>
<p>在 C 中，空格用于描述空白符、制表符、换行符和注释。空格分隔语句的各个部分，让编译器能识别语句中的某个元素（比如 int）在哪里结束，下一个元素在哪里开始。因此，在下面的语句中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> age;</span><br></pre></td></tr></table></figure>
<p>在这里，int 和 age 之间必须至少有一个空格字符（通常是一个空白符），这样编译器才能够区分它们。另一方面，在下面的语句中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fruit = apples + oranges;   <span class="comment">// 获取水果的总数</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>fruit 和 =，或者 = 和 apples 之间的空格字符不是必需的，但是为了增强<strong>可读性</strong>，您可以根据需要适当增加一些空格。</p>
</blockquote>
<h3 id="C-数据类型"><a class="header-anchor" href="#C-数据类型">¶</a>C 数据类型</h3>
<p>在 C 语言中，数据类型指的是用于声明不同类型的变量或函数的一个广泛的系统。变量的类型决定了变量存储占用的空间，以及如何解释存储的位模式。</p>
<p>C 中的类型可分为以下几种：</p>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">类型与描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><strong>基本类型：</strong> 它们是算术类型，包括两种类型：整数类型和浮点类型。</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><strong>枚举类型：</strong> 它们也是算术类型，被用来定义在程序中只能赋予其一定的离散整数值的变量。</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><strong>void 类型：</strong> 类型说明符 <em>void</em> 表明没有可用的值。</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left"><strong>派生类型：</strong> 它们包括：指针类型、数组类型、结构类型、共用体类型和函数类型。</td>
</tr>
</tbody>
</table>
<p>数组类型和结构类型统称为聚合类型。函数的类型指的是函数返回值的类型。</p>
<h4 id="整数类型"><a class="header-anchor" href="#整数类型">¶</a>整数类型</h4>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">存储大小</th>
<th style="text-align:left">值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">char</td>
<td style="text-align:left">1 字节</td>
<td style="text-align:left">-128 到 127 或 0 到 255</td>
</tr>
<tr>
<td style="text-align:left">unsigned char</td>
<td style="text-align:left">1 字节</td>
<td style="text-align:left">0 到 255</td>
</tr>
<tr>
<td style="text-align:left">signed char</td>
<td style="text-align:left">1 字节</td>
<td style="text-align:left">-128 到 127</td>
</tr>
<tr>
<td style="text-align:left">int</td>
<td style="text-align:left">2 或 4 字节</td>
<td style="text-align:left">-32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647</td>
</tr>
<tr>
<td style="text-align:left">unsigned int</td>
<td style="text-align:left">2 或 4 字节</td>
<td style="text-align:left">0 到 65,535 或 0 到 4,294,967,295</td>
</tr>
<tr>
<td style="text-align:left">short</td>
<td style="text-align:left">2 字节</td>
<td style="text-align:left">-32,768 到 32,767</td>
</tr>
<tr>
<td style="text-align:left">unsigned short</td>
<td style="text-align:left">2 字节</td>
<td style="text-align:left">0 到 65,535</td>
</tr>
<tr>
<td style="text-align:left">long</td>
<td style="text-align:left">4 字节</td>
<td style="text-align:left">-2,147,483,648 到 2,147,483,647</td>
</tr>
<tr>
<td style="text-align:left">unsigned long</td>
<td style="text-align:left">4 字节</td>
<td style="text-align:left">0 到 4,294,967,295</td>
</tr>
</tbody>
</table>
<p>为了得到某个类型或某个变量在特定平台上的准确大小，可以使用 <strong>sizeof</strong> 运算符。表达式 <em>sizeof(type)</em> 得到对象或类型的存储字节大小。</p>
<h4 id="浮点类型"><a class="header-anchor" href="#浮点类型">¶</a>浮点类型</h4>
<p>下表列出了关于标准浮点类型的存储大小、值范围和精度的细节：</p>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">存储大小</th>
<th style="text-align:left">值范围</th>
<th style="text-align:left">精度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">float</td>
<td style="text-align:left">4 字节</td>
<td style="text-align:left">1.2E-38 到 3.4E+38</td>
<td style="text-align:left">6 位小数</td>
</tr>
<tr>
<td style="text-align:left">double</td>
<td style="text-align:left">8 字节</td>
<td style="text-align:left">2.3E-308 到 1.7E+308</td>
<td style="text-align:left">15 位小数</td>
</tr>
<tr>
<td style="text-align:left">long double</td>
<td style="text-align:left">16 字节</td>
<td style="text-align:left">3.4E-4932 到 1.1E+4932</td>
<td style="text-align:left">19 位小数</td>
</tr>
</tbody>
</table>
<p>头文件 float.h 定义了宏，在程序中可以使用这些值和其他有关实数二进制表示的细节。</p>
<h4 id="void-类型"><a class="header-anchor" href="#void-类型">¶</a>void 类型</h4>
<p>void 类型指定没有可用的值。它通常用于以下三种情况下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">类型与描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><strong>函数返回为空</strong> C 中有各种函数都不返回值，或者您可以说它们返回空。不返回值的函数的返回类型为空。例如 <strong>void exit (int status);</strong></td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><strong>函数参数为空</strong> C 中有各种函数不接受任何参数。不带参数的函数可以接受一个 void。例如 <strong>int rand(void);</strong></td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><strong>指针指向 void</strong> 类型为 void * 的指针代表对象的地址，而不是类型。例如，内存分配函数 <strong>void *malloc( size_t size );</strong> 返回指向 void 的指针，可以转换为任何数据类型。</td>
</tr>
</tbody>
</table>
<h1>C 变量</h1>
<p>变量其实只不过是程序可操作的存储区的名称。C 中每个变量都有特定的类型，类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上。</p>
<p>变量的名称可以由字母、数字和下划线字符组成。它必须以字母或下划线开头。大写字母和小写字母是不同的，因为 C 是大小写<font color='red'><strong>敏感</strong></font>的。</p>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">char</td>
<td style="text-align:left">通常是一个字节（八位）。这是一个整数类型。</td>
</tr>
<tr>
<td style="text-align:left">int</td>
<td style="text-align:left">对机器而言，整数的最自然的大小。</td>
</tr>
<tr>
<td style="text-align:left">float</td>
<td style="text-align:left">单精度浮点值。单精度是这样的格式，1位符号，8位指数，23位小数。<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/stardust14/picture/img/20200909111147.png" alt="img"></td>
</tr>
<tr>
<td style="text-align:left">double</td>
<td style="text-align:left">双精度浮点值。双精度是1位符号，11位指数，52位小数。<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/stardust14/picture/img/20200909111135.png" alt="img"></td>
</tr>
<tr>
<td style="text-align:left">void</td>
<td style="text-align:left">表示类型的缺失。</td>
</tr>
</tbody>
</table>
<p>C 语言也允许定义各种其他类型的变量，比如枚举、指针、数组、结构、共用体等等.</p>
<h2 id="C-中的变量定义"><a class="header-anchor" href="#C-中的变量定义">¶</a>C 中的变量定义</h2>
<p>变量定义就是告诉编译器在何处创建变量的存储，以及如何创建变量的存储。变量定义指定一个数据类型，并包含了该类型的一个或多个变量的列表，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">type variable_list;</span><br></pre></td></tr></table></figure>
<p>在这里，<strong>type</strong> 必须是一个有效的 C 数据类型，可以是 char、w_char、int、float、double 或任何用户自定义的对象，<strong>variable_list</strong> 可以由一个或多个标识符名称组成，多个标识符之间用逗号分隔。</p>
<p>变量可以在声明的时候被初始化（指定一个初始值）。初始化器由一个等号，后跟一个常量表达式组成。</p>
<p>不带初始化的定义：带有静态存储持续时间的变量会被隐式初始化为 <strong>NULL</strong>（所有字节的值都是 0），其他所有变量的初始值是未定义的。</p>
<h2 id="C-中的变量声明"><a class="header-anchor" href="#C-中的变量声明">¶</a>C 中的变量声明</h2>
<p>变量声明向编译器保证变量以指定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。</p>
<p>变量的声明有两种情况：</p>
<ul>
<li>1、一种是需要建立存储空间的。例如：int a 在声明的时候就已经建立了存储空间。</li>
<li>2、另一种是不需要建立存储空间的，通过使用extern关键字声明变量名而不定义它。 例如：extern int a 其中变量 a 可以在别的文件中定义的。</li>
<li>除非有extern关键字，否则都是变量的定义。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//变量在头部就已经被声明，但是定义与初始化在主函数内</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 函数外定义变量 x 和 y</span></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">int</span> y;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addtwonum</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 函数内声明变量 x 和 y 为外部变量</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">int</span> y;</span><br><span class="line">    <span class="comment">// 给外部变量（全局变量）x 和 y 赋值</span></span><br><span class="line">    x = <span class="number">1</span>;</span><br><span class="line">    y = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line">    <span class="comment">// 调用函数 addtwonum</span></span><br><span class="line">    result = addtwonum();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result 为: %d&quot;</span>,result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">result 为: <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>如果需要在一个源文件中引用另外一个源文件中定义的变量，我们只需在引用的文件中将变量加上 extern 关键字的声明即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">/*外部变量声明*/</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> x ;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> y ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addtwonum</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">  </span><br><span class="line"><span class="comment">/*定义两个全局变量*/</span></span><br><span class="line"><span class="keyword">int</span> x=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> y=<span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addtwonum</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line">    result = addtwonum();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result 为: %d\n&quot;</span>,result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="C-中的左值（Lvalues）和右值（Rvalues）"><a class="header-anchor" href="#C-中的左值（Lvalues）和右值（Rvalues）">¶</a>C 中的左值（Lvalues）和右值（Rvalues）</h2>
<p>C 中有两种类型的表达式：</p>
<ol>
<li><strong>左值（lvalue）：<strong>指向</strong>内存位置</strong>的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。</li>
<li><strong>右值（rvalue）：<strong>术语右值（rvalue）指的是存储在内存中某些地址的</strong>数值</strong>。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。</li>
</ol>
<p>变量是左值，因此可以出现在赋值号的左边。数值型的字面值是右值，因此不能被赋值，不能出现在赋值号的左边。</p>
<h1>C 常量</h1>
<p>常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做<strong>字面量</strong>。</p>
<p>常量可以是任何的基本数据类型，比如整数常量、浮点常量、字符常量，或字符串字面值，也有枚举常量。</p>
<p><strong>常量</strong>就像是常规的变量，只不过常量的值在定义后不能进行修改。</p>
<h2 id="整数常量"><a class="header-anchor" href="#整数常量">¶</a>整数常量</h2>
<p>整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制。</p>
<p>整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意。</p>
<h2 id="浮点常量"><a class="header-anchor" href="#浮点常量">¶</a>浮点常量</h2>
<p>浮点常量由整数部分、小数点、小数部分和指数部分组成。您可以使用小数形式或者指数形式来表示浮点常量。</p>
<p>当使用小数形式表示时，必须包含整数部分、小数部分，或同时包含两者。当使用指数形式表示时， 必须包含小数点、指数，或同时包含两者。带符号的指数是用 e 或 E 引入的。</p>
<h2 id="字符常量"><a class="header-anchor" href="#字符常量">¶</a>字符常量</h2>
<p>字符常量是括在单引号中，例如，‘x’ 可以存储在 <strong>char</strong> 类型的简单变量中。</p>
<p>字符常量可以是一个普通的字符（例如 ‘x’）、一个转义序列（例如 ‘\t’），或一个通用的字符（例如 ‘\u02C0’）。</p>
<p>在 C 中，有一些特定的字符，当它们前面有反斜杠时，它们就具有特殊的含义，被用来表示如换行符（\n）或制表符（\t）等。</p>
<p>下表列出了一些这样的转义序列码：</p>
<table>
<thead>
<tr>
<th style="text-align:left">转义序列</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">\</td>
<td style="text-align:left">\ 字符</td>
</tr>
<tr>
<td style="text-align:left">’</td>
<td style="text-align:left">’ 字符</td>
</tr>
<tr>
<td style="text-align:left">&quot;</td>
<td style="text-align:left">&quot; 字符</td>
</tr>
<tr>
<td style="text-align:left">?</td>
<td style="text-align:left">? 字符</td>
</tr>
<tr>
<td style="text-align:left">\a</td>
<td style="text-align:left">警报铃声</td>
</tr>
<tr>
<td style="text-align:left">\b</td>
<td style="text-align:left">退格键</td>
</tr>
<tr>
<td style="text-align:left">\f</td>
<td style="text-align:left">换页符</td>
</tr>
<tr>
<td style="text-align:left">\n</td>
<td style="text-align:left">换行符</td>
</tr>
<tr>
<td style="text-align:left">\r</td>
<td style="text-align:left">回车</td>
</tr>
<tr>
<td style="text-align:left">\t</td>
<td style="text-align:left">水平制表符</td>
</tr>
<tr>
<td style="text-align:left">\v</td>
<td style="text-align:left">垂直制表符</td>
</tr>
<tr>
<td style="text-align:left">\ooo</td>
<td style="text-align:left">一到三位的八进制数</td>
</tr>
<tr>
<td style="text-align:left">\xhh . . .</td>
<td style="text-align:left">一个或多个数字的十六进制数</td>
</tr>
</tbody>
</table>
<h2 id="字符串常量"><a class="header-anchor" href="#字符串常量">¶</a>字符串常量</h2>
<p>字符串字面值或常量是括在双引号 “” 中的。一个字符串包含类似于字符常量的字符：普通的字符、转义序列和通用的字符。</p>
<p>可以使用空格做分隔符，把一个很长的字符串常量进行分行。</p>
<h2 id="定义常量"><a class="header-anchor" href="#定义常量">¶</a>定义常量</h2>
<p>在 C 中，有两种简单的定义常量的方式：</p>
<ol>
<li>使用 <strong>#define</strong> 预处理器。</li>
<li>使用 <strong>const</strong> 关键字。</li>
</ol>
<h3 id="define-预处理器"><a class="header-anchor" href="#define-预处理器">¶</a>#define 预处理器</h3>
<p>下面是使用 #define 预处理器定义常量的形式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> identifier value</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LENGTH 10   </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WIDTH  5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NEWLINE <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">int</span> area;  </span><br><span class="line">  </span><br><span class="line">   area = LENGTH * WIDTH;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;value of area : %d&quot;</span>, area);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, NEWLINE);</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>%c是char类型，输出单个字符</p>
</blockquote>
<h3 id="const-关键字"><a class="header-anchor" href="#const-关键字">¶</a>const 关键字</h3>
<p>可以使用 <strong>const</strong> 前缀声明指定类型的常量，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> type variable = value;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">int</span>  LENGTH = <span class="number">10</span>;</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">int</span>  WIDTH  = <span class="number">5</span>;</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">char</span> NEWLINE = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">   <span class="keyword">int</span> area;  </span><br><span class="line">   </span><br><span class="line">   area = LENGTH * WIDTH;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;value of area : %d&quot;</span>, area);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, NEWLINE);</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>C 存储类</h1>
<p>存储类定义 C 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C 程序中可用的存储类：</p>
<ul>
<li>auto</li>
<li>register</li>
<li>static</li>
<li>extern</li>
</ul>
<h2 id="auto-存储类"><a class="header-anchor" href="#auto-存储类">¶</a>auto 存储类</h2>
<p><strong>auto</strong> 存储类是所有局部变量<strong>默认</strong>的存储类。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="keyword">int</span> mount;</span><br><span class="line">   <span class="keyword">auto</span> <span class="keyword">int</span> month;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的实例定义了两个带有<strong>相同</strong>存储类的变量，auto <strong>只能</strong>用在<font color='red'><strong>函数内</strong></font>，即 auto 只能<strong>修饰</strong><font color='red'>局部变量</font>。</p>
<h2 id="register-存储类"><a class="header-anchor" href="#register-存储类">¶</a>register 存储类</h2>
<p><strong>register</strong> 存储类用于定义存储在<strong>寄存器</strong>中而<strong>不是 RAM</strong> 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 ‘&amp;’ 运算符（因为它没有内存位置）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="keyword">register</span> <span class="keyword">int</span>  miles;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义 ‘register’ 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。</p>
<h2 id="static-存储类"><a class="header-anchor" href="#static-存储类">¶</a>static 存储类</h2>
<p><strong>static</strong> 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰<strong>局部变量</strong>可以在函数调用之间保持局部变量的值。<br>
static 修饰符也可以应用于<strong>全局变量</strong>。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。<br>
全局声明的一个 static 变量或方法可以被任何函数或方法调用，只要这些方法出现在跟 static 变量或方法同一个文件中。</p>
<p>以下实例演示了 static 修饰全局变量和局部变量的应用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 函数声明 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> count=<span class="number">10</span>;        <span class="comment">/* 全局变量 - static 是默认的 */</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (count--) &#123;</span><br><span class="line">      func1();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* &#x27;thingy&#x27; 是 &#x27;func1&#x27; 的局部变量 - 只初始化一次</span></span><br><span class="line"><span class="comment"> * 每次调用函数 &#x27;func1&#x27; &#x27;thingy&#x27; 值不会被重置。</span></span><br><span class="line"><span class="comment"> */</span>                </span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> thingy=<span class="number">5</span>;</span><br><span class="line">  thingy++;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot; thingy 为 %d ， count 为 %d\n&quot;</span>, thingy, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实例中 count 作为全局变量可以在函数内使用，thingy 使用 static 修饰后，不会在每次调用时重置。</p>
<h2 id="extern-存储类"><a class="header-anchor" href="#extern-存储类">¶</a>extern 存储类</h2>
<p><strong>extern</strong> 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 <strong>extern</strong> 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。</p>
<p>当有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 <em>extern</em> 来得到已定义的变量或函数的引用。可以这么理解，<em>extern</em> 是用来在另一个文件中声明一个全局变量或函数。</p>
<p>extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候，如下所示：</p>
<p><strong>第一个文件：main.c</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> count ;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">write_extern</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   count = <span class="number">5</span>;</span><br><span class="line">   write_extern();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>第二个文件：support.c</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> count;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_extern</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;count is %d\n&quot;</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，第二个文件中的 <em>extern</em> 关键字用于声明已经在第一个文件 main.c 中定义的 <em>count</em>。</p>
<p>执行结果</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">count is <span class="number">5</span></span><br></pre></td></tr></table></figure>
<h1>C 运算符</h1>
<p>运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。C 语言内置了丰富的运算符，并提供了以下类型的运算符：</p>
<ul>
<li>算术运算符</li>
<li>关系运算符</li>
<li>逻辑运算符</li>
<li>位运算符</li>
<li>赋值运算符</li>
<li>杂项运算符</li>
</ul>
<h2 id="算术运算符"><a class="header-anchor" href="#算术运算符">¶</a>算术运算符</h2>
<p>下表显示了 C 语言支持的所有算术运算符。假设变量 <strong>A</strong> 的值为 10，变量 <strong>B</strong> 的值为 20，则：</p>
<table>
<thead>
<tr>
<th style="text-align:left">运算符</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">+</td>
<td style="text-align:left">把两个操作数相加</td>
<td style="text-align:left">A + B 将得到 30</td>
</tr>
<tr>
<td style="text-align:left">-</td>
<td style="text-align:left">从第一个操作数中减去第二个操作数</td>
<td style="text-align:left">A - B 将得到 -10</td>
</tr>
<tr>
<td style="text-align:left">*</td>
<td style="text-align:left">把两个操作数相乘</td>
<td style="text-align:left">A * B 将得到 200</td>
</tr>
<tr>
<td style="text-align:left">/</td>
<td style="text-align:left">分子除以分母</td>
<td style="text-align:left">B / A 将得到 2</td>
</tr>
<tr>
<td style="text-align:left">%</td>
<td style="text-align:left">取模运算符，整除后的余数</td>
<td style="text-align:left">B % A 将得到 0</td>
</tr>
<tr>
<td style="text-align:left">++</td>
<td style="text-align:left">自增运算符，整数值增加 1</td>
<td style="text-align:left">A++ 将得到 11</td>
</tr>
<tr>
<td style="text-align:left">–</td>
<td style="text-align:left">自减运算符，整数值减少 1</td>
<td style="text-align:left">A-- 将得到 9</td>
</tr>
</tbody>
</table>
<h3 id="实例"><a class="header-anchor" href="#实例">¶</a>实例</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> a = <span class="number">21</span>;</span><br><span class="line">   <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">   <span class="keyword">int</span> c ;</span><br><span class="line"> </span><br><span class="line">   c = a + b;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line 1 - c 的值是 %d\n&quot;</span>, c );</span><br><span class="line">   c = a - b;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line 2 - c 的值是 %d\n&quot;</span>, c );</span><br><span class="line">   c = a * b;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line 3 - c 的值是 %d\n&quot;</span>, c );</span><br><span class="line">   c = a / b;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line 4 - c 的值是 %d\n&quot;</span>, c );</span><br><span class="line">   c = a % b;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line 5 - c 的值是 %d\n&quot;</span>, c );</span><br><span class="line">   c = a++;  <span class="comment">// 赋值后再加 1 ，c 为 21，a 为 22</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line 6 - c 的值是 %d\n&quot;</span>, c );</span><br><span class="line">   c = a--;  <span class="comment">// 赋值后再减 1 ，c 为 22 ，a 为 21</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line 7 - c 的值是 %d\n&quot;</span>, c );</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Line 1 - c 的值是 31</span><br><span class="line">Line 2 - c 的值是 11</span><br><span class="line">Line 3 - c 的值是 210</span><br><span class="line">Line 4 - c 的值是 2</span><br><span class="line">Line 5 - c 的值是 1</span><br><span class="line">Line 6 - c 的值是 21</span><br><span class="line">Line 7 - c 的值是 22</span><br></pre></td></tr></table></figure>
<p>以下实例演示了 a++ 与 ++a 的区别：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> c;</span><br><span class="line">   <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">   c = a++; </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;先赋值后运算：\n&quot;</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line 1 - c 的值是 %d\n&quot;</span>, c );</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line 2 - a 的值是 %d\n&quot;</span>, a );</span><br><span class="line">   a = <span class="number">10</span>;</span><br><span class="line">   c = a--; </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line 3 - c 的值是 %d\n&quot;</span>, c );</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line 4 - a 的值是 %d\n&quot;</span>, a );</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;先运算后赋值：\n&quot;</span>);</span><br><span class="line">   a = <span class="number">10</span>;</span><br><span class="line">   c = ++a; </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line 5 - c 的值是 %d\n&quot;</span>, c );</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line 6 - a 的值是 %d\n&quot;</span>, a );</span><br><span class="line">   a = <span class="number">10</span>;</span><br><span class="line">   c = --a; </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line 7 - c 的值是 %d\n&quot;</span>, c );</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line 8 - a 的值是 %d\n&quot;</span>, a );</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上程序执行输出结果为：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">先赋值后运算：</span><br><span class="line">Line 1 - c 的值是 10</span><br><span class="line">Line 2 - a 的值是 11</span><br><span class="line">Line 3 - c 的值是 10</span><br><span class="line">Line 4 - a 的值是 9</span><br><span class="line">先运算后赋值：</span><br><span class="line">Line 5 - c 的值是 11</span><br><span class="line">Line 6 - a 的值是 11</span><br><span class="line">Line 7 - c 的值是 9</span><br><span class="line">Line 8 - a 的值是 9</span><br></pre></td></tr></table></figure>
<h2 id="关系运算符"><a class="header-anchor" href="#关系运算符">¶</a>关系运算符</h2>
<p>下表显示了 C 语言支持的所有关系运算符。假设变量 <strong>A</strong> 的值为 10，变量 <strong>B</strong> 的值为 20，则：</p>
<table>
<thead>
<tr>
<th style="text-align:left">运算符</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">==</td>
<td style="text-align:left">检查两个操作数的值是否相等，如果相等则条件为真。</td>
<td style="text-align:left">(A == B) 为假。</td>
</tr>
<tr>
<td style="text-align:left">!=</td>
<td style="text-align:left">检查两个操作数的值是否相等，如果不相等则条件为真。</td>
<td style="text-align:left">(A != B) 为真。</td>
</tr>
<tr>
<td style="text-align:left">&gt;</td>
<td style="text-align:left">检查左操作数的值是否大于右操作数的值，如果是则条件为真。</td>
<td style="text-align:left">(A &gt; B) 为假。</td>
</tr>
<tr>
<td style="text-align:left">&lt;</td>
<td style="text-align:left">检查左操作数的值是否小于右操作数的值，如果是则条件为真。</td>
<td style="text-align:left">(A &lt; B) 为真。</td>
</tr>
<tr>
<td style="text-align:left">&gt;=</td>
<td style="text-align:left">检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。</td>
<td style="text-align:left">(A &gt;= B) 为假。</td>
</tr>
<tr>
<td style="text-align:left">&lt;=</td>
<td style="text-align:left">检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。</td>
<td style="text-align:left">(A &lt;= B) 为真。</td>
</tr>
</tbody>
</table>
<h3 id="实例-v2"><a class="header-anchor" href="#实例-v2">¶</a>实例</h3>
<p>看下面的实例，了解 C 语言中所有可用的关系运算符：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> a = <span class="number">21</span>;</span><br><span class="line">   <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">   <span class="keyword">int</span> c ;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">if</span>( a == b )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Line 1 - a 等于 b\n&quot;</span> );</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Line 1 - a 不等于 b\n&quot;</span> );</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> ( a &lt; b )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Line 2 - a 小于 b\n&quot;</span> );</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Line 2 - a 不小于 b\n&quot;</span> );</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> ( a &gt; b )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Line 3 - a 大于 b\n&quot;</span> );</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Line 3 - a 不大于 b\n&quot;</span> );</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/* 改变 a 和 b 的值 */</span></span><br><span class="line">   a = <span class="number">5</span>;</span><br><span class="line">   b = <span class="number">20</span>;</span><br><span class="line">   <span class="keyword">if</span> ( a &lt;= b )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Line 4 - a 小于或等于 b\n&quot;</span> );</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> ( b &gt;= a )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Line 5 - b 大于或等于 a\n&quot;</span> );</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Line 1 - a 不等于 b</span><br><span class="line">Line 2 - a 不小于 b</span><br><span class="line">Line 3 - a 大于 b</span><br><span class="line">Line 4 - a 小于或等于 b</span><br><span class="line">Line 5 - b 大于或等于 a</span><br></pre></td></tr></table></figure>
<h2 id="逻辑运算符"><a class="header-anchor" href="#逻辑运算符">¶</a>逻辑运算符</h2>
<p>下表显示了 C 语言支持的所有关系逻辑运算符。假设变量 <strong>A</strong> 的值为 1，变量 <strong>B</strong> 的值为 0，则：</p>
<table>
<thead>
<tr>
<th style="text-align:left">运算符</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">&amp;&amp;</td>
<td style="text-align:left">称为逻辑与运算符。如果两个操作数都非零，则条件为真。</td>
<td style="text-align:left">(A &amp;&amp; B) 为假。</td>
</tr>
<tr>
<td style="text-align:left">||</td>
<td style="text-align:left">称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。</td>
<td style="text-align:left">(A || B) 为真。</td>
</tr>
<tr>
<td style="text-align:left">!</td>
<td style="text-align:left">称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。</td>
<td style="text-align:left">!(A &amp;&amp; B) 为真。</td>
</tr>
</tbody>
</table>
<h3 id="实例-v3"><a class="header-anchor" href="#实例-v3">¶</a>实例</h3>
<p>看下面的实例，了解 C 语言中所有可用的关系运算符：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">   <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">   <span class="keyword">int</span> c ;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">if</span> ( a &amp;&amp; b )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Line 1 - 条件为真\n&quot;</span> );</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> ( a || b )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Line 2 - 条件为真\n&quot;</span> );</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/* 改变 a 和 b 的值 */</span></span><br><span class="line">   a = <span class="number">0</span>;</span><br><span class="line">   b = <span class="number">10</span>;</span><br><span class="line">   <span class="keyword">if</span> ( a &amp;&amp; b )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Line 3 - 条件为真\n&quot;</span> );</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Line 3 - 条件为假\n&quot;</span> );</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> ( !(a &amp;&amp; b) )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Line 4 - 条件为真\n&quot;</span> );</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Line 1 - 条件为真</span><br><span class="line">Line 2 - 条件为真</span><br><span class="line">Line 3 - 条件为假</span><br><span class="line">Line 4 - 条件为真</span><br></pre></td></tr></table></figure>
<h2 id="位运算符"><a class="header-anchor" href="#位运算符">¶</a>位运算符</h2>
<p>位运算符作用于位，并逐位执行操作。&amp;、 | 和 ^ 的真值表如下所示：</p>
<table>
<thead>
<tr>
<th style="text-align:left">p</th>
<th style="text-align:left">q</th>
<th style="text-align:left">p &amp; q</th>
<th style="text-align:left">p | q</th>
<th style="text-align:left">p ^ q</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">1</td>
<td style="text-align:left">0</td>
<td style="text-align:left">1</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">1</td>
<td style="text-align:left">1</td>
<td style="text-align:left">1</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
<td style="text-align:left">1</td>
<td style="text-align:left">1</td>
</tr>
</tbody>
</table>
<blockquote>
<p>“^”:<strong>按位异或</strong></p>
</blockquote>
<p>下表显示了 C 语言支持的位运算符。假设变量 <strong>A</strong> 的值为 60，变量 <strong>B</strong> 的值为 13，则：</p>
<table>
<thead>
<tr>
<th style="text-align:left">运算符</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">&amp;</td>
<td style="text-align:left">按位与操作，按二进制位进行&quot;与&quot;运算。运算规则：<code>0&amp;0=0;    0&amp;1=0;     1&amp;0=0;      1&amp;1=1;</code></td>
<td style="text-align:left">(A &amp; B) 将得到 12，即为 0000 1100</td>
</tr>
<tr>
<td style="text-align:left">|</td>
<td style="text-align:left">按位或运算符，按二进制位进行&quot;或&quot;运算。运算规则：<code>0|0=0;    0|1=1;    1|0=1;     1|1=1;</code></td>
<td style="text-align:left">(A | B) 将得到 61，即为 0011 1101</td>
</tr>
<tr>
<td style="text-align:left">^</td>
<td style="text-align:left">异或运算符，按二进制位进行&quot;异或&quot;运算。运算规则：<code>0^0=0;    0^1=1;    1^0=1;   1^1=0;</code></td>
<td style="text-align:left">(A ^ B) 将得到 49，即为 0011 0001</td>
</tr>
<tr>
<td style="text-align:left">~</td>
<td style="text-align:left">取反运算符，按二进制位进行&quot;取反&quot;运算。运算规则：<code>~1=0;    ~0=1;</code></td>
<td style="text-align:left">(~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。</td>
</tr>
<tr>
<td style="text-align:left">&lt;&lt;</td>
<td style="text-align:left">二进制左移运算符。将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。</td>
<td style="text-align:left">A &lt;&lt; 2 将得到 240，即为 1111 0000</td>
</tr>
<tr>
<td style="text-align:left">&gt;&gt;</td>
<td style="text-align:left">二进制右移运算符。将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。</td>
<td style="text-align:left">A &gt;&gt; 2 将得到 15，即为 0000 1111</td>
</tr>
</tbody>
</table>
<h3 id="实例-v4"><a class="header-anchor" href="#实例-v4">¶</a>实例</h3>
<p>看下面的实例，了解 C 语言中所有可用的位运算符：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">int</span> a = <span class="number">60</span>;    <span class="comment">/* 60 = 0011 1100 */</span>  </span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">int</span> b = <span class="number">13</span>;    <span class="comment">/* 13 = 0000 1101 */</span></span><br><span class="line">   <span class="keyword">int</span> c = <span class="number">0</span>;           </span><br><span class="line"> </span><br><span class="line">   c = a &amp; b;       <span class="comment">/* 12 = 0000 1100 */</span> </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line 1 - c 的值是 %d\n&quot;</span>, c );</span><br><span class="line"> </span><br><span class="line">   c = a | b;       <span class="comment">/* 61 = 0011 1101 */</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line 2 - c 的值是 %d\n&quot;</span>, c );</span><br><span class="line"> </span><br><span class="line">   c = a ^ b;       <span class="comment">/* 49 = 0011 0001 */</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line 3 - c 的值是 %d\n&quot;</span>, c );</span><br><span class="line"> </span><br><span class="line">   c = ~a;          <span class="comment">/*-61 = 1100 0011 */</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line 4 - c 的值是 %d\n&quot;</span>, c );</span><br><span class="line"> </span><br><span class="line">   c = a &lt;&lt; <span class="number">2</span>;     <span class="comment">/* 240 = 1111 0000 */</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line 5 - c 的值是 %d\n&quot;</span>, c );</span><br><span class="line"> </span><br><span class="line">   c = a &gt;&gt; <span class="number">2</span>;     <span class="comment">/* 15 = 0000 1111 */</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line 6 - c 的值是 %d\n&quot;</span>, c );</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Line 1 - c 的值是 12</span><br><span class="line">Line 2 - c 的值是 61</span><br><span class="line">Line 3 - c 的值是 49</span><br><span class="line">Line 4 - c 的值是 -61</span><br><span class="line">Line 5 - c 的值是 240</span><br><span class="line">Line 6 - c 的值是 15</span><br></pre></td></tr></table></figure>
<h2 id="赋值运算符"><a class="header-anchor" href="#赋值运算符">¶</a>赋值运算符</h2>
<p>下表列出了 C 语言支持的赋值运算符：</p>
<table>
<thead>
<tr>
<th style="text-align:left">运算符</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">=</td>
<td style="text-align:left">简单的赋值运算符，把右边操作数的值赋给左边操作数</td>
<td style="text-align:left">C = A + B 将把 A + B 的值赋给 C</td>
</tr>
<tr>
<td style="text-align:left">+=</td>
<td style="text-align:left">加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数</td>
<td style="text-align:left">C += A 相当于 C = C + A</td>
</tr>
<tr>
<td style="text-align:left">-=</td>
<td style="text-align:left">减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数</td>
<td style="text-align:left">C -= A 相当于 C = C - A</td>
</tr>
<tr>
<td style="text-align:left">*=</td>
<td style="text-align:left">乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数</td>
<td style="text-align:left">C *= A 相当于 C = C * A</td>
</tr>
<tr>
<td style="text-align:left">/=</td>
<td style="text-align:left">除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数</td>
<td style="text-align:left">C /= A 相当于 C = C / A</td>
</tr>
<tr>
<td style="text-align:left">%=</td>
<td style="text-align:left">求模且赋值运算符，求两个操作数的模赋值给左边操作数</td>
<td style="text-align:left">C %= A 相当于 C = C % A</td>
</tr>
<tr>
<td style="text-align:left">&lt;&lt;=</td>
<td style="text-align:left">左移且赋值运算符</td>
<td style="text-align:left">C &lt;&lt;= 2 等同于 C = C &lt;&lt; 2</td>
</tr>
<tr>
<td style="text-align:left">&gt;&gt;=</td>
<td style="text-align:left">右移且赋值运算符</td>
<td style="text-align:left">C &gt;&gt;= 2 等同于 C = C &gt;&gt; 2</td>
</tr>
<tr>
<td style="text-align:left">&amp;=</td>
<td style="text-align:left">按位与且赋值运算符</td>
<td style="text-align:left">C &amp;= 2 等同于 C = C &amp; 2</td>
</tr>
<tr>
<td style="text-align:left">^=</td>
<td style="text-align:left">按位异或且赋值运算符</td>
<td style="text-align:left">C ^= 2 等同于 C = C ^ 2</td>
</tr>
<tr>
<td style="text-align:left">|=</td>
<td style="text-align:left">按位或且赋值运算符</td>
<td style="text-align:left">C |= 2 等同于 C = C | 2</td>
</tr>
</tbody>
</table>
<blockquote>
<p>&quot;&gt;&gt;(右移)&quot;按二进制形式把所有的数字向右移动对应位移位数，低位移出(舍弃)，高位的空位补符号位，即正数补零，负数补1。</p>
</blockquote>
<h3 id="实例-v5"><a class="header-anchor" href="#实例-v5">¶</a>实例</h3>
<p>请看下面的实例，了解 C 语言中所有可用的赋值运算符：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> a = <span class="number">21</span>;</span><br><span class="line">   <span class="keyword">int</span> c ;</span><br><span class="line"> </span><br><span class="line">   c =  a;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line 1 - =  运算符实例，c 的值 = %d\n&quot;</span>, c );</span><br><span class="line"> </span><br><span class="line">   c +=  a;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line 2 - += 运算符实例，c 的值 = %d\n&quot;</span>, c );</span><br><span class="line"> </span><br><span class="line">   c -=  a;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line 3 - -= 运算符实例，c 的值 = %d\n&quot;</span>, c );</span><br><span class="line"> </span><br><span class="line">   c *=  a;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line 4 - *= 运算符实例，c 的值 = %d\n&quot;</span>, c );</span><br><span class="line"> </span><br><span class="line">   c /=  a;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line 5 - /= 运算符实例，c 的值 = %d\n&quot;</span>, c );</span><br><span class="line"> </span><br><span class="line">   c  = <span class="number">200</span>;</span><br><span class="line">   c %=  a;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line 6 - %%= 运算符实例，c 的值 = %d\n&quot;</span>, c );</span><br><span class="line"> </span><br><span class="line">   c &lt;&lt;=  <span class="number">2</span>;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line 7 - &lt;&lt;= 运算符实例，c 的值 = %d\n&quot;</span>, c );</span><br><span class="line"> </span><br><span class="line">   c &gt;&gt;=  <span class="number">2</span>;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line 8 - &gt;&gt;= 运算符实例，c 的值 = %d\n&quot;</span>, c );</span><br><span class="line"> </span><br><span class="line">   c &amp;=  <span class="number">2</span>;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line 9 - &amp;= 运算符实例，c 的值 = %d\n&quot;</span>, c );</span><br><span class="line"> </span><br><span class="line">   c ^=  <span class="number">2</span>;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line 10 - ^= 运算符实例，c 的值 = %d\n&quot;</span>, c );</span><br><span class="line"> </span><br><span class="line">   c |=  <span class="number">2</span>;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line 11 - |= 运算符实例，c 的值 = %d\n&quot;</span>, c );</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Line 1 - =  运算符实例，c 的值 = 21</span><br><span class="line">Line 2 - += 运算符实例，c 的值 = 42</span><br><span class="line">Line 3 - -= 运算符实例，c 的值 = 21</span><br><span class="line">Line 4 - <span class="emphasis">*= 运算符实例，c 的值 = 441</span></span><br><span class="line"><span class="emphasis">Line 5 - /= 运算符实例，c 的值 = 21</span></span><br><span class="line"><span class="emphasis">Line 6 - %= 运算符实例，c 的值 = 11</span></span><br><span class="line"><span class="emphasis">Line 7 - <span class="xml"><span class="tag">&lt;&lt;= <span class="string">运算符实例，c</span> 的值 = <span class="string">44</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="xml">Line 8 - &gt;</span>&gt;= 运算符实例，c 的值 = 11</span></span><br><span class="line"><span class="emphasis">Line 9 - &amp;= 运算符实例，c 的值 = 2</span></span><br><span class="line"><span class="emphasis">Line 10 - ^= 运算符实例，c 的值 = 0</span></span><br><span class="line"><span class="emphasis">Line 11 - |= 运算符实例，c 的值 = 2</span></span><br></pre></td></tr></table></figure>
<h2 id="杂项运算符-↦-sizeof-三元"><a class="header-anchor" href="#杂项运算符-↦-sizeof-三元">¶</a>杂项运算符 ↦ sizeof &amp; 三元</h2>
<p>下表列出了 C 语言支持的其他一些重要的运算符，包括 <strong>sizeof</strong> 和 <strong>? :</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">运算符</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">sizeof()</td>
<td style="text-align:left">返回变量的大小。</td>
<td style="text-align:left">sizeof(a) 将返回 4，其中 a 是整数。</td>
</tr>
<tr>
<td style="text-align:left">&amp;</td>
<td style="text-align:left">返回变量的地址。</td>
<td style="text-align:left">&amp;a; 将给出变量的实际地址。</td>
</tr>
<tr>
<td style="text-align:left">*</td>
<td style="text-align:left">指向一个变量。</td>
<td style="text-align:left">*a; 将指向一个变量。</td>
</tr>
<tr>
<td style="text-align:left">? :</td>
<td style="text-align:left">条件表达式</td>
<td style="text-align:left">如果条件为真 ? 则值为 X : 否则值为 Y</td>
</tr>
</tbody>
</table>
<h3 id="实例-v6"><a class="header-anchor" href="#实例-v6">¶</a>实例</h3>
<p>请看下面的实例，了解 C 语言中所有可用的杂项运算符：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> a = <span class="number">4</span>;</span><br><span class="line">   <span class="keyword">short</span> b;</span><br><span class="line">   <span class="keyword">double</span> c;</span><br><span class="line">   <span class="keyword">int</span>* ptr;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* sizeof 运算符实例 */</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line 1 - 变量 a 的大小 = %lu\n&quot;</span>, <span class="keyword">sizeof</span>(a) );</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line 2 - 变量 b 的大小 = %lu\n&quot;</span>, <span class="keyword">sizeof</span>(b) );</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line 3 - 变量 c 的大小 = %lu\n&quot;</span>, <span class="keyword">sizeof</span>(c) );</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* &amp; 和 * 运算符实例 */</span></span><br><span class="line">   ptr = &amp;a;    <span class="comment">/* &#x27;ptr&#x27; 现在包含 &#x27;a&#x27; 的地址 */</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;a 的值是 %d\n&quot;</span>, a);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;*ptr 是 %d\n&quot;</span>, *ptr);</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 三元运算符实例 */</span></span><br><span class="line">   a = <span class="number">10</span>;</span><br><span class="line">   b = (a == <span class="number">1</span>) ? <span class="number">20</span>: <span class="number">30</span>;</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;b 的值是 %d\n&quot;</span>, b );</span><br><span class="line"> </span><br><span class="line">   b = (a == <span class="number">10</span>) ? <span class="number">20</span>: <span class="number">30</span>;</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;b 的值是 %d\n&quot;</span>, b );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Line 1 - 变量 a 的大小 = 4</span><br><span class="line">Line 2 - 变量 b 的大小 = 2</span><br><span class="line">Line 3 - 变量 c 的大小 = 8</span><br><span class="line">a 的值是 4</span><br><span class="line"><span class="emphasis">*ptr 是 4</span></span><br><span class="line"><span class="emphasis">b 的值是 30</span></span><br><span class="line"><span class="emphasis">b 的值是 20</span></span><br></pre></td></tr></table></figure>
<h2 id="C-中的运算符优先级"><a class="header-anchor" href="#C-中的运算符优先级">¶</a>C 中的运算符优先级</h2>
<p>下表将按运算符优先级从高到低列出各个运算符，具有较高优先级的运算符出现在表格的上面，具有较低优先级的运算符出现在表格的下面。</p>
<table>
<thead>
<tr>
<th style="text-align:left">类别</th>
<th style="text-align:left">运算符</th>
<th style="text-align:left">结合性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">后缀</td>
<td style="text-align:left">() [] -&gt; . ++ - -</td>
<td style="text-align:left">从左到右</td>
</tr>
<tr>
<td style="text-align:left">一元</td>
<td style="text-align:left">+ - ! ~ ++ - - (type)* &amp; sizeof</td>
<td style="text-align:left">从右到左</td>
</tr>
<tr>
<td style="text-align:left">乘除</td>
<td style="text-align:left">* / %</td>
<td style="text-align:left">从左到右</td>
</tr>
<tr>
<td style="text-align:left">加减</td>
<td style="text-align:left">+ -</td>
<td style="text-align:left">从左到右</td>
</tr>
<tr>
<td style="text-align:left">移位</td>
<td style="text-align:left">&lt;&lt; &gt;&gt;</td>
<td style="text-align:left">从左到右</td>
</tr>
<tr>
<td style="text-align:left">关系</td>
<td style="text-align:left">&lt; &lt;= &gt; &gt;=</td>
<td style="text-align:left">从左到右</td>
</tr>
<tr>
<td style="text-align:left">相等</td>
<td style="text-align:left">== !=</td>
<td style="text-align:left">从左到右</td>
</tr>
<tr>
<td style="text-align:left">位与 AND</td>
<td style="text-align:left">&amp;</td>
<td style="text-align:left">从左到右</td>
</tr>
<tr>
<td style="text-align:left">位异或 XOR</td>
<td style="text-align:left">^</td>
<td style="text-align:left">从左到右</td>
</tr>
<tr>
<td style="text-align:left">位或 OR</td>
<td style="text-align:left">|</td>
<td style="text-align:left">从左到右</td>
</tr>
<tr>
<td style="text-align:left">逻辑与 AND</td>
<td style="text-align:left">&amp;&amp;</td>
<td style="text-align:left">从左到右</td>
</tr>
<tr>
<td style="text-align:left">逻辑或 OR</td>
<td style="text-align:left">||</td>
<td style="text-align:left">从左到右</td>
</tr>
<tr>
<td style="text-align:left">条件</td>
<td style="text-align:left">?:</td>
<td style="text-align:left">从右到左</td>
</tr>
<tr>
<td style="text-align:left">赋值</td>
<td style="text-align:left">= += -= *= /= %=&gt;&gt;= &lt;&lt;= &amp;= ^= |=</td>
<td style="text-align:left">从右到左</td>
</tr>
<tr>
<td style="text-align:left">逗号</td>
<td style="text-align:left">,</td>
<td style="text-align:left">从左到右</td>
</tr>
</tbody>
</table>
<h3 id="实例-v7"><a class="header-anchor" href="#实例-v7">¶</a>实例</h3>
<p>请看下面的实例，了解 C 语言中运算符的优先级：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">int</span> a = <span class="number">20</span>;</span><br><span class="line">   <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">   <span class="keyword">int</span> c = <span class="number">15</span>;</span><br><span class="line">   <span class="keyword">int</span> d = <span class="number">5</span>;</span><br><span class="line">   <span class="keyword">int</span> e;</span><br><span class="line"> </span><br><span class="line">   e = (a + b) * c / d;      <span class="comment">// ( 30 * 15 ) / 5</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;(a + b) * c / d 的值是 %d\n&quot;</span>,  e );</span><br><span class="line"> </span><br><span class="line">   e = ((a + b) * c) / d;    <span class="comment">// (30 * 15 ) / 5</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;((a + b) * c) / d 的值是 %d\n&quot;</span> ,  e );</span><br><span class="line"> </span><br><span class="line">   e = (a + b) * (c / d);   <span class="comment">// (30) * (15/5)</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;(a + b) * (c / d) 的值是 %d\n&quot;</span>,  e );</span><br><span class="line"> </span><br><span class="line">   e = a + (b * c) / d;     <span class="comment">//  20 + (150/5)</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;a + (b * c) / d 的值是 %d\n&quot;</span> ,  e );</span><br><span class="line">  </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">(a + b) <span class="emphasis">* c / d 的值是 90</span></span><br><span class="line"><span class="emphasis">((a + b) *</span> c) / d 的值是 90</span><br><span class="line">(a + b) <span class="emphasis">* (c / d) 的值是 90</span></span><br><span class="line"><span class="emphasis">a + (b *</span> c) / d 的值是 50</span><br></pre></td></tr></table></figure>
<h1>C 判断</h1>
<p>判断结构要求程序员指定一个或多个要评估或测试的条件，以及条件为真时要执行的语句（必需的）和条件为假时要执行的语句（可选的）。</p>
<p>C 语言把任何<strong>非零</strong>和<strong>非空</strong>的值假定为 <strong>true</strong>，把<strong>零</strong>或 <strong>null</strong> 假定为 <strong>false</strong>。</p>
<h2 id="判断语句"><a class="header-anchor" href="#判断语句">¶</a>判断语句</h2>
<table>
<thead>
<tr>
<th style="text-align:left">语句</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">if 语句</td>
<td style="text-align:left">一个 <strong>if 语句</strong> 由一个布尔表达式后跟一个或多个语句组成。</td>
</tr>
<tr>
<td style="text-align:left">if…else语句</td>
<td style="text-align:left">一个 <strong>if 语句</strong> 后可跟一个可选的 <strong>else 语句</strong>，else 语句在布尔表达式为假时执行。</td>
</tr>
<tr>
<td style="text-align:left">嵌套 if 语句</td>
<td style="text-align:left">您可以在一个 <strong>if</strong> 或 <strong>else if</strong> 语句内使用另一个 <strong>if</strong> 或 <strong>else if</strong> 语句。</td>
</tr>
<tr>
<td style="text-align:left">switch 语句</td>
<td style="text-align:left">一个 <strong>switch</strong> 语句允许测试一个变量等于多个值时的情况。</td>
</tr>
<tr>
<td style="text-align:left">嵌套 switch 语句</td>
<td style="text-align:left">您可以在一个 <strong>switch</strong> 语句内使用另一个 <strong>switch</strong> 语句。</td>
</tr>
</tbody>
</table>
<h3 id="if-语句"><a class="header-anchor" href="#if-语句">¶</a>if 语句</h3>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">if(boolean<span class="emphasis">_expression)</span></span><br><span class="line"><span class="emphasis">&#123;</span></span><br><span class="line"><span class="emphasis">   /* 如果布尔表达式为真将执行的语句 */</span></span><br><span class="line"><span class="emphasis">&#125;</span></span><br></pre></td></tr></table></figure>
<p>如果布尔表达式为 <strong>true</strong>，则 if 语句内的代码块将被执行。如果布尔表达式为 <strong>false</strong>，则 if 语句结束后的第一组代码（闭括号后）将被执行。</p>
<p>C 语言把任何<strong>非零</strong>和<strong>非空</strong>的值假定为 <strong>true</strong>，把<strong>零</strong>或 <strong>null</strong> 假定为 <strong>false</strong>。</p>
<h3 id="if…else语句"><a class="header-anchor" href="#if…else语句">¶</a>if…else语句</h3>
<p>一个 <strong>if 语句</strong> 后可跟一个可选的 <strong>else 语句</strong>，else 语句在布尔表达式为 false 时执行。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">if(boolean<span class="emphasis">_expression)</span></span><br><span class="line"><span class="emphasis">&#123;</span></span><br><span class="line"><span class="emphasis">   /* 如果布尔表达式为真将执行的语句 */</span></span><br><span class="line"><span class="emphasis">&#125;</span></span><br><span class="line"><span class="emphasis">else</span></span><br><span class="line"><span class="emphasis">&#123;</span></span><br><span class="line"><span class="emphasis">   /* 如果布尔表达式为假将执行的语句 */</span></span><br><span class="line"><span class="emphasis">&#125;</span></span><br></pre></td></tr></table></figure>
<p>一个 <strong>if</strong> 语句后可跟一个可选的 <strong>else if…else</strong> 语句，这可用于测试多种条件。</p>
<p>当使用 if…else if…else 语句时，以下几点需要注意：</p>
<ul>
<li>一个 if 后可跟零个或一个 else，else 必须在所有 else if 之后。</li>
<li>一个 if 后可跟零个或多个 else if，else if 必须在 else 之前。</li>
<li>一旦某个 else if 匹配成功，其他的 else if 或 else 将不会被测试。</li>
</ul>
<h3 id="嵌套-if-语句"><a class="header-anchor" href="#嵌套-if-语句">¶</a>嵌套 if 语句</h3>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">if( boolean<span class="emphasis">_expression 1)</span></span><br><span class="line"><span class="emphasis">&#123;</span></span><br><span class="line"><span class="emphasis">   /* 当布尔表达式 1 为真时执行 */</span></span><br><span class="line"><span class="emphasis">   if(boolean_</span>expression 2)</span><br><span class="line">   &#123;</span><br><span class="line"><span class="code">      /* 当布尔表达式 2 为真时执行 */</span></span><br><span class="line"><span class="code">   &#125;</span></span><br><span class="line"><span class="code">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="switch-语句"><a class="header-anchor" href="#switch-语句">¶</a>switch 语句</h3>
<p>一个 <strong>switch</strong> 语句允许测试一个变量等于多个值时的情况。每个值称为一个 case，且被测试的变量会对每个 <strong>switch case</strong> 进行检查。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">switch(expression)&#123;</span><br><span class="line"><span class="code">    case constant-expression  :</span></span><br><span class="line"><span class="code">       statement(s);</span></span><br><span class="line"><span class="code">       break; /* 可选的 */</span></span><br><span class="line"><span class="code">    case constant-expression  :</span></span><br><span class="line"><span class="code">       statement(s);</span></span><br><span class="line"><span class="code">       break; /* 可选的 */</span></span><br><span class="line"><span class="code">  </span></span><br><span class="line"><span class="code">    /* 您可以有任意数量的 case 语句 */</span></span><br><span class="line"><span class="code">    default : /* 可选的 */</span></span><br><span class="line"><span class="code">       statement(s);</span></span><br><span class="line"><span class="code">&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>switch</strong> 语句必须遵循下面的规则：</p>
<ul>
<li><strong>switch</strong> 语句中的 <strong>expression</strong> 是一个常量表达式，必须是一个整型或枚举类型。</li>
<li>在一个 switch 中可以有任意数量的 case 语句。每个 case 后跟一个要比较的值和一个冒号。</li>
<li>case 的 <strong>constant-expression</strong> 必须与 switch 中的变量具有相同的数据类型，且必须是一个常量或字面量。</li>
<li>当被测试的变量等于 case 中的常量时，case 后跟的语句将被执行，直到遇到 <strong>break</strong> 语句为止。</li>
<li>当遇到 <strong>break</strong> 语句时，switch 终止，控制流将跳转到 switch 语句后的下一行。</li>
<li>不是每一个 case 都需要包含 <strong>break</strong>。如果 case 语句不包含 <strong>break</strong>，控制流将会 <em>继续</em> 后续的 case，直到遇到 break 为止。</li>
<li>一个 <strong>switch</strong> 语句可以有一个可选的 <strong>default</strong> case，出现在 switch 的结尾。default case 可用于在上面所有 case 都不为真时执行一个任务。default case 中的 <strong>break</strong> 语句不是必需的。</li>
</ul>
<h3 id="嵌套-switch-语句"><a class="header-anchor" href="#嵌套-switch-语句">¶</a>嵌套 switch 语句</h3>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">switch(ch1) &#123;</span><br><span class="line">   case &#x27;A&#x27;: </span><br><span class="line"><span class="code">      printf(&quot;这个 A 是外部 switch 的一部分&quot; );</span></span><br><span class="line"><span class="code">      switch(ch2) &#123;</span></span><br><span class="line"><span class="code">         case &#x27;A&#x27;:</span></span><br><span class="line"><span class="code">            printf(&quot;这个 A 是内部 switch 的一部分&quot; );</span></span><br><span class="line"><span class="code">            break;</span></span><br><span class="line"><span class="code">         case &#x27;B&#x27;: /* 内部 B case 代码 */</span></span><br><span class="line"><span class="code">      &#125;</span></span><br><span class="line"><span class="code">      break;</span></span><br><span class="line"><span class="code">   case &#x27;B&#x27;: /* 外部 B case 代码 */</span></span><br><span class="line"><span class="code">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="运算符-三元运算符"><a class="header-anchor" href="#运算符-三元运算符">¶</a>? : 运算符(三元运算符)</h2>
<p><strong>条件运算符 ? :</strong>，可以用来替代 <strong>if…else</strong> 语句。它的一般形式如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Exp1 ? Exp2 : Exp3;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其中，Exp1、Exp2 和 Exp3 是表达式。请注意，冒号的使用和位置。</p>
</blockquote>
<p>? 表达式的值是由 Exp1 决定的。如果 Exp1 为真，则计算 Exp2 的值，结果即为整个 ? 表达式的值。如果 Exp1 为假，则计算 Exp3 的值，结果即为整个 ? 表达式的值。</p>
<h3 id="实例-v8"><a class="header-anchor" href="#实例-v8">¶</a>实例</h3>
<p>以下实例通过输入一个数字来判断它是否为奇数或偶数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入一个数字 : &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num);</span><br><span class="line"> </span><br><span class="line">    (num%<span class="number">2</span>==<span class="number">0</span>)?<span class="built_in">printf</span>(<span class="string">&quot;偶数&quot;</span>):<span class="built_in">printf</span>(<span class="string">&quot;奇数&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>C 循环</h1>
<p>有的时候，我们可能需要多次执行同一块代码。一般情况下，语句是按顺序执行的：函数中的第一个语句先执行，接着是第二个语句，依此类推。</p>
<p>编程语言提供了更为复杂执行路径的多种控制结构。</p>
<p>循环语句允许我们多次执行一个语句或语句组。</p>
<h2 id="循环类型"><a class="header-anchor" href="#循环类型">¶</a>循环类型</h2>
<table>
<thead>
<tr>
<th style="text-align:left">循环类型</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">while 循环</td>
<td style="text-align:left">当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件。</td>
</tr>
<tr>
<td style="text-align:left">for 循环</td>
<td style="text-align:left">多次执行一个语句序列，简化管理循环变量的代码。</td>
</tr>
<tr>
<td style="text-align:left">do…while 循环</td>
<td style="text-align:left">除了它是在循环主体结尾测试条件外，其他与 while 语句类似。</td>
</tr>
<tr>
<td style="text-align:left">嵌套循环</td>
<td style="text-align:left">可以在 while、for 或 do…while 循环内使用一个或多个循环。</td>
</tr>
</tbody>
</table>
<h3 id="while-循环"><a class="header-anchor" href="#while-循环">¶</a>while 循环</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(condition)</span><br><span class="line">&#123;</span><br><span class="line">   statement(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，<strong>statement(s)</strong> 可以是一个单独的语句，也可以是几个语句组成的代码块。</p>
<p><strong>condition</strong> 可以是任意的表达式，当为任意非零值时都为 true。当条件为 true 时执行循环。 当条件为 false 时，退出循环，程序流将继续执行紧接着循环的下一条语句。</p>
<p><em>while</em> 循环的关键点是循环可能一次都不会执行。当条件为 false 时，会跳过循环主体，直接执行紧接着 while 循环的下一条语句。</p>
<h3 id="for-循环"><a class="header-anchor" href="#for-循环">¶</a>for 循环</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ( init; condition; increment )</span><br><span class="line">&#123;</span><br><span class="line">   statement(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是 for 循环的控制流：</p>
<ol>
<li><strong>init</strong> 会首先被执行，且只会执行一次。这一步允许您声明并初始化任何循环控制变量。您也可以不在这里写任何语句，只要有一个分号出现即可。</li>
<li>接下来，会判断 <strong>condition</strong>。如果为真，则执行循环主体。如果为假，则不执行循环主体，且控制流会跳转到紧接着 for 循环的下一条语句。</li>
<li>在执行完 for 循环主体后，控制流会跳回上面的 <strong>increment</strong> 语句。该语句允许您更新循环控制变量。该语句可以留空，只要在条件后有一个分号出现即可。</li>
<li>条件再次被判断。如果为真，则执行循环，这个过程会不断重复（循环主体，然后增加步值，再然后重新判断条件）。在条件变为假时，for 循环终止。</li>
</ol>
<h3 id="do…while-循环"><a class="header-anchor" href="#do…while-循环">¶</a><strong>do…while</strong> 循环</h3>
<p>不像 <strong>for</strong> 和 <strong>while</strong> 循环，它们是在循环头部测试循环条件。在 C 语言中，<strong>do…while</strong> 循环是在循环的尾部检查它的条件。</p>
<p><strong>do…while</strong> 循环与 while 循环类似，但是 do…while 循环会确保至少执行一次循环。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">   statement(s);</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">while</span>( condition );</span><br></pre></td></tr></table></figure>
<p>请注意，条件表达式出现在循环的尾部，所以循环中的 statement(s) 会在条件被测试之前至少执行一次。</p>
<p>如果条件为真，控制流会跳转回上面的 do，然后重新执行循环中的 statement(s)。这个过程会不断重复，直到给定条件变为假为止。</p>
<h3 id="嵌套循环"><a class="header-anchor" href="#嵌套循环">¶</a>嵌套循环</h3>
<p>C 语言中 <strong>嵌套 for 循环</strong> 语句的语法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (initialization; condition; increment/decrement)</span><br><span class="line">&#123;</span><br><span class="line">    statement(s);</span><br><span class="line">    <span class="keyword">for</span> (initialization; condition; increment/decrement)</span><br><span class="line">    &#123;</span><br><span class="line">        statement(s);</span><br><span class="line">        ... ... ...</span><br><span class="line">    &#125;</span><br><span class="line">    ... ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>流程图：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/stardust14/picture/img/20200910164012.png" alt=""></p>
<p>C 语言中 <strong>嵌套 while 循环</strong> 语句的语法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (condition1)</span><br><span class="line">&#123;</span><br><span class="line">    statement(s);</span><br><span class="line">    <span class="keyword">while</span> (condition2)</span><br><span class="line">    &#123;</span><br><span class="line">        statement(s);</span><br><span class="line">        ... ... ...</span><br><span class="line">    &#125;</span><br><span class="line">    ... ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>流程图：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/stardust14/picture/img/20200910164059.png" alt=""></p>
<p>C 语言中 <strong>嵌套 do…while 循环</strong> 语句的语法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    statement(s);</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        statement(s);</span><br><span class="line">        ... ... ...</span><br><span class="line">    &#125;<span class="keyword">while</span> (condition2);</span><br><span class="line">    ... ... ...</span><br><span class="line">&#125;<span class="keyword">while</span> (condition1);</span><br></pre></td></tr></table></figure>
<p>流程图：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/stardust14/picture/img/20200910171229.png" alt=""></p>
<p>关于嵌套循环有一点值得注意，您可以在任何类型的循环内嵌套其他任何类型的循环。比如，一个 for 循环可以嵌套在一个 while 循环内，反之亦然。</p>
<h3 id="实例-v9"><a class="header-anchor" href="#实例-v9">¶</a>实例</h3>
<h4 id="for-循环-v2"><a class="header-anchor" href="#for-循环-v2">¶</a>for 循环</h4>
<p>下面的程序使用了一个嵌套的 for 循环来查找 2 到 100 中的质数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">/* 局部变量定义 */</span></span><br><span class="line">   <span class="keyword">int</span> i, j;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">2</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(j=<span class="number">2</span>; j &lt;= (i/j); j++)</span><br><span class="line">        <span class="keyword">if</span>(!(i%j)) <span class="keyword">break</span>; <span class="comment">// 如果找到，则不是质数</span></span><br><span class="line">      <span class="keyword">if</span>(j &gt; (i/j)) <span class="built_in">printf</span>(<span class="string">&quot;%d 是质数\n&quot;</span>, i);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="number">2</span> 是质数</span><br><span class="line"><span class="number">3</span> 是质数</span><br><span class="line"><span class="number">5</span> 是质数</span><br><span class="line"><span class="number">7</span> 是质数</span><br><span class="line"><span class="number">11</span> 是质数</span><br><span class="line"><span class="number">13</span> 是质数</span><br><span class="line"><span class="number">17</span> 是质数</span><br><span class="line"><span class="number">19</span> 是质数</span><br><span class="line"><span class="number">23</span> 是质数</span><br><span class="line"><span class="number">29</span> 是质数</span><br><span class="line"><span class="number">31</span> 是质数</span><br><span class="line"><span class="number">37</span> 是质数</span><br><span class="line"><span class="number">41</span> 是质数</span><br><span class="line"><span class="number">43</span> 是质数</span><br><span class="line"><span class="number">47</span> 是质数</span><br><span class="line"><span class="number">53</span> 是质数</span><br><span class="line"><span class="number">59</span> 是质数</span><br><span class="line"><span class="number">61</span> 是质数</span><br><span class="line"><span class="number">67</span> 是质数</span><br><span class="line"><span class="number">71</span> 是质数</span><br><span class="line"><span class="number">73</span> 是质数</span><br><span class="line"><span class="number">79</span> 是质数</span><br><span class="line"><span class="number">83</span> 是质数</span><br><span class="line"><span class="number">89</span> 是质数</span><br><span class="line"><span class="number">97</span> 是质数</span><br></pre></td></tr></table></figure>
<h4 id="while-嵌套实例"><a class="header-anchor" href="#while-嵌套实例">¶</a>while 嵌套实例</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>,j;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= <span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        j=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,j);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<h4 id="do-while-嵌套实例"><a class="header-anchor" href="#do-while-嵌套实例">¶</a>do-while 嵌套实例</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>,j;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        j=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="keyword">while</span>(j &lt;= i);</span><br><span class="line">        i++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">while</span>(i &lt;= <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*</span><br><span class="line">**</span><br><span class="line">***</span><br><span class="line">****</span><br><span class="line">*****</span><br></pre></td></tr></table></figure>
<h2 id="循环控制语句"><a class="header-anchor" href="#循环控制语句">¶</a>循环控制语句</h2>
<p>循环控制语句改变代码的执行顺序。通过它可以实现代码的跳转。</p>
<table>
<thead>
<tr>
<th style="text-align:left">控制语句</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">break 语句</td>
<td style="text-align:left">终止<strong>循环</strong>或 <strong>switch</strong> 语句，程序流将继续执行紧接着循环或 switch 的下一条语句。</td>
</tr>
<tr>
<td style="text-align:left">continue 语句</td>
<td style="text-align:left">告诉一个循环体立刻停止本次循环迭代，重新开始下次循环迭代。</td>
</tr>
<tr>
<td style="text-align:left">goto 语句</td>
<td style="text-align:left">将控制转移到被标记的语句。但是不建议在程序中使用 goto 语句。</td>
</tr>
</tbody>
</table>
<h3 id="break-语句"><a class="header-anchor" href="#break-语句">¶</a>break 语句</h3>
<p>C 语言中 <strong>break</strong> 语句有以下两种用法：</p>
<ol>
<li>当 <strong>break</strong> 语句出现在一个循环内时，循环会立即终止，且程序流将继续执行紧接着循环的下一条语句。</li>
<li>它可用于终止 <strong>switch</strong> 语句中的一个 case。</li>
</ol>
<p>如果使用的是嵌套循环（即一个循环内嵌套另一个循环），break 语句会停止执行最内层的循环，然后开始执行该块之后的下一行代码。</p>
<h3 id="continue-语句"><a class="header-anchor" href="#continue-语句">¶</a>continue 语句</h3>
<p>C 语言中的 <strong>continue</strong> 语句有点像 <strong>break</strong> 语句。但它不是强制终止，continue 会跳过当前循环中的代码，强迫开始下一次循环。</p>
<p>对于 <strong>for</strong> 循环，<strong>continue</strong> 语句执行后自增语句仍然会执行。对于 <strong>while</strong> 和 <strong>do…while</strong> 循环，<strong>continue</strong> 语句重新执行条件判断语句。</p>
<h3 id="goto-语句"><a class="header-anchor" href="#goto-语句">¶</a>goto 语句</h3>
<p>C 语言中的 <strong>goto</strong> 语句允许把控制无条件转移到同一函数内的被标记的语句。</p>
<blockquote>
<p>**注意：**在任何编程语言中，都不建议使用 goto 语句。因为它使得程序的控制流难以跟踪，使程序难以理解和难以修改。任何使用 goto 语句的程序可以改写成不需要使用 goto 语句的写法。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">goto</span> label;</span><br><span class="line">..</span><br><span class="line">.</span><br><span class="line">label: statement;</span><br></pre></td></tr></table></figure>
<p>在这里，<strong>label</strong> 可以是任何除 C 关键字以外的纯文本，它可以设置在 C 程序中 <strong>goto</strong> 语句的前面或者后面。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/stardust14/picture/img/20200910171220.png" alt=""></p>
<h1>C 函数</h1>
<p>函数是一组一起执行一个任务的语句。每个 C 程序都至少有一个函数，即主函数 <strong>main()</strong> ，所有简单的程序都可以定义其他额外的函数。</p>
<p>您可以把代码划分到不同的函数中。如何划分代码到不同的函数中是由您来决定的，但在逻辑上，划分通常是根据每个函数执行一个特定的任务来进行的。</p>
<p>函数<strong>声明</strong>告诉编译器函数的名称、返回类型和参数。函数<strong>定义</strong>提供了函数的实际主体。</p>
<p>C 标准库提供了大量的程序可以调用的内置函数。例如，函数 <strong>strcat()</strong> 用来连接两个字符串，函数 <strong>memcpy()</strong> 用来复制内存到另一个位置。</p>
<p>函数还有很多叫法，比如方法、子例程或程序，等等。</p>
<h2 id="定义函数"><a class="header-anchor" href="#定义函数">¶</a>定义函数</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">return_type <span class="title">function_name</span><span class="params">( parameter <span class="built_in">list</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   body of the function</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 C 语言中，函数由一个函数头和一个函数主体组成。下面列出一个函数的所有组成部分：</p>
<ul>
<li>**返回类型：**一个函数可以返回一个值。<strong>return_type</strong> 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 <strong>void</strong>。</li>
<li>**函数名称：**这是函数的实际名称。函数名和参数列表一起构成了函数签名。</li>
<li>**参数：**参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。</li>
<li>**函数主体：**函数主体包含一组定义函数执行任务的语句。</li>
</ul>
<h3 id="实例-v10"><a class="header-anchor" href="#实例-v10">¶</a>实例</h3>
<p>以下是 <strong>max()</strong> 函数的源代码。该函数有两个参数 num1 和 num2，会返回这两个数中较大的那个数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 函数返回两个数中较大的那个数 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">/* 局部变量声明 */</span></span><br><span class="line">   <span class="keyword">int</span> result;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">if</span> (num1 &gt; num2)</span><br><span class="line">      result = num1;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">      result = num2;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数声明"><a class="header-anchor" href="#函数声明">¶</a>函数声明</h2>
<p>函数<strong>声明</strong>会告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。</p>
<p>函数声明包括以下几个部分：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">return_type <span class="title">function_name</span><span class="params">( parameter <span class="built_in">list</span> )</span></span>;</span><br></pre></td></tr></table></figure>
<p>针对上面定义的函数 max()，以下是函数声明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在函数声明中，参数的名称并不重要，只有参数的类型是必需的，因此下面也是有效的声明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>当在一个源文件中定义函数且在另一个文件中调用函数时，函数声明是必需的。在这种情况下，您应该在调用函数的文件顶部声明函数。</p>
<h2 id="调用函数"><a class="header-anchor" href="#调用函数">¶</a>调用函数</h2>
<p>创建 C 函数时，会定义函数做什么，然后通过调用函数来完成已定义的任务。</p>
<p>当程序调用函数时，程序控制权会转移给被调用的函数。被调用的函数执行已定义的任务，当函数的返回语句被执行时，或到达函数的结束括号时，会把程序控制权交还给主程序。</p>
<p>调用函数时，传递所需参数，如果函数返回一个值，则可以存储返回值。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 函数声明 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">/* 局部变量定义 */</span></span><br><span class="line">   <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">   <span class="keyword">int</span> b = <span class="number">200</span>;</span><br><span class="line">   <span class="keyword">int</span> ret;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 调用函数来获取最大值 */</span></span><br><span class="line">   ret = max(a, b);</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;Max value is : %d\n&quot;</span>, ret );</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 函数返回两个数中较大的那个数 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">/* 局部变量声明 */</span></span><br><span class="line">   <span class="keyword">int</span> result;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">if</span> (num1 &gt; num2)</span><br><span class="line">      result = num1;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">      result = num2;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把 max() 函数和 main() 函数放一块，编译源代码。当运行最后的可执行文件时，会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Max value is : <span class="number">200</span></span><br></pre></td></tr></table></figure>
<h2 id="函数参数"><a class="header-anchor" href="#函数参数">¶</a>函数参数</h2>
<p>如果函数要使用参数，则必须声明接受参数值的变量。这些变量称为函数的<strong>形式参数</strong>。</p>
<p>形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。</p>
<p>当调用函数时，有两种向函数传递参数的方式：</p>
<table>
<thead>
<tr>
<th style="text-align:left">调用类型</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">传值调用</td>
<td style="text-align:left">该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数不会影响实际参数。</td>
</tr>
<tr>
<td style="text-align:left">引用调用</td>
<td style="text-align:left">通过指针传递方式，形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作。</td>
</tr>
</tbody>
</table>
<h3 id="传值方式调用函数"><a class="header-anchor" href="#传值方式调用函数">¶</a>传值方式调用函数</h3>
<p>向函数传递参数的<strong>传值调用</strong>方法，把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数不会影响实际参数。</p>
<p>默认情况下，C 语言使用<em>传值调用</em>方法来传递参数。一般来说，这意味着函数内的代码不会改变用于调用函数的实际参数。函数 <strong>swap()</strong> 定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 函数定义 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> temp;</span><br><span class="line"></span><br><span class="line">   temp = x; <span class="comment">/* 保存 x 的值 */</span></span><br><span class="line">   x = y;    <span class="comment">/* 把 y 赋值给 x */</span></span><br><span class="line">   y = temp; <span class="comment">/* 把 temp 赋值给 y */</span></span><br><span class="line">  </span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过传递实际参数来调用函数 <strong>swap()</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 函数声明 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">/* 局部变量定义 */</span></span><br><span class="line">   <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">   <span class="keyword">int</span> b = <span class="number">200</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;交换前，a 的值： %d\n&quot;</span>, a );</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;交换前，b 的值： %d\n&quot;</span>, b );</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 调用函数来交换值 */</span></span><br><span class="line">   swap(a, b);</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;交换后，a 的值： %d\n&quot;</span>, a );</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;交换后，b 的值： %d\n&quot;</span>, b );</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">交换前，a 的值： <span class="number">100</span></span><br><span class="line">交换前，b 的值： <span class="number">200</span></span><br><span class="line">交换后，a 的值： <span class="number">100</span></span><br><span class="line">交换后，b 的值： <span class="number">200</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面的实例表明了，虽然在函数内改变了 a 和 b 的值，但是实际上 a 和 b 的值没有发生变化。</p>
</blockquote>
<h3 id="引用方式调用函数"><a class="header-anchor" href="#引用方式调用函数">¶</a>引用方式调用函数</h3>
<p>通过引用传递方式，形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作。</p>
<p>传递指针可以让多个函数访问指针所引用的对象，而不用把对象声明为全局可访问。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 函数定义 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *x, <span class="keyword">int</span> *y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> temp;</span><br><span class="line">   temp = *x;    <span class="comment">/* 保存地址 x 的值 */</span></span><br><span class="line">   *x = *y;      <span class="comment">/* 把 y 赋值给 x */</span></span><br><span class="line">   *y = temp;    <span class="comment">/* 把 temp 赋值给 y */</span></span><br><span class="line">  </span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过引用传值来调用函数 <strong>swap()</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 函数声明 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *x, <span class="keyword">int</span> *y)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">/* 局部变量定义 */</span></span><br><span class="line">   <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">   <span class="keyword">int</span> b = <span class="number">200</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;交换前，a 的值： %d\n&quot;</span>, a );</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;交换前，b 的值： %d\n&quot;</span>, b );</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 调用函数来交换值</span></span><br><span class="line"><span class="comment">    * &amp;a 表示指向 a 的指针，即变量 a 的地址</span></span><br><span class="line"><span class="comment">    * &amp;b 表示指向 b 的指针，即变量 b 的地址</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   swap(&amp;a, &amp;b);</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;交换后，a 的值： %d\n&quot;</span>, a );</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;交换后，b 的值： %d\n&quot;</span>, b );</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">交换前，a 的值： <span class="number">100</span></span><br><span class="line">交换前，b 的值： <span class="number">200</span></span><br><span class="line">交换后，a 的值： <span class="number">200</span></span><br><span class="line">交换后，b 的值： <span class="number">100</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面的实例表明了，与传值调用不同，引用调用在函数内改变了 a 和 b 的值，实际上也改变了函数外 a 和 b 的值。</p>
</blockquote>
<h1>C 作用域规则</h1>
<p>任何一种编程中，作用域是程序中定义的变量所存在的区域，超过该区域变量就不能被访问。C 语言中有三个地方可以声明变量：</p>
<ol>
<li>在函数或块内部的<strong>局部</strong>变量</li>
<li>在所有函数外部的<strong>全局</strong>变量</li>
<li>在<strong>形式</strong>参数的函数参数定义中</li>
</ol>
<h2 id="局部变量"><a class="header-anchor" href="#局部变量">¶</a>局部变量</h2>
<p>在某个函数或块的内部声明的变量称为局部变量。它们只能被该函数或该代码块内部的语句使用。局部变量在函数外部是不可知的。下面是使用局部变量的实例。在这里，所有的变量 a、b 和 c 是 main() 函数的局部变量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* 局部变量声明 */</span></span><br><span class="line">  <span class="keyword">int</span> a, b;</span><br><span class="line">  <span class="keyword">int</span> c;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* 实际初始化 */</span></span><br><span class="line">  a = <span class="number">10</span>;</span><br><span class="line">  b = <span class="number">20</span>;</span><br><span class="line">  c = a + b;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">printf</span> (<span class="string">&quot;value of a = %d, b = %d and c = %d\n&quot;</span>, a, b, c);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="全局变量"><a class="header-anchor" href="#全局变量">¶</a>全局变量</h2>
<p>全局变量是定义在函数外部，通常是在程序的顶部。全局变量在整个程序生命周期内都是有效的，在任意的函数内部能访问全局变量。</p>
<p>全局变量可以被任何函数访问。也就是说，全局变量在声明后整个程序中都是可用的。下面是使用全局变量和局部变量的实例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 全局变量声明 */</span></span><br><span class="line"><span class="keyword">int</span> g;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* 局部变量声明 */</span></span><br><span class="line">  <span class="keyword">int</span> a, b;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* 实际初始化 */</span></span><br><span class="line">  a = <span class="number">10</span>;</span><br><span class="line">  b = <span class="number">20</span>;</span><br><span class="line">  g = a + b;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">printf</span> (<span class="string">&quot;value of a = %d, b = %d and g = %d\n&quot;</span>, a, b, g);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在程序中，局部变量和全局变量的名称可以相同，但是在函数内，如果两个名字相同，会使用局部变量值，全局变量不会被使用。下面是一个实例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 全局变量声明 */</span></span><br><span class="line"><span class="keyword">int</span> g = <span class="number">20</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* 局部变量声明 */</span></span><br><span class="line">  <span class="keyword">int</span> g = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">printf</span> (<span class="string">&quot;value of g = %d\n&quot;</span>,  g);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="形式参数"><a class="header-anchor" href="#形式参数">¶</a>形式参数</h2>
<p>函数的参数，形式参数，被当作该函数内的局部变量，如果与全局变量同名它们会优先使用。下面是一个实例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 全局变量声明 */</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">20</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* 在主函数中的局部变量声明 */</span></span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">  <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">printf</span> (<span class="string">&quot;value of a in main() = %d\n&quot;</span>,  a);</span><br><span class="line">  c = sum( a, b);</span><br><span class="line">  <span class="built_in">printf</span> (<span class="string">&quot;value of c in main() = %d\n&quot;</span>,  c);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 添加两个整数的函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;value of a in sum() = %d\n&quot;</span>,  a);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;value of b in sum() = %d\n&quot;</span>,  b);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">value of a in <span class="title">main</span><span class="params">()</span> </span>= <span class="number">10</span></span><br><span class="line"><span class="function">value of a in <span class="title">sum</span><span class="params">()</span> </span>= <span class="number">10</span></span><br><span class="line"><span class="function">value of b in <span class="title">sum</span><span class="params">()</span> </span>= <span class="number">20</span></span><br><span class="line"><span class="function">value of c in <span class="title">main</span><span class="params">()</span> </span>= <span class="number">30</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>全局变量与局部变量在内存中的区别</strong>：</p>
</blockquote>
<blockquote>
<ul>
<li>全局变量保存在内存的全局存储区中，占用静态的存储单元；</li>
<li>局部变量保存在栈中，只有在所在函数被调用时才动态地为变量分配存储单元。</li>
</ul>
</blockquote>
<h2 id="初始化局部变量和全局变量"><a class="header-anchor" href="#初始化局部变量和全局变量">¶</a>初始化局部变量和全局变量</h2>
<p>当局部变量被定义时，系统不会对其初始化，您必须自行对其初始化。定义全局变量时，系统会自动对其初始化，如下所示：</p>
<table>
<thead>
<tr>
<th style="text-align:left">数据类型</th>
<th style="text-align:left">初始化默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">int</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">char</td>
<td style="text-align:left">‘\0’</td>
</tr>
<tr>
<td style="text-align:left">float</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">double</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">pointer</td>
<td style="text-align:left">NULL</td>
</tr>
</tbody>
</table>
<p>正确地初始化变量是一个良好的编程习惯，否则有时候程序可能会产生意想不到的结果，因为未初始化的变量会导致一些在内存位置中已经可用的垃圾值。</p>
<h1>C 数组</h1>
<p>C 语言支持<strong>数组</strong>数据结构，它可以存储一个固定大小的相同类型元素的顺序集合。数组是用来存储一系列数据，但它往往被认为是一系列相同类型的变量。</p>
<p>数组的声明并不是声明一个个单独的变量，比如 number0、number1、…、number99，而是声明一个数组变量，比如 numbers，然后使用 numbers[0]、numbers[1]、…、numbers[99] 来代表一个个单独的变量。数组中的特定元素可以通过索引访问。</p>
<p>所有的数组都是由连续的内存位置组成。最低的地址对应第一个元素，最高的地址对应最后一个元素。<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/stardust14/picture/img/20200913162129.jpg" alt="C 中的数组"></p>
<h2 id="声明数组"><a class="header-anchor" href="#声明数组">¶</a>声明数组</h2>
<p>在 C 中要声明一个数组，需要指定元素的类型和元素的数量，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">type arrayName [ arraySize ];</span><br></pre></td></tr></table></figure>
<p>这叫做一维数组。<strong>arraySize</strong> 必须是一个大于零的整数常量，<strong>type</strong> 可以是任意有效的 C 数据类型。例如，要声明一个类型为 double 的包含 10 个元素的数组 <strong>balance</strong>，声明语句如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> balance[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<p>现在 <em>balance</em> 是一个可用的数组，可以容纳 10 个类型为 double 的数字。</p>
<h2 id="初始化数组"><a class="header-anchor" href="#初始化数组">¶</a>初始化数组</h2>
<p>在 C 中，可以逐个初始化数组，也可以使用一个初始化语句，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> balance[<span class="number">5</span>] = &#123;<span class="number">1000.0</span>, <span class="number">2.0</span>, <span class="number">3.4</span>, <span class="number">7.0</span>, <span class="number">50.0</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>大括号 { } 之间的值的数目不能大于我们在数组声明时在方括号 [ ] 中指定的元素数目。</p>
<p>如果您省略掉了数组的大小，数组的大小则为初始化时元素的个数。因此，如果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> balance[] = &#123;<span class="number">1000.0</span>, <span class="number">2.0</span>, <span class="number">3.4</span>, <span class="number">7.0</span>, <span class="number">50.0</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>将创建一个数组，它与前一个实例中所创建的数组是完全相同的。下面是一个为数组中某个元素赋值的实例:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">balance[<span class="number">4</span>] = <span class="number">50.0</span>;</span><br></pre></td></tr></table></figure>
<p>上述的语句把数组中第五个元素的值赋为 50.0。所有的数组都是以 0 作为它们第一个元素的索引，也被称为基索引，数组的最后一个索引是数组的总大小减去 1。以下是上面所讨论的数组的的图形表示：<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/stardust14/picture/img/20200914213845.jpg" alt="数组表示"></p>
<h2 id="访问数组元素"><a class="header-anchor" href="#访问数组元素">¶</a>访问数组元素</h2>
<p>数组元素可以通过数组名称加索引进行访问。元素的索引是放在方括号内，跟在数组名称的后边。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> salary = balance[<span class="number">9</span>];</span><br></pre></td></tr></table></figure>
<p>上面的语句将把数组中第 10 个元素的值赋给 salary 变量。下面的实例使用了上述的三个概念，即，声明数组、数组赋值、访问数组：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> n[ <span class="number">10</span> ]; <span class="comment">/* n 是一个包含 10 个整数的数组 */</span></span><br><span class="line">   <span class="keyword">int</span> i,j;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 初始化数组元素 */</span>         </span><br><span class="line">   <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ )</span><br><span class="line">   &#123;</span><br><span class="line">      n[ i ] = i + <span class="number">100</span>; <span class="comment">/* 设置元素 i 为 i + 100 */</span></span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 输出数组中每个元素的值 */</span></span><br><span class="line">   <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Element[%d] = %d\n&quot;</span>, j, n[j] );</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Element[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">Element[<span class="number">1</span>] = <span class="number">101</span></span><br><span class="line">Element[<span class="number">2</span>] = <span class="number">102</span></span><br><span class="line">Element[<span class="number">3</span>] = <span class="number">103</span></span><br><span class="line">Element[<span class="number">4</span>] = <span class="number">104</span></span><br><span class="line">Element[<span class="number">5</span>] = <span class="number">105</span></span><br><span class="line">Element[<span class="number">6</span>] = <span class="number">106</span></span><br><span class="line">Element[<span class="number">7</span>] = <span class="number">107</span></span><br><span class="line">Element[<span class="number">8</span>] = <span class="number">108</span></span><br><span class="line">Element[<span class="number">9</span>] = <span class="number">109</span></span><br></pre></td></tr></table></figure>
<h2 id="C-中数组详解"><a class="header-anchor" href="#C-中数组详解">¶</a>C 中数组详解</h2>
<table>
<thead>
<tr>
<th style="text-align:left">概念</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">多维数组</td>
<td style="text-align:left">C 支持多维数组。多维数组最简单的形式是二维数组。</td>
</tr>
<tr>
<td style="text-align:left">传递数组给函数</td>
<td style="text-align:left">您可以通过指定不带索引的数组名称来给函数传递一个指向数组的指针。</td>
</tr>
<tr>
<td style="text-align:left">从函数返回数组</td>
<td style="text-align:left">C 允许从函数返回数组。</td>
</tr>
<tr>
<td style="text-align:left">指向数组的指针</td>
<td style="text-align:left">可以通过指定不带索引的数组名称来生成一个指向数组中第一个元素的指针。</td>
</tr>
</tbody>
</table>
<h3 id="多维数组"><a class="header-anchor" href="#多维数组">¶</a>多维数组</h3>
<p>多维数组声明的一般形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">type name[size1][size2]...[sizeN];</span><br></pre></td></tr></table></figure>
<p>例如，下面的声明创建了一个三维 5 . 10 . 4 整型数组：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> threedim[<span class="number">5</span>][<span class="number">10</span>][<span class="number">4</span>];</span><br></pre></td></tr></table></figure>
<h4 id="二维数组"><a class="header-anchor" href="#二维数组">¶</a>二维数组</h4>
<p>多维数组最简单的形式是二维数组。一个二维数组，在本质上，是一个一维数组的列表。声明一个 x 行 y 列的二维整型数组，形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">type arrayName [ x ][ y ];</span><br></pre></td></tr></table></figure>
<p>其中，<strong>type</strong> 可以是任意有效的 C 数据类型，<strong>arrayName</strong> 是一个有效的 C 标识符。一个二维数组可以被认为是一个带有 x 行和 y 列的表格。下面是一个二维数组，包含 3 行和 4 列：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x[<span class="number">3</span>][<span class="number">4</span>];</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/stardust14/picture/img/20200914214340.jpg" alt=""></p>
<p>因此，数组中的每个元素是使用形式为 a[ i , j ] 的元素名称来标识的，其中 a 是数组名称，i 和 j 是唯一标识 a 中每个元素的下标。</p>
<h4 id="初始化二维数组"><a class="header-anchor" href="#初始化二维数组">¶</a>初始化二维数组</h4>
<p>多维数组可以通过在括号内为每行指定值来进行初始化。下面是一个带有 3 行 4 列的数组。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;  </span><br><span class="line"> &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; ,   <span class="comment">/*  初始化索引号为 0 的行 */</span></span><br><span class="line"> &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125; ,   <span class="comment">/*  初始化索引号为 1 的行 */</span></span><br><span class="line"> &#123;<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;   <span class="comment">/*  初始化索引号为 2 的行 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>内部嵌套的括号是可选的，下面的初始化与上面是等同的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="访问二维数组元素"><a class="header-anchor" href="#访问二维数组元素">¶</a>访问二维数组元素</h4>
<p>二维数组中的元素是通过使用下标（即数组的行索引和列索引）来访问的。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> val = a[<span class="number">2</span>][<span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<p>上面的语句将获取数组中第 3 行第 4 个元素。可以通过上面的示意图来进行验证。来看看下面的程序，将使用嵌套循环来处理二维数组：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">/* 一个带有 5 行 2 列的数组 */</span></span><br><span class="line">   <span class="keyword">int</span> a[<span class="number">5</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">0</span>,<span class="number">0</span>&#125;, &#123;<span class="number">1</span>,<span class="number">2</span>&#125;, &#123;<span class="number">2</span>,<span class="number">4</span>&#125;, &#123;<span class="number">3</span>,<span class="number">6</span>&#125;,&#123;<span class="number">4</span>,<span class="number">8</span>&#125;&#125;;</span><br><span class="line">   <span class="keyword">int</span> i, j;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 输出数组中每个元素的值 */</span></span><br><span class="line">   <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++ )</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;a[%d][%d] = %d\n&quot;</span>, i,j, a[i][j] );</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">a[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">a[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">a[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">a[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">2</span></span><br><span class="line">a[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">4</span></span><br><span class="line">a[<span class="number">3</span>][<span class="number">0</span>] = <span class="number">3</span></span><br><span class="line">a[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">6</span></span><br><span class="line">a[<span class="number">4</span>][<span class="number">0</span>] = <span class="number">4</span></span><br><span class="line">a[<span class="number">4</span>][<span class="number">1</span>] = <span class="number">8</span></span><br></pre></td></tr></table></figure>
<h3 id="传递数组给函数"><a class="header-anchor" href="#传递数组给函数">¶</a>传递数组给函数</h3>
<p>如果想要在函数中传递一个一维数组作为参数，必须以下面三种方式来声明函数形式参数，这三种声明方式的结果是一样的，因为每种方式都会告诉编译器将要接收一个整型指针。同样地，也可以传递一个多维数组作为形式参数。</p>
<h4 id="方式-1"><a class="header-anchor" href="#方式-1">¶</a>方式 1</h4>
<p>形式参数是一个指针:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myFunction</span><span class="params">(<span class="keyword">int</span> *param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方式-2"><a class="header-anchor" href="#方式-2">¶</a>方式 2</h4>
<p>形式参数是一个已定义大小的数组：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myFunction</span><span class="params">(<span class="keyword">int</span> param[<span class="number">10</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方式-3"><a class="header-anchor" href="#方式-3">¶</a>方式 3</h4>
<p>形式参数是一个未定义大小的数组：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myFunction</span><span class="params">(<span class="keyword">int</span> param[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="实例-v11"><a class="header-anchor" href="#实例-v11">¶</a>实例</h4>
<p>来看下面这个函数，它把数组作为参数，同时还传递了另一个参数，根据所传的参数，会返回数组中各元素的平均值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getAverage</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span>    i;</span><br><span class="line">  <span class="keyword">double</span> avg;</span><br><span class="line">  <span class="keyword">double</span> sum;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    sum += arr[i];</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  avg = sum / size;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> avg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用上面的函数，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 函数声明 */</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getAverage</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> size)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">/* 带有 5 个元素的整型数组 */</span></span><br><span class="line">   <span class="keyword">int</span> balance[<span class="number">5</span>] = &#123;<span class="number">1000</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">17</span>, <span class="number">50</span>&#125;;</span><br><span class="line">   <span class="keyword">double</span> avg;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 传递一个指向数组的指针作为参数 */</span></span><br><span class="line">   avg = getAverage( balance, <span class="number">5</span> ) ;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 输出返回值 */</span></span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;平均值是： %f &quot;</span>, avg );</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getAverage</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span>    i;</span><br><span class="line">  <span class="keyword">double</span> avg;</span><br><span class="line">  <span class="keyword">double</span> sum=<span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    sum += arr[i];</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  avg = sum / size;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> avg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">平均值是： <span class="number">214.400000</span></span><br></pre></td></tr></table></figure>
<h3 id="从函数返回数组"><a class="header-anchor" href="#从函数返回数组">¶</a>从函数返回数组</h3>
<p>C 语言不允许返回一个完整的数组作为函数的参数。但是，可以通过指定不带索引的数组名来返回一个指向数组的指针。</p>
<p>如果想要从函数返回一个一维数组，必须声明一个返回指针的函数，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">myFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，C 不支持在函数外返回局部变量的地址，除非定义局部变量为 <strong>static</strong> 变量。</p>
<p>来看下面的函数，它会生成 10 个随机数，并使用数组来返回它们，具体如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 要生成和返回随机数的函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">getRandom</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span>  r[<span class="number">10</span>];</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* 设置种子 */</span></span><br><span class="line">  srand( (<span class="keyword">unsigned</span>)time( <span class="literal">NULL</span> ) );</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">     r[i] = rand();</span><br><span class="line">     <span class="built_in">printf</span>( <span class="string">&quot;r[%d] = %d\n&quot;</span>, i, r[i]);</span><br><span class="line"> </span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 要调用上面定义函数的主函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">/* 一个指向整数的指针 */</span></span><br><span class="line">   <span class="keyword">int</span> *p;</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line"> </span><br><span class="line">   p = getRandom();</span><br><span class="line">   <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ )</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">printf</span>( <span class="string">&quot;*(p + %d) : %d\n&quot;</span>, i, *(p + i));</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">r[<span class="number">0</span>] = <span class="number">313959809</span></span><br><span class="line">r[<span class="number">1</span>] = <span class="number">1759055877</span></span><br><span class="line">r[<span class="number">2</span>] = <span class="number">1113101911</span></span><br><span class="line">r[<span class="number">3</span>] = <span class="number">2133832223</span></span><br><span class="line">r[<span class="number">4</span>] = <span class="number">2073354073</span></span><br><span class="line">r[<span class="number">5</span>] = <span class="number">167288147</span></span><br><span class="line">r[<span class="number">6</span>] = <span class="number">1827471542</span></span><br><span class="line">r[<span class="number">7</span>] = <span class="number">834791014</span></span><br><span class="line">r[<span class="number">8</span>] = <span class="number">1901409888</span></span><br><span class="line">r[<span class="number">9</span>] = <span class="number">1990469526</span></span><br><span class="line">*(p + <span class="number">0</span>) : <span class="number">313959809</span></span><br><span class="line">*(p + <span class="number">1</span>) : <span class="number">1759055877</span></span><br><span class="line">*(p + <span class="number">2</span>) : <span class="number">1113101911</span></span><br><span class="line">*(p + <span class="number">3</span>) : <span class="number">2133832223</span></span><br><span class="line">*(p + <span class="number">4</span>) : <span class="number">2073354073</span></span><br><span class="line">*(p + <span class="number">5</span>) : <span class="number">167288147</span></span><br><span class="line">*(p + <span class="number">6</span>) : <span class="number">1827471542</span></span><br><span class="line">*(p + <span class="number">7</span>) : <span class="number">834791014</span></span><br><span class="line">*(p + <span class="number">8</span>) : <span class="number">1901409888</span></span><br><span class="line">*(p + <span class="number">9</span>) : <span class="number">1990469526</span></span><br></pre></td></tr></table></figure>
<h3 id="指向数组的指针"><a class="header-anchor" href="#指向数组的指针">¶</a>指向数组的指针</h3>
<p>数组名是一个指向数组中第一个元素的常量指针。因此，在下面的声明中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> balance[<span class="number">50</span>];</span><br></pre></td></tr></table></figure>
<p><strong>balance</strong> 是一个指向 &amp;balance[0] 的指针，即数组 balance 的第一个元素的地址。因此，下面的程序片段把 <strong>p</strong> 赋值为 <strong>balance</strong> 的第一个元素的地址：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> *p;</span><br><span class="line"><span class="keyword">double</span> balance[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">p = balance;</span><br></pre></td></tr></table></figure>
<p>使用数组名作为常量指针是合法的，反之亦然。因此，*(balance + 4) 是一种访问 balance[4] 数据的合法方式。</p>
<p>一旦把第一个元素的地址存储在 p 中，就可以使用 <em>p、</em>(p+1)、*(p+2) 等来访问数组元素。下面的实例演示了上面讨论到的这些概念：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">/* 带有 5 个元素的整型数组 */</span></span><br><span class="line">   <span class="keyword">double</span> balance[<span class="number">5</span>] = &#123;<span class="number">1000.0</span>, <span class="number">2.0</span>, <span class="number">3.4</span>, <span class="number">17.0</span>, <span class="number">50.0</span>&#125;;</span><br><span class="line">   <span class="keyword">double</span> *p;</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line"> </span><br><span class="line">   p = balance;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 输出数组中每个元素的值 */</span></span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;使用指针的数组值\n&quot;</span>);</span><br><span class="line">   <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ )</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;*(p + %d) : %f\n&quot;</span>,  i, *(p + i) );</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;使用 balance 作为地址的数组值\n&quot;</span>);</span><br><span class="line">   <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ )</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;*(balance + %d) : %f\n&quot;</span>,  i, *(balance + i) );</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">使用指针的数组值</span><br><span class="line">*(p + <span class="number">0</span>) : <span class="number">1000.000000</span></span><br><span class="line">*(p + <span class="number">1</span>) : <span class="number">2.000000</span></span><br><span class="line">*(p + <span class="number">2</span>) : <span class="number">3.400000</span></span><br><span class="line">*(p + <span class="number">3</span>) : <span class="number">17.000000</span></span><br><span class="line">*(p + <span class="number">4</span>) : <span class="number">50.000000</span></span><br><span class="line">使用 balance 作为地址的数组值</span><br><span class="line">*(balance + <span class="number">0</span>) : <span class="number">1000.000000</span></span><br><span class="line">*(balance + <span class="number">1</span>) : <span class="number">2.000000</span></span><br><span class="line">*(balance + <span class="number">2</span>) : <span class="number">3.400000</span></span><br><span class="line">*(balance + <span class="number">3</span>) : <span class="number">17.000000</span></span><br><span class="line">*(balance + <span class="number">4</span>) : <span class="number">50.000000</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在上面的实例中，p 是一个指向 double 型的指针，这意味着它可以存储一个 double 类型的变量。一旦有了 p 中的地址，*<strong>p</strong> 将给出存储在 p 中相应地址的值，正如上面实例中所演示的。</p>
</blockquote>
<h1>C enum(枚举)</h1>
<p>枚举是 C 语言中的一种基本数据类型，它可以让数据更简洁，更易读。</p>
<p>枚举语法定义格式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span>　枚举名　&#123;枚举元素<span class="number">1</span>,枚举元素<span class="number">2</span>,……&#125;;</span><br></pre></td></tr></table></figure>
<p>举个例子，比如：一星期有 7 天，如果不用枚举，我们需要使用 #define 来为每个整数定义一个别名：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MON  1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TUE  2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WED  3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THU  4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FRI  5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SAT  6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SUN  7</span></span><br></pre></td></tr></table></figure>
<p>使用枚举的方式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> DAY</span><br><span class="line">&#123;</span><br><span class="line">      MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>**注意：**第一个枚举成员的默认值为整型的 0，后续枚举成员的值在前一个成员上加 1。我们在这个实例中把第一个枚举成员的值定义为 1，第二个就为 2，以此类推。</p>
</blockquote>
<p><em>可以在定义枚举类型时改变枚举元素的值：</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> season &#123;spring, summer=<span class="number">3</span>, autumn, winter&#125;;</span><br></pre></td></tr></table></figure>
<p><em>没有指定值的枚举元素，其值为前一元素加 1。也就说 spring 的值为 0，summer 的值为 3，autumn 的值为 4，winter 的值为 5</em></p>
<h2 id="枚举变量的定义"><a class="header-anchor" href="#枚举变量的定义">¶</a>枚举变量的定义</h2>
<p>前面只是声明了枚举类型，接下来看看如何定义枚举变量。</p>
<p>可以通过以下三种方式来定义枚举变量</p>
<p><strong>1、先定义枚举类型，再定义枚举变量</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> DAY</span><br><span class="line">&#123;</span><br><span class="line">      MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">enum</span> DAY day;</span><br></pre></td></tr></table></figure>
<p><strong>2、定义枚举类型的同时定义枚举变量</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> DAY</span><br><span class="line">&#123;</span><br><span class="line">      MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125; day;</span><br></pre></td></tr></table></figure>
<p><strong>3、省略枚举名称，直接定义枚举变量</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">      MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125; day;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">enum</span> DAY</span><br><span class="line">&#123;</span><br><span class="line">      MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> DAY day;</span><br><span class="line">    day = WED;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,day);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上实例输出结果为：3</p>
<p>在C 语言中，枚举类型是被当做 int 或者 unsigned int 类型来处理的，所以按照 C 语言规范是没有办法遍历枚举类型的。</p>
<p>不过在一些特殊的情况下，枚举类型必须连续是可以实现有条件的遍历。</p>
<p>以下实例使用 for 来遍历枚举的元素：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">enum</span> DAY</span><br><span class="line">&#123;</span><br><span class="line">      MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125; day;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 遍历枚举元素</span></span><br><span class="line">    <span class="keyword">for</span> (day = MON; day &lt;= SUN; day++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;枚举元素：%d \n&quot;</span>, day);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下枚举类型<strong>不连续</strong>，这种枚举无法遍历。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">    ENUM_0,</span><br><span class="line">    ENUM_10 = <span class="number">10</span>,</span><br><span class="line">    ENUM_11</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>枚举在 switch 中的使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">enum</span> color &#123; red=<span class="number">1</span>, green, blue &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">enum</span>  color favorite_color;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 用户输入数字来选择颜色 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入你喜欢的颜色: (1. red, 2. green, 3. blue): &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%u&quot;</span>, &amp;favorite_color);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 输出结果 */</span></span><br><span class="line">    <span class="keyword">switch</span> (favorite_color)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> red:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;你喜欢的颜色是红色&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> green:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;你喜欢的颜色是绿色&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> blue:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;你喜欢的颜色是蓝色&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;你没有选择你喜欢的颜色&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上实例输出结果为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">请输入你喜欢的颜色: (<span class="number">1.</span> red, <span class="number">2.</span> green, <span class="number">3.</span> blue): <span class="number">1</span></span><br><span class="line">你喜欢的颜色是红色</span><br></pre></td></tr></table></figure>
<h2 id="将整数转换为枚举"><a class="header-anchor" href="#将整数转换为枚举">¶</a>将整数转换为枚举</h2>
<p>以下实例将整数转换为枚举：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">enum</span> day</span><br><span class="line">    &#123;</span><br><span class="line">        saturday,</span><br><span class="line">        sunday,</span><br><span class="line">        monday,</span><br><span class="line">        tuesday,</span><br><span class="line">        wednesday,</span><br><span class="line">        thursday,</span><br><span class="line">        friday</span><br><span class="line">    &#125; workday;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">enum</span> day weekend;</span><br><span class="line">    weekend = ( <span class="keyword">enum</span> day ) a;  <span class="comment">//类型转换</span></span><br><span class="line">    <span class="comment">//weekend = a; //错误</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;weekend:%d&quot;</span>,weekend);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上实例输出结果为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">weekend:<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h1>C 指针</h1>
<p>每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（&amp;）运算符访问的地址，它表示了在内存中的一个地址。请看下面的实例，它将输出定义的变量地址：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span>  var1;</span><br><span class="line">   <span class="keyword">char</span> var2[<span class="number">10</span>];</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;var1 变量的地址： %p\n&quot;</span>, &amp;var1  );</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;var2 变量的地址： %p\n&quot;</span>, &amp;var2  );</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">var1 变量的地址： <span class="number">0x7fff5cc109d4</span></span><br><span class="line">var2 变量的地址： <span class="number">0x7fff5cc109de</span></span><br></pre></td></tr></table></figure>
<h2 id="什么是指针？"><a class="header-anchor" href="#什么是指针？">¶</a>什么是指针？</h2>
<p><strong>指针</strong>是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。就像其他变量或常量一样，必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">type *var-name;</span><br></pre></td></tr></table></figure>
<p>在这里，<strong>type</strong> 是指针的基类型，它必须是一个有效的 C 数据类型，<strong>var-name</strong> 是指针变量的名称。用来声明指针的星号 * 与乘法中使用的星号是相同的。但是，在这个语句中，星号是用来指定一个变量是指针。以下是有效的指针声明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>    *ip;    <span class="comment">/* 一个整型的指针 */</span></span><br><span class="line"><span class="keyword">double</span> *dp;    <span class="comment">/* 一个 double 型的指针 */</span></span><br><span class="line"><span class="keyword">float</span>  *fp;    <span class="comment">/* 一个浮点型的指针 */</span></span><br><span class="line"><span class="keyword">char</span>   *ch;     <span class="comment">/* 一个字符型的指针 */</span></span><br></pre></td></tr></table></figure>
<p>所有实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，对应指针的值的类型都是一样的，都是一个代表内存地址的长的十六进制数。</p>
<p>不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。</p>
<h2 id="如何使用指针？"><a class="header-anchor" href="#如何使用指针？">¶</a>如何使用指针？</h2>
<p>使用指针时会频繁进行以下几个操作：定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值。这些是通过使用一元运算符 ***** 来返回位于操作数所指定地址的变量的值。下面的实例涉及到了这些操作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span>  var = <span class="number">20</span>;   <span class="comment">/* 实际变量的声明 */</span></span><br><span class="line">   <span class="keyword">int</span>  *ip;        <span class="comment">/* 指针变量的声明 */</span></span><br><span class="line"> </span><br><span class="line">   ip = &amp;var;  <span class="comment">/* 在指针变量中存储 var 的地址 */</span></span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Address of var variable: %p\n&quot;</span>, &amp;var  );</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 在指针变量中存储的地址 */</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Address stored in ip variable: %p\n&quot;</span>, ip );</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 使用指针访问值 */</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Value of *ip variable: %d\n&quot;</span>, *ip );</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Address of var variable: bffd8b3c</span><br><span class="line">Address stored in ip variable: bffd8b3c</span><br><span class="line">Value of *ip variable: <span class="number">20</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>%p是用来打印地址值的</p>
</blockquote>
<h2 id="C-中的-NULL-指针"><a class="header-anchor" href="#C-中的-NULL-指针">¶</a>C 中的 NULL 指针</h2>
<p>在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。赋为 NULL 值的指针被称为<strong>空</strong>指针。</p>
<p>NULL 指针是一个定义在标准库中的值为零的常量。请看下面的程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span>  *ptr = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;ptr 的地址是 %p\n&quot;</span>, ptr  );</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ptr 的地址是 <span class="number">0x0</span></span><br></pre></td></tr></table></figure>
<p>在大多数的操作系统上，程序不允许访问地址为 0 的内存，因为该内存是操作系统保留的。然而，内存地址 0 有特别重要的意义，它表明该指针不指向一个可访问的内存位置。但按照惯例，如果指针包含空值（零值），则假定它不指向任何东西。</p>
<p>如需检查一个空指针，您可以使用 if 语句，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(ptr)     <span class="comment">/* 如果 p 非空，则完成 */</span></span><br><span class="line"><span class="keyword">if</span>(!ptr)    <span class="comment">/* 如果 p 为空，则完成 */</span></span><br></pre></td></tr></table></figure>
<h2 id="C-指针详解"><a class="header-anchor" href="#C-指针详解">¶</a>C 指针详解</h2>
<p>在 C 中，有很多指针相关的概念，这些概念都很简单，但是都很重要。下面列出了 C 程序员必须清楚的一些与指针相关的重要概念：</p>
<table>
<thead>
<tr>
<th style="text-align:left">概念</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">指针的算术运算</td>
<td style="text-align:left">可以对指针进行四种算术运算：++、–、+、-</td>
</tr>
<tr>
<td style="text-align:left">指针数组</td>
<td style="text-align:left">可以定义用来存储指针的数组。</td>
</tr>
<tr>
<td style="text-align:left">指向指针的指针</td>
<td style="text-align:left">C 允许指向指针的指针。</td>
</tr>
<tr>
<td style="text-align:left">传递指针给函数</td>
<td style="text-align:left">通过引用或地址传递参数，使传递的参数在调用函数中被改变。</td>
</tr>
<tr>
<td style="text-align:left">从函数返回指针</td>
<td style="text-align:left">C 允许函数返回指针到局部变量、静态变量和动态内存分配。</td>
</tr>
</tbody>
</table>
<h3 id="指针的算术运算"><a class="header-anchor" href="#指针的算术运算">¶</a>指针的算术运算</h3>
<p>C 指针是一个用数值表示的地址。因此，您可以对指针执行算术运算。可以对指针进行四种算术运算：++、–、+、-。</p>
<p>假设 <strong>ptr</strong> 是一个指向地址 1000 的整型指针，是一个 32 位的整数，让我们对该指针执行下列的算术运算：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ptr++</span><br></pre></td></tr></table></figure>
<p>在执行完上述的运算之后，<strong>ptr</strong> 将指向位置 1004，因为 ptr 每增加一次，它都将指向下一个整数位置，即当前位置往后移 4 字节。这个运算会在不影响内存位置中实际值的情况下，移动指针到下一个内存位置。如果 <strong>ptr</strong> 指向一个地址为 1000 的字符，上面的运算会导致指针指向位置 1001，因为下一个字符位置是在 1001。</p>
<ul>
<li>指针的每一次递增，它其实会指向下一个元素的存储单元。</li>
<li>指针的每一次递减，它都会指向前一个元素的存储单元。</li>
<li>指针在递增和递减时跳跃的字节数取决于指针所指向变量数据类型长度，比如 int 就是 4 个字节。</li>
</ul>
<h4 id="递增一个指针"><a class="header-anchor" href="#递增一个指针">¶</a>递增一个指针</h4>
<p>在程序中使用指针代替数组，因为变量指针可以递增，而数组不能递增，数组可以看成一个指针常量。下面的程序递增变量指针，以便顺序访问数组中的每一个元素：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">3</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span>  var[] = &#123;<span class="number">10</span>, <span class="number">100</span>, <span class="number">200</span>&#125;;</span><br><span class="line">   <span class="keyword">int</span>  i, *ptr;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 指针中的数组地址 */</span></span><br><span class="line">   ptr = var;</span><br><span class="line">   <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; MAX; i++)</span><br><span class="line">   &#123;</span><br><span class="line"> </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;存储地址：var[%d] = %x\n&quot;</span>, i, ptr );</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;存储值：var[%d] = %d\n&quot;</span>, i, *ptr );</span><br><span class="line"> </span><br><span class="line">      <span class="comment">/* 移动到下一个位置 */</span></span><br><span class="line">      ptr++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">存储地址：var[<span class="number">0</span>] = bf882b30</span><br><span class="line">存储值：var[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line">存储地址：of var[<span class="number">1</span>] = bf882b34</span><br><span class="line">存储值： var[<span class="number">1</span>] = <span class="number">100</span></span><br><span class="line">存储地址：of var[<span class="number">2</span>] = bf882b38</span><br><span class="line">存储值：var[<span class="number">2</span>] = <span class="number">200</span></span><br></pre></td></tr></table></figure>
<h4 id="递减一个指针"><a class="header-anchor" href="#递减一个指针">¶</a>递减一个指针</h4>
<p>同样地，对指针进行递减运算，即把值减去其数据类型的字节数，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">3</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span>  var[] = &#123;<span class="number">10</span>, <span class="number">100</span>, <span class="number">200</span>&#125;;</span><br><span class="line">   <span class="keyword">int</span>  i, *ptr;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 指针中最后一个元素的地址 */</span></span><br><span class="line">   ptr = &amp;var[MAX<span class="number">-1</span>];</span><br><span class="line">   <span class="keyword">for</span> ( i = MAX; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">   &#123;</span><br><span class="line"> </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;存储地址：var[%d] = %x\n&quot;</span>, i<span class="number">-1</span>, ptr );</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;存储值：var[%d] = %d\n&quot;</span>, i<span class="number">-1</span>, *ptr );</span><br><span class="line"> </span><br><span class="line">      <span class="comment">/* 移动到下一个位置 */</span></span><br><span class="line">      ptr--;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">存储地址：var[<span class="number">2</span>] = <span class="number">518</span>a0ae4</span><br><span class="line">存储值：var[<span class="number">2</span>] = <span class="number">200</span></span><br><span class="line">存储地址：var[<span class="number">1</span>] = <span class="number">518</span>a0ae0</span><br><span class="line">存储值：var[<span class="number">1</span>] = <span class="number">100</span></span><br><span class="line">存储地址：var[<span class="number">0</span>] = <span class="number">518</span>a0adc</span><br><span class="line">存储值：var[<span class="number">0</span>] = <span class="number">10</span></span><br></pre></td></tr></table></figure>
<h4 id="指针的比较"><a class="header-anchor" href="#指针的比较">¶</a>指针的比较</h4>
<p>指针可以用关系运算符进行比较，如 ==、&lt; 和 &gt;。如果 p1 和 p2 指向两个相关的变量，比如同一个数组中的不同元素，则可对 p1 和 p2 进行大小比较。</p>
<p>下面的程序修改了上面的实例，只要变量指针所指向的地址小于或等于数组的最后一个元素的地址 &amp;var[MAX - 1]，则把变量指针进行递增：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">3</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span>  var[] = &#123;<span class="number">10</span>, <span class="number">100</span>, <span class="number">200</span>&#125;;</span><br><span class="line">   <span class="keyword">int</span>  i, *ptr;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 指针中第一个元素的地址 */</span></span><br><span class="line">   ptr = var;</span><br><span class="line">   i = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span> ( ptr &lt;= &amp;var[MAX - <span class="number">1</span>] )</span><br><span class="line">   &#123;</span><br><span class="line"> </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Address of var[%d] = %p\n&quot;</span>, i, ptr );</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Value of var[%d] = %d\n&quot;</span>, i, *ptr );</span><br><span class="line"> </span><br><span class="line">      <span class="comment">/* 指向上一个位置 */</span></span><br><span class="line">      ptr++;</span><br><span class="line">      i++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Address of var[<span class="number">0</span>] = bfdbcb20</span><br><span class="line">Value of var[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line">Address of var[<span class="number">1</span>] = bfdbcb24</span><br><span class="line">Value of var[<span class="number">1</span>] = <span class="number">100</span></span><br><span class="line">Address of var[<span class="number">2</span>] = bfdbcb28</span><br><span class="line">Value of var[<span class="number">2</span>] = <span class="number">200</span></span><br></pre></td></tr></table></figure>
<h3 id="指针数组"><a class="header-anchor" href="#指针数组">¶</a>指针数组</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">3</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span>  var[] = &#123;<span class="number">10</span>, <span class="number">100</span>, <span class="number">200</span>&#125;;</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX; i++)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Value of var[%d] = %d\n&quot;</span>, i, var[i] );</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Value of var[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line">Value of var[<span class="number">1</span>] = <span class="number">100</span></span><br><span class="line">Value of var[<span class="number">2</span>] = <span class="number">200</span></span><br></pre></td></tr></table></figure>
<p>可能有一种情况，想要让数组存储指向 int 或 char 或其他数据类型的指针。下面是一个指向整数的指针数组的声明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *ptr[MAX];</span><br></pre></td></tr></table></figure>
<p>在这里，把 <strong>ptr</strong> 声明为一个数组，由 MAX 个整数指针组成。因此，ptr 中的每个元素，都是一个指向 int 值的指针。下面的实例用到了三个整数，它们将存储在一个指针数组中，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">3</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span>  var[] = &#123;<span class="number">10</span>, <span class="number">100</span>, <span class="number">200</span>&#125;;</span><br><span class="line">   <span class="keyword">int</span> i, *ptr[MAX];</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; MAX; i++)</span><br><span class="line">   &#123;</span><br><span class="line">      ptr[i] = &amp;var[i]; <span class="comment">/* 赋值为整数的地址 */</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; MAX; i++)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Value of var[%d] = %d\n&quot;</span>, i, *ptr[i] );</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Value of var[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line">Value of var[<span class="number">1</span>] = <span class="number">100</span></span><br><span class="line">Value of var[<span class="number">2</span>] = <span class="number">200</span></span><br></pre></td></tr></table></figure>
<p>也可以用一个指向字符的指针数组来存储一个字符串列表，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">4</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">char</span> *names[] = &#123;</span><br><span class="line">                   <span class="string">&quot;Zara Ali&quot;</span>,</span><br><span class="line">                   <span class="string">&quot;Hina Ali&quot;</span>,</span><br><span class="line">                   <span class="string">&quot;Nuha Ali&quot;</span>,</span><br><span class="line">                   <span class="string">&quot;Sara Ali&quot;</span>,</span><br><span class="line">   &#125;;</span><br><span class="line">   <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; MAX; i++)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Value of names[%d] = %s\n&quot;</span>, i, names[i] );</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Value of names[<span class="number">0</span>] = Zara Ali</span><br><span class="line">Value of names[<span class="number">1</span>] = Hina Ali</span><br><span class="line">Value of names[<span class="number">2</span>] = Nuha Ali</span><br><span class="line">Value of names[<span class="number">3</span>] = Sara Ali</span><br></pre></td></tr></table></figure>
<h3 id="指向指针的指针"><a class="header-anchor" href="#指向指针的指针">¶</a>指向指针的指针</h3>
<p>指向指针的指针是一种多级间接寻址的形式，或者说是一个指针链。通常，一个指针包含一个变量的地址。当我们定义一个指向指针的指针时，第一个指针包含了第二个指针的地址，第二个指针指向包含实际值的位置。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/stardust14/picture/img/20200915165900.jpg" alt="C 中指向指针的指针"></p>
<p>一个指向指针的指针变量必须如下声明，即在变量名前放置两个星号。例如，下面声明了一个指向 int 类型指针的指针：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> **var;</span><br></pre></td></tr></table></figure>
<p>当一个目标值被一个指针间接指向到另一个指针时，访问这个值需要使用两个星号运算符，如下面实例所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span>  var;</span><br><span class="line">   <span class="keyword">int</span>  *ptr;</span><br><span class="line">   <span class="keyword">int</span>  **pptr;</span><br><span class="line"></span><br><span class="line">   var = <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 获取 var 的地址 */</span></span><br><span class="line">   ptr = &amp;var;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 使用运算符 &amp; 获取 ptr 的地址 */</span></span><br><span class="line">   pptr = &amp;ptr;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 使用 pptr 获取值 */</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Value of var = %d\n&quot;</span>, var );</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Value available at *ptr = %d\n&quot;</span>, *ptr );</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Value available at **pptr = %d\n&quot;</span>, **pptr);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Value of var = <span class="number">3000</span></span><br><span class="line">Value available at *ptr = <span class="number">3000</span></span><br><span class="line">Value available at **pptr = <span class="number">3000</span></span><br></pre></td></tr></table></figure>
<h3 id="传递指针给函数"><a class="header-anchor" href="#传递指针给函数">¶</a>传递指针给函数</h3>
<p>只需要简单地声明函数参数为指针类型即可。</p>
<p>下面的实例中，传递一个无符号的 long 型指针给函数，并在函数内改变这个值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getSeconds</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> *par)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">long</span> sec;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   getSeconds( &amp;sec );</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 输出实际值 */</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Number of seconds: %ld\n&quot;</span>, sec );</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getSeconds</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> *par)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">/* 获取当前的秒数 */</span></span><br><span class="line">   *par = time( <span class="literal">NULL</span> );</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Number of seconds :<span class="number">1294450468</span></span><br></pre></td></tr></table></figure>
<p>能接受指针作为参数的函数，也能接受数组作为参数，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 函数声明 */</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getAverage</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> size)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">/* 带有 5 个元素的整型数组  */</span></span><br><span class="line">   <span class="keyword">int</span> balance[<span class="number">5</span>] = &#123;<span class="number">1000</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">17</span>, <span class="number">50</span>&#125;;</span><br><span class="line">   <span class="keyword">double</span> avg;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 传递一个指向数组的指针作为参数 */</span></span><br><span class="line">   avg = getAverage( balance, <span class="number">5</span> ) ;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 输出返回值  */</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Average value is: %f\n&quot;</span>, avg );</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getAverage</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span>    i, sum = <span class="number">0</span>;      </span><br><span class="line">  <span class="keyword">double</span> avg;          </span><br><span class="line"> </span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    sum += arr[i];</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  avg = (<span class="keyword">double</span>)sum / size;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> avg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Average value is: <span class="number">214.40000</span></span><br></pre></td></tr></table></figure>
<h3 id="从函数返回指针"><a class="header-anchor" href="#从函数返回指针">¶</a>从函数返回指针</h3>
<p>C 允许从函数返回指针。为了做到这点，必须声明一个返回指针的函数，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">myFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，C 语言不支持在调用函数时返回局部变量的地址，除非定义局部变量为 <strong>static</strong> 变量。</p>
<p>现在，来看下面的函数，它会生成 10 个随机数，并使用表示指针的数组名（即第一个数组元素的地址）来返回它们，具体如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 要生成和返回随机数的函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">getRandom</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">int</span>  r[<span class="number">10</span>];</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 设置种子 */</span></span><br><span class="line">   srand( (<span class="keyword">unsigned</span>)time( <span class="literal">NULL</span> ) );</span><br><span class="line">   <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">   &#123;</span><br><span class="line">      r[i] = rand();</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, r[i] );</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 要调用上面定义函数的主函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">/* 一个指向整数的指针 */</span></span><br><span class="line">   <span class="keyword">int</span> *p;</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line"> </span><br><span class="line">   p = getRandom();</span><br><span class="line">   <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ )</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;*(p + [%d]) : %d\n&quot;</span>, i, *(p + i) );</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1523198053</span></span><br><span class="line"><span class="number">1187214107</span></span><br><span class="line"><span class="number">1108300978</span></span><br><span class="line"><span class="number">430494959</span></span><br><span class="line"><span class="number">1421301276</span></span><br><span class="line"><span class="number">930971084</span></span><br><span class="line"><span class="number">123250484</span></span><br><span class="line"><span class="number">106932140</span></span><br><span class="line"><span class="number">1604461820</span></span><br><span class="line"><span class="number">149169022</span></span><br><span class="line">*(p + [<span class="number">0</span>]) : <span class="number">1523198053</span></span><br><span class="line">*(p + [<span class="number">1</span>]) : <span class="number">1187214107</span></span><br><span class="line">*(p + [<span class="number">2</span>]) : <span class="number">1108300978</span></span><br><span class="line">*(p + [<span class="number">3</span>]) : <span class="number">430494959</span></span><br><span class="line">*(p + [<span class="number">4</span>]) : <span class="number">1421301276</span></span><br><span class="line">*(p + [<span class="number">5</span>]) : <span class="number">930971084</span></span><br><span class="line">*(p + [<span class="number">6</span>]) : <span class="number">123250484</span></span><br><span class="line">*(p + [<span class="number">7</span>]) : <span class="number">106932140</span></span><br><span class="line">*(p + [<span class="number">8</span>]) : <span class="number">1604461820</span></span><br><span class="line">*(p + [<span class="number">9</span>]) : <span class="number">149169022</span></span><br></pre></td></tr></table></figure>
<h1>C 函数指针与回调函数</h1>
<h2 id="函数指针"><a class="header-anchor" href="#函数指针">¶</a>函数指针</h2>
<p>函数指针是指向函数的指针变量。</p>
<p>通常我们说的指针变量是指向一个整型、字符型或数组等变量，而函数指针是指向函数。</p>
<p>函数指针可以像一般函数一样，用于调用函数、传递参数。</p>
<p>函数指针变量的声明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*fun_ptr)</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>; <span class="comment">// 声明一个指向同样参数、返回值的函数指针类型</span></span><br></pre></td></tr></table></figure>
<h3 id="实例-v12"><a class="header-anchor" href="#实例-v12">¶</a>实例</h3>
<p>以下实例声明了函数指针变量 p，指向函数 max：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; y ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* p 是函数指针 */</span></span><br><span class="line">    <span class="keyword">int</span> (* p)(<span class="keyword">int</span>, <span class="keyword">int</span>) = &amp; max; <span class="comment">// &amp;可以省略</span></span><br><span class="line">    <span class="keyword">int</span> a, b, c, d;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入三个数字:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp; a, &amp; b, &amp; c);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 与直接调用函数等价，d = max(max(a, b), c) */</span></span><br><span class="line">    d = p(p(a, b), c); </span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;最大的数字是: %d\n&quot;</span>, d);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译执行，输出结果如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">请输入三个数字:<span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">最大的数字是: <span class="number">3</span></span><br></pre></td></tr></table></figure>
<h2 id="回调函数"><a class="header-anchor" href="#回调函数">¶</a>回调函数</h2>
<h3 id="函数指针作为某个函数的参数"><a class="header-anchor" href="#函数指针作为某个函数的参数">¶</a>函数指针作为某个函数的参数</h3>
<p>函数指针变量可以作为某个函数的参数来使用的，回调函数就是一个通过函数指针调用的函数。</p>
<p>简单讲：回调函数是由别人的函数执行时调用你实现的函数。</p>
<blockquote>
<p>例子：<em>你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。在这个例子里，你的电话号码就叫回调函数，你把电话留给店员就叫登记回调函数，店里后来有货了叫做触发了回调关联的事件，店员给你打电话叫做调用回调函数，你到店里去取货叫做响应回调事件。</em></p>
</blockquote>
<h3 id="实例-v13"><a class="header-anchor" href="#实例-v13">¶</a>实例</h3>
<p>实例中 populate_array 函数定义了三个参数，其中第三个参数是函数的指针，通过该函数来设置数组的值。</p>
<p>实例中我们定义了回调函数 getNextRandomValue，它返回一个随机值，它作为一个函数指针传递给 populate_array 函数。</p>
<p>populate_array 将调用 10 次回调函数，并将回调函数的返回值赋值给数组。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">populate_array</span><span class="params">(<span class="keyword">int</span> *<span class="built_in">array</span>, <span class="keyword">size_t</span> arraySize, <span class="keyword">int</span> (*getNextValue)(<span class="keyword">void</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span>; i&lt;arraySize; i++)</span><br><span class="line">        <span class="built_in">array</span>[i] = getNextValue();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 获取随机值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNextRandomValue</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rand();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> myarray[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">/* getNextRandomValue 不能加括号，否则无法编译，因为加上括号之后相当于传入此参数时传入了 int , 而不是函数指针*/</span></span><br><span class="line">    populate_array(myarray, <span class="number">10</span>, getNextRandomValue);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, myarray[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译执行，输出结果如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">16807</span> <span class="number">282475249</span> <span class="number">1622650073</span> <span class="number">984943658</span> <span class="number">1144108930</span> <span class="number">470211272</span> <span class="number">101027544</span> <span class="number">1457850878</span> <span class="number">1458777923</span> <span class="number">2007237709</span></span><br></pre></td></tr></table></figure>
<h1>C 字符串</h1>
<p>在 C 语言中，字符串实际上是使用 <strong>null</strong> 字符 ‘\0’ 终止的一维字符数组。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。</p>
<p>下面的声明和初始化创建了一个 “Hello” 字符串。由于在数组的末尾存储了空字符，所以字符数组的大小比单词 “Hello” 的字符数多一个。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> greeting[<span class="number">6</span>] = &#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>依据数组初始化规则，您可以把上面的语句写成以下语句：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> greeting[] = <span class="string">&quot;Hello&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>以下是 C/C++ 中定义的字符串的内存表示：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/stardust14/picture/img/20200915171750.jpg" alt="C/C++ 中的字符串表示"></p>
<p>其实，不需要把 <em>null</em> 字符放在字符串常量的末尾。C 编译器会在初始化数组时，自动把 ‘\0’ 放在字符串的末尾。让我们尝试输出上面的字符串：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">char</span> greeting[<span class="number">6</span>] = &#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Greeting message: %s\n&quot;</span>, greeting );</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Greeting message: Hello</span><br></pre></td></tr></table></figure>
<p>C 中有大量操作字符串的函数</p>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">函数 &amp; 目的</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><strong>strcpy(s1, s2);</strong> 复制字符串 s2 到字符串 s1。</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><strong>strcat(s1, s2);</strong> 连接字符串 s2 到字符串 s1 的末尾。</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><strong>strlen(s1);</strong> 返回字符串 s1 的长度。</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left"><strong>strcmp(s1, s2);</strong> 如果 s1 和 s2 是相同的，则返回 0；如果 s1&lt;s2 则返回小于 0；如果 s1&gt;s2 则返回大于 0。</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left"><strong>strchr(s1, ch);</strong> 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left"><strong>strstr(s1, s2);</strong> 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。</td>
</tr>
</tbody>
</table>
<p>下面的实例使用了上述的一些函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">char</span> str1[<span class="number">12</span>] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">   <span class="keyword">char</span> str2[<span class="number">12</span>] = <span class="string">&quot;World&quot;</span>;</span><br><span class="line">   <span class="keyword">char</span> str3[<span class="number">12</span>];</span><br><span class="line">   <span class="keyword">int</span>  len ;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 复制 str1 到 str3 */</span></span><br><span class="line">   <span class="built_in">strcpy</span>(str3, str1);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;strcpy( str3, str1) :  %s\n&quot;</span>, str3 );</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 连接 str1 和 str2 */</span></span><br><span class="line">   <span class="built_in">strcat</span>( str1, str2);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;strcat( str1, str2):   %s\n&quot;</span>, str1 );</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 连接后，str1 的总长度 */</span></span><br><span class="line">   len = <span class="built_in">strlen</span>(str1);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;strlen(str1) :  %d\n&quot;</span>, len );</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>( str3, str1) :  Hello</span><br><span class="line"><span class="built_in">strcat</span>( str1, str2):   HelloWorld</span><br><span class="line"><span class="built_in">strlen</span>(str1) :  <span class="number">10</span></span><br></pre></td></tr></table></figure>
<h1>C 结构体</h1>
<p>C 数组允许定义可存储相同类型数据项的变量，<strong>结构</strong>是 C 编程中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。</p>
<p>结构用于表示一条记录，假设您想要跟踪图书馆中书本的动态，您可能需要跟踪每本书的下列属性：</p>
<ul>
<li>Title</li>
<li>Author</li>
<li>Subject</li>
<li>Book ID</li>
</ul>
<h2 id="定义结构"><a class="header-anchor" href="#定义结构">¶</a>定义结构</h2>
<p>为了定义结构，您必须使用 <strong>struct</strong> 语句。struct 语句定义了一个包含多个成员的新的数据类型，struct 语句的格式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tag</span> &#123;</span> </span><br><span class="line">    member-<span class="built_in">list</span></span><br><span class="line">    member-<span class="built_in">list</span> </span><br><span class="line">    member-<span class="built_in">list</span>  </span><br><span class="line">    ...</span><br><span class="line">&#125; variable-<span class="built_in">list</span> ;</span><br></pre></td></tr></table></figure>
<p><strong>tag</strong> 是结构体标签。</p>
<p><strong>member-list</strong> 是标准的变量定义，比如 int i; 或者 float f，或者其他有效的变量定义。</p>
<p><strong>variable-list</strong> 结构变量，定义在结构的末尾，最后一个分号之前，您可以指定一个或多个结构变量。下面是声明 Book 结构的方式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Books</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">char</span>  title[<span class="number">50</span>];</span><br><span class="line">   <span class="keyword">char</span>  author[<span class="number">50</span>];</span><br><span class="line">   <span class="keyword">char</span>  subject[<span class="number">100</span>];</span><br><span class="line">   <span class="keyword">int</span>   book_id;</span><br><span class="line">&#125; book;</span><br></pre></td></tr></table></figure>
<p>在一般情况下，<strong>tag、member-list、variable-list</strong> 这 3 部分至少要出现 2 个。以下为实例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//此声明声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c</span></span><br><span class="line"><span class="comment">//同时又声明了结构体变量s1</span></span><br><span class="line"><span class="comment">//这个结构体并没有标明其标签</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    <span class="keyword">double</span> c;</span><br><span class="line">&#125; s1;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//此声明声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c</span></span><br><span class="line"><span class="comment">//结构体的标签被命名为SIMPLE,没有声明变量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SIMPLE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    <span class="keyword">double</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//用SIMPLE标签的结构体，另外声明了变量t1、t2、t3</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SIMPLE</span> <span class="title">t1</span>, <span class="title">t2</span>[20], *<span class="title">t3</span>;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//也可以用typedef创建新类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    <span class="keyword">double</span> c; </span><br><span class="line">&#125; Simple2;</span><br><span class="line"><span class="comment">//现在可以用Simple2作为类型声明新的结构体变量</span></span><br><span class="line">Simple2 u1, u2[<span class="number">20</span>], *u3;</span><br></pre></td></tr></table></figure>
<p>在上面的声明中，第一个和第二声明被编译器当作两个完全不同的类型，即使他们的成员列表是一样的，如果令 t3=&amp;s1，则是非法的。</p>
<p>结构体的成员可以包含其他结构体，也可以包含指向自己结构体类型的指针，而通常这种指针的应用是为了实现一些更高级的数据结构如链表和树等。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//此结构体的声明包含了其他的结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">COMPLEX</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">string</span>[<span class="number">100</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SIMPLE</span> <span class="title">a</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//此结构体的声明包含了指向自己类型的指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NODE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">string</span>[<span class="number">100</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">NODE</span> *<span class="title">next_node</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果两个结构体互相包含，则需要对其中一个结构体进行不完整声明，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>;</span>    <span class="comment">//对结构体B进行不完整声明</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//结构体A中包含指向结构体B的指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">B</span> *<span class="title">partner</span>;</span></span><br><span class="line">    <span class="comment">//other members;</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//结构体B中包含指向结构体A的指针，在A声明完后，B也随之进行声明</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">A</span> *<span class="title">partner</span>;</span></span><br><span class="line">    <span class="comment">//other members;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="结构体变量的初始化"><a class="header-anchor" href="#结构体变量的初始化">¶</a>结构体变量的初始化</h2>
<p>和其它类型变量一样，对结构体变量可以在定义时指定初始值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Books</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">char</span>  title[<span class="number">50</span>];</span><br><span class="line">   <span class="keyword">char</span>  author[<span class="number">50</span>];</span><br><span class="line">   <span class="keyword">char</span>  subject[<span class="number">100</span>];</span><br><span class="line">   <span class="keyword">int</span>   book_id;</span><br><span class="line">&#125; book = &#123;<span class="string">&quot;C 语言&quot;</span>, <span class="string">&quot;RUNOOB&quot;</span>, <span class="string">&quot;编程语言&quot;</span>, <span class="number">123456</span>&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;title : %s\nauthor: %s\nsubject: %s\nbook_id: %d\n&quot;</span>, book.title, book.author, book.subject, book.book_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行输出结果为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">title : C 语言</span><br><span class="line">author: RUNOOB</span><br><span class="line">subject: 编程语言</span><br><span class="line">book_id: <span class="number">123456</span></span><br></pre></td></tr></table></figure>
<h2 id="访问结构成员"><a class="header-anchor" href="#访问结构成员">¶</a>访问结构成员</h2>
<p>为了访问结构的成员，我们使用<strong>成员访问运算符（.）</strong>。成员访问运算符是结构变量名称和我们要访问的结构成员之间的一个句号。您可以使用 <strong>struct</strong> 关键字来定义结构类型的变量。下面的实例演示了结构的用法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Books</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">char</span>  title[<span class="number">50</span>];</span><br><span class="line">   <span class="keyword">char</span>  author[<span class="number">50</span>];</span><br><span class="line">   <span class="keyword">char</span>  subject[<span class="number">100</span>];</span><br><span class="line">   <span class="keyword">int</span>   book_id;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">Books</span> <span class="title">Book1</span>;</span>        <span class="comment">/* 声明 Book1，类型为 Books */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">Books</span> <span class="title">Book2</span>;</span>        <span class="comment">/* 声明 Book2，类型为 Books */</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* Book1 详述 */</span></span><br><span class="line">   <span class="built_in">strcpy</span>( Book1.title, <span class="string">&quot;C Programming&quot;</span>);</span><br><span class="line">   <span class="built_in">strcpy</span>( Book1.author, <span class="string">&quot;Nuha Ali&quot;</span>); </span><br><span class="line">   <span class="built_in">strcpy</span>( Book1.subject, <span class="string">&quot;C Programming Tutorial&quot;</span>);</span><br><span class="line">   Book1.book_id = <span class="number">6495407</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* Book2 详述 */</span></span><br><span class="line">   <span class="built_in">strcpy</span>( Book2.title, <span class="string">&quot;Telecom Billing&quot;</span>);</span><br><span class="line">   <span class="built_in">strcpy</span>( Book2.author, <span class="string">&quot;Zara Ali&quot;</span>);</span><br><span class="line">   <span class="built_in">strcpy</span>( Book2.subject, <span class="string">&quot;Telecom Billing Tutorial&quot;</span>);</span><br><span class="line">   Book2.book_id = <span class="number">6495700</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 输出 Book1 信息 */</span></span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;Book 1 title : %s\n&quot;</span>, Book1.title);</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;Book 1 author : %s\n&quot;</span>, Book1.author);</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;Book 1 subject : %s\n&quot;</span>, Book1.subject);</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;Book 1 book_id : %d\n&quot;</span>, Book1.book_id);</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 输出 Book2 信息 */</span></span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;Book 2 title : %s\n&quot;</span>, Book2.title);</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;Book 2 author : %s\n&quot;</span>, Book2.author);</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;Book 2 subject : %s\n&quot;</span>, Book2.subject);</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;Book 2 book_id : %d\n&quot;</span>, Book2.book_id);</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Book <span class="number">1</span> title : C Programming</span><br><span class="line">Book <span class="number">1</span> author : Nuha Ali</span><br><span class="line">Book <span class="number">1</span> subject : C Programming Tutorial</span><br><span class="line">Book <span class="number">1</span> book_id : <span class="number">6495407</span></span><br><span class="line">Book <span class="number">2</span> title : Telecom Billing</span><br><span class="line">Book <span class="number">2</span> author : Zara Ali</span><br><span class="line">Book <span class="number">2</span> subject : Telecom Billing Tutorial</span><br><span class="line">Book <span class="number">2</span> book_id : <span class="number">6495700</span></span><br></pre></td></tr></table></figure>
<h2 id="结构作为函数参数"><a class="header-anchor" href="#结构作为函数参数">¶</a>结构作为函数参数</h2>
<p>可以把结构作为函数参数，传参方式与其他类型的变量或指针类似。可以使用上面实例中的方式来访问结构变量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Books</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">char</span>  title[<span class="number">50</span>];</span><br><span class="line">   <span class="keyword">char</span>  author[<span class="number">50</span>];</span><br><span class="line">   <span class="keyword">char</span>  subject[<span class="number">100</span>];</span><br><span class="line">   <span class="keyword">int</span>   book_id;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 函数声明 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printBook</span><span class="params">( struct Books book )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">Books</span> <span class="title">Book1</span>;</span>        <span class="comment">/* 声明 Book1，类型为 Books */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">Books</span> <span class="title">Book2</span>;</span>        <span class="comment">/* 声明 Book2，类型为 Books */</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* Book1 详述 */</span></span><br><span class="line">   <span class="built_in">strcpy</span>( Book1.title, <span class="string">&quot;C Programming&quot;</span>);</span><br><span class="line">   <span class="built_in">strcpy</span>( Book1.author, <span class="string">&quot;Nuha Ali&quot;</span>); </span><br><span class="line">   <span class="built_in">strcpy</span>( Book1.subject, <span class="string">&quot;C Programming Tutorial&quot;</span>);</span><br><span class="line">   Book1.book_id = <span class="number">6495407</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* Book2 详述 */</span></span><br><span class="line">   <span class="built_in">strcpy</span>( Book2.title, <span class="string">&quot;Telecom Billing&quot;</span>);</span><br><span class="line">   <span class="built_in">strcpy</span>( Book2.author, <span class="string">&quot;Zara Ali&quot;</span>);</span><br><span class="line">   <span class="built_in">strcpy</span>( Book2.subject, <span class="string">&quot;Telecom Billing Tutorial&quot;</span>);</span><br><span class="line">   Book2.book_id = <span class="number">6495700</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 输出 Book1 信息 */</span></span><br><span class="line">   printBook( Book1 );</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 输出 Book2 信息 */</span></span><br><span class="line">   printBook( Book2 );</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printBook</span><span class="params">( struct Books book )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;Book title : %s\n&quot;</span>, book.title);</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;Book author : %s\n&quot;</span>, book.author);</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;Book subject : %s\n&quot;</span>, book.subject);</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;Book book_id : %d\n&quot;</span>, book.book_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Book title : C Programming</span><br><span class="line">Book author : Nuha Ali</span><br><span class="line">Book subject : C Programming Tutorial</span><br><span class="line">Book book_id : 6495407</span><br><span class="line">Book title : Telecom Billing</span><br><span class="line">Book author : Zara Ali</span><br><span class="line">Book subject : Telecom Billing Tutorial</span><br><span class="line">Book book_id : 6495700</span><br></pre></td></tr></table></figure>
<h2 id="指向结构的指针"><a class="header-anchor" href="#指向结构的指针">¶</a>指向结构的指针</h2>
<p>可以定义指向结构的指针，方式与定义指向其他类型变量的指针相似，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Books</span> *<span class="title">struct_pointer</span>;</span></span><br></pre></td></tr></table></figure>
<p>现在，可以在上述定义的指针变量中存储结构变量的地址。为了查找结构变量的地址，请把 &amp; 运算符放在结构名称的前面，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">struct_pointer = &amp;Book1;</span><br></pre></td></tr></table></figure>
<p>为了使用指向该结构的指针访问结构的成员，必须使用 -&gt; 运算符，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">struct_pointer-&gt;title;</span><br></pre></td></tr></table></figure>
<p>让我们使用结构指针来重写上面的实例，这将有助于您理解结构指针的概念：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Books</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">char</span>  title[<span class="number">50</span>];</span><br><span class="line">   <span class="keyword">char</span>  author[<span class="number">50</span>];</span><br><span class="line">   <span class="keyword">char</span>  subject[<span class="number">100</span>];</span><br><span class="line">   <span class="keyword">int</span>   book_id;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 函数声明 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printBook</span><span class="params">( struct Books *book )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">Books</span> <span class="title">Book1</span>;</span>        <span class="comment">/* 声明 Book1，类型为 Books */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">Books</span> <span class="title">Book2</span>;</span>        <span class="comment">/* 声明 Book2，类型为 Books */</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* Book1 详述 */</span></span><br><span class="line">   <span class="built_in">strcpy</span>( Book1.title, <span class="string">&quot;C Programming&quot;</span>);</span><br><span class="line">   <span class="built_in">strcpy</span>( Book1.author, <span class="string">&quot;Nuha Ali&quot;</span>); </span><br><span class="line">   <span class="built_in">strcpy</span>( Book1.subject, <span class="string">&quot;C Programming Tutorial&quot;</span>);</span><br><span class="line">   Book1.book_id = <span class="number">6495407</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* Book2 详述 */</span></span><br><span class="line">   <span class="built_in">strcpy</span>( Book2.title, <span class="string">&quot;Telecom Billing&quot;</span>);</span><br><span class="line">   <span class="built_in">strcpy</span>( Book2.author, <span class="string">&quot;Zara Ali&quot;</span>);</span><br><span class="line">   <span class="built_in">strcpy</span>( Book2.subject, <span class="string">&quot;Telecom Billing Tutorial&quot;</span>);</span><br><span class="line">   Book2.book_id = <span class="number">6495700</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 通过传 Book1 的地址来输出 Book1 信息 */</span></span><br><span class="line">   printBook( &amp;Book1 );</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 通过传 Book2 的地址来输出 Book2 信息 */</span></span><br><span class="line">   printBook( &amp;Book2 );</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printBook</span><span class="params">( struct Books *book )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;Book title : %s\n&quot;</span>, book-&gt;title);</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;Book author : %s\n&quot;</span>, book-&gt;author);</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;Book subject : %s\n&quot;</span>, book-&gt;subject);</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;Book book_id : %d\n&quot;</span>, book-&gt;book_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Book title : C Programming</span><br><span class="line">Book author : Nuha Ali</span><br><span class="line">Book subject : C Programming Tutorial</span><br><span class="line">Book book_id : <span class="number">6495407</span></span><br><span class="line">Book title : Telecom Billing</span><br><span class="line">Book author : Zara Ali</span><br><span class="line">Book subject : Telecom Billing Tutorial</span><br><span class="line">Book book_id : <span class="number">6495700</span></span><br></pre></td></tr></table></figure>
<h2 id="位域"><a class="header-anchor" href="#位域">¶</a>位域</h2>
<p>有些信息在存储时，并不需要占用一个完整的字节，而只需占几个或一个二进制位。例如在存放一个开关量时，只有 0 和 1 两种状态，用 1 位二进位即可。为了节省存储空间，并使处理简便，C 语言又提供了一种数据结构，称为&quot;位域&quot;或&quot;位段&quot;。</p>
<p>所谓&quot;位域&quot;是把一个字节中的二进位划分为几个不同的区域，并说明每个区域的位数。每个域有一个域名，允许在程序中按域名进行操作。这样就可以把几个不同的对象用一个字节的二进制位域来表示。</p>
<p>典型的实例：</p>
<ul>
<li>用 1 位二进位存放一个开关量时，只有 0 和 1 两种状态。</li>
<li>读取外部文件格式——可以读取非标准的文件格式。例如：9 位的整数。</li>
</ul>
<h3 id="位域的定义和位域变量的说明"><a class="header-anchor" href="#位域的定义和位域变量的说明">¶</a>位域的定义和位域变量的说明</h3>
<p>位域定义与结构定义相仿，其形式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 位域结构名 </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line"> 位域列表</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中位域列表的形式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">类型说明符 位域名: 位域长度 </span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bs</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a:<span class="number">8</span>;</span><br><span class="line">    <span class="keyword">int</span> b:<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> c:<span class="number">6</span>;</span><br><span class="line">&#125;data;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明 data 为 bs 变量，共占两个字节。其中位域 a 占 8 位，位域 b 占 2 位，位域 c 占 6 位。</p>
</blockquote>
<p>再来看一个实例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">packed_struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> f1:<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> f2:<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> f3:<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> f4:<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> type:<span class="number">4</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> my_int:<span class="number">9</span>;</span><br><span class="line">&#125; pack;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在这里，packed_struct 包含了 6 个成员：四个 1 位的标识符 f1…f4、一个 4 位的 type 和一个 9 位的 my_int。</p>
</blockquote>
<p><strong>对于位域的定义尚有以下几点说明：</strong></p>
<ul>
<li>
<p>一个位域存储在同一个字节中，如一个字节所剩空间不够存放另一位域时，则会从下一单元起存放该位域。也可以有意使某位域从下一单元开始。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bs</span>&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> a:<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span>  :<span class="number">4</span>;    <span class="comment">/* 空域 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> b:<span class="number">4</span>;    <span class="comment">/* 从下一单元开始存放 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> c:<span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个位域定义中，a 占第一字节的 4 位，后 4 位填 0 表示不使用，b 从第二字节开始，占用 4 位，c 占用 4 位。</p>
</li>
<li>
<p>由于位域不允许跨两个字节，因此位域的长度不能大于一个字节的长度，也就是说不能超过8位二进位。如果最大长度大于计算机的整数字长，一些编译器可能会允许域的内存重叠，另外一些编译器可能会把大于一个域的部分存储在下一个字中。</p>
</li>
<li>
<p>位域可以是无名位域，这时它只用来作填充或调整位置。无名的位域是不能使用的。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">k</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>  :<span class="number">2</span>;    <span class="comment">/* 该 2 位不能使用 */</span></span><br><span class="line">    <span class="keyword">int</span> b:<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> c:<span class="number">2</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>从以上分析可以看出，位域在本质上就是一种结构类型，不过其成员是按二进位分配的。</p>
</blockquote>
<h3 id="位域的使用"><a class="header-anchor" href="#位域的使用">¶</a>位域的使用</h3>
<p>位域的使用和结构成员的使用相同，其一般形式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">位域变量名.位域名</span><br><span class="line">位域变量名-&gt;位域名</span><br></pre></td></tr></table></figure>
<p>位域允许用各种格式输出。</p>
<p>请看下面的实例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bs</span>&#123;</span></span><br><span class="line">        <span class="keyword">unsigned</span> a:<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> b:<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> c:<span class="number">4</span>;</span><br><span class="line">    &#125; bit,*pbit;</span><br><span class="line">    bit.a=<span class="number">1</span>;    <span class="comment">/* 给位域赋值（应注意赋值不能超过该位域的允许范围） */</span></span><br><span class="line">    bit.b=<span class="number">7</span>;    <span class="comment">/* 给位域赋值（应注意赋值不能超过该位域的允许范围） */</span></span><br><span class="line">    bit.c=<span class="number">15</span>;    <span class="comment">/* 给位域赋值（应注意赋值不能超过该位域的允许范围） */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d,%d,%d\n&quot;</span>,bit.a,bit.b,bit.c);    <span class="comment">/* 以整型量格式输出三个域的内容 */</span></span><br><span class="line">    pbit=&amp;bit;    <span class="comment">/* 把位域变量 bit 的地址送给指针变量 pbit */</span></span><br><span class="line">    pbit-&gt;a=<span class="number">0</span>;    <span class="comment">/* 用指针方式给位域 a 重新赋值，赋为 0 */</span></span><br><span class="line">    pbit-&gt;b&amp;=<span class="number">3</span>;    <span class="comment">/* 使用了复合的位运算符 &quot;&amp;=&quot;，相当于：pbit-&gt;b=pbit-&gt;b&amp;3，位域 b 中原有值为 7，与 3 作按位与运算的结果为 3（111&amp;011=011，十进制值为 3） */</span></span><br><span class="line">    pbit-&gt;c|=<span class="number">1</span>;    <span class="comment">/* 使用了复合位运算符&quot;|=&quot;，相当于：pbit-&gt;c=pbit-&gt;c|1，其结果为 15 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d,%d,%d\n&quot;</span>,pbit-&gt;a,pbit-&gt;b,pbit-&gt;c);    <span class="comment">/* 用指针方式输出了这三个域的值 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上例程序中定义了位域结构 bs，三个位域为 a、b、c。说明了 bs 类型的变量 bit 和指向 bs 类型的指针变量 pbit。这表示位域也是可以使用指针的。</p>
</blockquote>
<h1>C 共用体</h1>
<p><strong>共用体</strong>是一种特殊的数据类型，允许在相同的内存位置存储不同的数据类型。可以定义一个带有多成员的共用体，但是任何时候只能有一个成员带有值。共用体提供了一种使用相同的内存位置的有效方式。</p>
<h2 id="定义共用体"><a class="header-anchor" href="#定义共用体">¶</a>定义共用体</h2>
<p>为了定义共用体，您必须使用 <strong>union</strong> 语句，方式与定义结构类似。union 语句定义了一个新的数据类型，带有多个成员。union 语句的格式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> [<span class="keyword">union</span> tag]</span><br><span class="line">&#123;</span><br><span class="line">   member definition;</span><br><span class="line">   member definition;</span><br><span class="line">   ...</span><br><span class="line">   member definition;</span><br><span class="line">&#125; [one <span class="keyword">or</span> more <span class="keyword">union</span> variables];</span><br></pre></td></tr></table></figure>
<p><strong>union tag</strong> 是可选的，每个 member definition 是标准的变量定义，比如 int i; 或者 float f; 或者其他有效的变量定义。在共用体定义的末尾，最后一个分号之前，您可以指定一个或多个共用体变量，这是可选的。下面定义一个名为 Data 的共用体类型，有三个成员 i、f 和 str：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> Data</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">   <span class="keyword">float</span> f;</span><br><span class="line">   <span class="keyword">char</span>  str[<span class="number">20</span>];</span><br><span class="line">&#125; data;</span><br></pre></td></tr></table></figure>
<p>现在，<strong>Data</strong> 类型的变量可以存储一个整数、一个浮点数，或者一个字符串。这意味着一个变量（相同的内存位置）可以存储多个多种类型的数据。您可以根据需要在一个共用体内使用任何内置的或者用户自定义的数据类型。</p>
<p>共用体占用的内存应足够存储共用体中最大的成员。例如，在上面的实例中，Data 将占用 20 个字节的内存空间，因为在各个成员中，字符串所占用的空间是最大的。下面的实例将显示上面的共用体占用的总内存大小：</p>
<div class='tip success'><p>由于data占用最大的字节数是char str[20]占用20个字节<p></div>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">union</span> Data</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">   <span class="keyword">float</span> f;</span><br><span class="line">   <span class="keyword">char</span>  str[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">union</span> Data data;        </span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;Memory size occupied by data : %d\n&quot;</span>, <span class="keyword">sizeof</span>(data));</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Memory size occupied by data : <span class="number">20</span></span><br></pre></td></tr></table></figure>
<h2 id="访问共用体成员"><a class="header-anchor" href="#访问共用体成员">¶</a>访问共用体成员</h2>
<p>为了访问共用体的成员，我们使用<strong>成员访问运算符（.）</strong>。成员访问运算符是共用体变量名称和我们要访问的共用体成员之间的一个句号。您可以使用 <strong>union</strong> 关键字来定义共用体类型的变量。下面的实例演示了共用体的用法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">union</span> Data</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">   <span class="keyword">float</span> f;</span><br><span class="line">   <span class="keyword">char</span>  str[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">union</span> Data data;        </span><br><span class="line"> </span><br><span class="line">   data.i = <span class="number">10</span>;</span><br><span class="line">   data.f = <span class="number">220.5</span>;</span><br><span class="line">   <span class="built_in">strcpy</span>( data.str, <span class="string">&quot;C Programming&quot;</span>);</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;data.i : %d\n&quot;</span>, data.i);</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;data.f : %f\n&quot;</span>, data.f);</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;data.str : %s\n&quot;</span>, data.str);</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">data.i : <span class="number">1917853763</span></span><br><span class="line">data.f : <span class="number">4122360580327794860452759994368.000000</span></span><br><span class="line">data.str : C Programming</span><br></pre></td></tr></table></figure>
<p>在这里，可以看到共用体的 <strong>i</strong> 和 <strong>f</strong> 成员的值有损坏，因为最后赋给变量的值占用了内存位置，这也是 <strong>str</strong> 成员能够完好输出的原因。现在让我们再来看一个相同的实例，这次在同一时间只使用一个变量，这也演示了使用共用体的主要目的:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">union</span> Data</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">   <span class="keyword">float</span> f;</span><br><span class="line">   <span class="keyword">char</span>  str[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">union</span> Data data;        </span><br><span class="line"> </span><br><span class="line">   data.i = <span class="number">10</span>;</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;data.i : %d\n&quot;</span>, data.i);</span><br><span class="line">   </span><br><span class="line">   data.f = <span class="number">220.5</span>;</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;data.f : %f\n&quot;</span>, data.f);</span><br><span class="line">   <span class="comment">//strcpy是字符串复制，接受两个参数,一个是被复制字符串,另一个新字符串</span></span><br><span class="line">   <span class="built_in">strcpy</span>( data.str, <span class="string">&quot;C Programming&quot;</span>);</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;data.str : %s\n&quot;</span>, data.str);</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">data.i : <span class="number">10</span></span><br><span class="line">data.f : <span class="number">220.500000</span></span><br><span class="line">data.str : C Programming</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在这里，所有的成员都能完好输出，因为同一时间只用到一个成员。</p>
</blockquote>
<h1>C 位域</h1>
<p>如果程序的结构中包含多个开关量，只有 TRUE/FALSE 变量，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> widthValidated;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> heightValidated;</span><br><span class="line">&#125; status;</span><br></pre></td></tr></table></figure>
<p>这种结构需要 8 字节的内存空间，但在实际上，在每个变量中，我们只存储 0 或 1。在这种情况下，C 语言提供了一种更好的利用内存空间的方式。如果您在结构内使用这样的变量，可以定义变量的宽度来告诉编译器，将只使用这些字节。例如，上面的结构可以重写成：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> widthValidated : <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> heightValidated : <span class="number">1</span>;</span><br><span class="line">&#125; status;</span><br></pre></td></tr></table></figure>
<p>现在，上面的结构中，status 变量将占用 4 个字节的内存空间，但是只有 2 位被用来存储值。如果您用了 32 个变量，每一个变量宽度为 1 位，那么 status 结构将使用 4 个字节，但只要您再多用一个变量，如果使用了 33 个变量，那么它将分配内存的下一段来存储第 33 个变量，这个时候就开始使用 8 个字节。让我们看看下面的实例来理解这个概念：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 定义简单的结构 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> widthValidated;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> heightValidated;</span><br><span class="line">&#125; status1;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 定义位域结构 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> widthValidated : <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> heightValidated : <span class="number">1</span>;</span><br><span class="line">&#125; status2;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;Memory size occupied by status1 : %d\n&quot;</span>, <span class="keyword">sizeof</span>(status1));</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;Memory size occupied by status2 : %d\n&quot;</span>, <span class="keyword">sizeof</span>(status2));</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Memory size occupied by status1 : <span class="number">8</span></span><br><span class="line">Memory size occupied by status2 : <span class="number">4</span></span><br></pre></td></tr></table></figure>
<h2 id="位域声明"><a class="header-anchor" href="#位域声明">¶</a>位域声明</h2>
<p>在结构内声明位域的形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  type [member_name] : width ;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下面是有关位域中变量元素的描述：</p>
<table>
<thead>
<tr>
<th style="text-align:left">元素</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">type</td>
<td style="text-align:left">只能为 int(整型)，unsigned int(无符号整型)，signed int(有符号整型) 三种类型，决定了如何解释位域的值。</td>
</tr>
<tr>
<td style="text-align:left">member_name</td>
<td style="text-align:left">位域的名称。</td>
</tr>
<tr>
<td style="text-align:left">width</td>
<td style="text-align:left">位域中位的数量。宽度必须小于或等于指定类型的位宽度。</td>
</tr>
</tbody>
</table>
<p>带有预定义宽度的变量被称为<strong>位域</strong>。位域可以存储多于 1 位的数，例如，需要一个变量来存储从 0 到 7 的值，您可以定义一个宽度为 3 位的位域，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> age : <span class="number">3</span>;</span><br><span class="line">&#125; Age;</span><br></pre></td></tr></table></figure>
<p>上面的结构定义指示 C 编译器，age 变量将只使用 3 位来存储这个值，如果试图使用超过 3 位，则无法完成。让我们来看下面的实例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> age : <span class="number">3</span>;</span><br><span class="line">&#125; Age;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Age.age = <span class="number">4</span>;</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;Sizeof( Age ) : %d\n&quot;</span>, <span class="keyword">sizeof</span>(Age) );</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;Age.age : %d\n&quot;</span>, Age.age );</span><br><span class="line"> </span><br><span class="line">   Age.age = <span class="number">7</span>;</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;Age.age : %d\n&quot;</span>, Age.age );</span><br><span class="line"> </span><br><span class="line">   Age.age = <span class="number">8</span>; <span class="comment">// 二进制表示为 1000 有四位，超出</span></span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;Age.age : %d\n&quot;</span>, Age.age );</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上面的代码被编译时，它会带有警告，当上面的代码被执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Sizeof( Age ) : <span class="number">4</span></span><br><span class="line">Age.age : <span class="number">4</span></span><br><span class="line">Age.age : <span class="number">7</span></span><br><span class="line">Age.age : <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h1>C typedef</h1>
<p>C 语言提供了 <strong>typedef</strong> 关键字，您可以使用它来为类型取一个新的名字。下面的实例为单字节数字定义了一个术语 <strong>BYTE</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> BYTE;</span><br></pre></td></tr></table></figure>
<p>在这个类型定义之后，标识符 BYTE 可作为类型 <strong>unsigned char</strong> 的缩写，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BYTE  b1, b2;</span><br></pre></td></tr></table></figure>
<p>按照惯例，定义时会大写字母，以便提醒用户类型名称是一个象征性的缩写，但也可以使用小写字母，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> byte;</span><br></pre></td></tr></table></figure>
<p>也可以使用 <strong>typedef</strong> 来为用户自定义的数据类型取一个新的名字。例如，可以对结构体使用 typedef 来定义一个新的数据类型名字，然后使用这个新的数据类型来直接定义结构变量，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Books</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">char</span>  title[<span class="number">50</span>];</span><br><span class="line">   <span class="keyword">char</span>  author[<span class="number">50</span>];</span><br><span class="line">   <span class="keyword">char</span>  subject[<span class="number">100</span>];</span><br><span class="line">   <span class="keyword">int</span>   book_id;</span><br><span class="line">&#125; Book;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Book book;</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">strcpy</span>( book.title, <span class="string">&quot;C 教程&quot;</span>);</span><br><span class="line">   <span class="built_in">strcpy</span>( book.author, <span class="string">&quot;Runoob&quot;</span>); </span><br><span class="line">   <span class="built_in">strcpy</span>( book.subject, <span class="string">&quot;编程语言&quot;</span>);</span><br><span class="line">   book.book_id = <span class="number">12345</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;书标题 : %s\n&quot;</span>, book.title);</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;书作者 : %s\n&quot;</span>, book.author);</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;书类目 : %s\n&quot;</span>, book.subject);</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;书 ID : %d\n&quot;</span>, book.book_id);</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">书标题 : C 教程</span><br><span class="line">书作者 : Runoob</span><br><span class="line">书类目 : 编程语言</span><br><span class="line">书 ID : <span class="number">12345</span></span><br></pre></td></tr></table></figure>
<h2 id="typedef-vs-define"><a class="header-anchor" href="#typedef-vs-define">¶</a>typedef vs #define</h2>
<p><strong>#define</strong> 是 C 指令，用于为各种数据类型定义别名，与 <strong>typedef</strong> 类似，但是它们有以下几点不同：</p>
<ul>
<li><strong>typedef</strong> 仅限于为类型定义符号名称，<strong>#define</strong> 不仅可以为类型定义别名，也能为数值定义别名，比如您可以定义 1 为 ONE。</li>
<li><strong>typedef</strong> 是由编译器执行解释的，<strong>#define</strong> 语句是由预编译器进行处理的。</li>
</ul>
<p>下面是 #define 的最简单的用法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE  1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;TRUE 的值: %d\n&quot;</span>, TRUE);</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;FALSE 的值: %d\n&quot;</span>, FALSE);</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TRUE 的值: <span class="number">1</span></span><br><span class="line">FALSE 的值: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h1>C 输入 &amp; 输出</h1>
<p>当我们提到<strong>输入</strong>时，这意味着要向程序填充一些数据。输入可以是以文件的形式或从命令行中进行。C 语言提供了一系列内置的函数来读取给定的输入，并根据需要填充到程序中。</p>
<p>当我们提到<strong>输出</strong>时，这意味着要在屏幕上、打印机上或任意文件中显示一些数据。C 语言提供了一系列内置的函数来输出数据到计算机屏幕上和保存数据到文本文件或二进制文件中。</p>
<h2 id="标准文件"><a class="header-anchor" href="#标准文件">¶</a>标准文件</h2>
<p>C 语言把所有的设备都当作文件。所以设备（比如显示器）被处理的方式与文件相同。以下三个文件会在程序执行时自动打开，以便访问键盘和屏幕。</p>
<table>
<thead>
<tr>
<th style="text-align:left">标准文件</th>
<th style="text-align:left">文件指针</th>
<th style="text-align:left">设备</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">标准输入</td>
<td style="text-align:left">stdin</td>
<td style="text-align:left">键盘</td>
</tr>
<tr>
<td style="text-align:left">标准输出</td>
<td style="text-align:left">stdout</td>
<td style="text-align:left">屏幕</td>
</tr>
<tr>
<td style="text-align:left">标准错误</td>
<td style="text-align:left">stderr</td>
<td style="text-align:left">您的屏幕</td>
</tr>
</tbody>
</table>
<p>文件指针是访问文件的方式，本节将讲解如何从屏幕读取值以及如何把结果输出到屏幕上。</p>
<p>C 语言中的 I/O (输入/输出) 通常使用 printf() 和 scanf() 两个函数。</p>
<p>scanf() 函数用于从标准输入（键盘）读取并格式化， printf() 函数发送格式化输出到标准输出（屏幕）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;      // 执行 printf() 函数需要该库</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;菜鸟教程&quot;</span>);  <span class="comment">//显示引号中的内容</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译以上程序，输出结果为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">菜鸟教程</span><br></pre></td></tr></table></figure>
<p><strong>实例解析：</strong></p>
<ul>
<li>所有的 C 语言程序都需要包含 <strong>main()</strong> 函数。 代码从 <strong>main()</strong> 函数开始执行。</li>
<li><strong>printf()</strong> 用于格式化输出到屏幕。<strong>printf()</strong> 函数在 <strong>“stdio.h”</strong> 头文件中声明。</li>
<li><strong>stdio.h</strong> 是一个头文件 (标准输入输出头文件) and <strong>#include</strong> 是一个预处理命令，用来引入头文件。 当编译器遇到 <strong>printf()</strong> 函数时，如果没有找到 <strong>stdio.h</strong> 头文件，会发生编译错误。</li>
<li><strong>return 0;</strong> 语句用于表示退出程序。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> testInteger = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Number = %d&quot;</span>, testInteger);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译以上程序，输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Number &#x3D; 5</span><br></pre></td></tr></table></figure>
<p>在 printf() 函数的引号中使用 “%d” (整型) 来匹配整型变量 testInteger 并输出到屏幕。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> f;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter a number: &quot;</span>);</span><br><span class="line">    <span class="comment">// %f 匹配浮点型数据</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>,&amp;f);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Value = %f&quot;</span>, f);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="getchar-putchar-函数"><a class="header-anchor" href="#getchar-putchar-函数">¶</a>getchar() &amp; putchar() 函数</h2>
<p><strong>int getchar(void)</strong> 函数从屏幕读取下一个可用的字符，并把它返回为一个整数。这个函数在同一个时间内只会读取一个单一的字符。可以在循环内使用这个方法，以便从屏幕上读取多个字符。</p>
<p><strong>int putchar(int c)</strong> 函数把字符输出到屏幕上，并返回相同的字符。这个函数在同一个时间内只会输出一个单一的字符。可以在循环内使用这个方法，以便在屏幕上输出多个字符。</p>
<p>请看下面的实例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> c;</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;Enter a value :&quot;</span>);</span><br><span class="line">   c = getchar( );</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;\nYou entered: &quot;</span>);</span><br><span class="line">   <span class="built_in">putchar</span>( c );</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上面的代码被编译和执行时，它会等待您输入一些文本，当您输入一个文本并按下回车键时，程序会继续并只会读取一个单一的字符，显示如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$./a.out</span><br><span class="line">Enter a value :runoob</span><br><span class="line"></span><br><span class="line">You entered: r</span><br></pre></td></tr></table></figure>
<h2 id="gets-puts-函数"><a class="header-anchor" href="#gets-puts-函数">¶</a>gets() &amp; puts() 函数</h2>
<p><strong>char *gets(char *s)</strong> 函数从 <strong>stdin</strong> 读取一行到 <strong>s</strong> 所指向的缓冲区，直到一个终止符或 EOF。</p>
<p><strong>int puts(const char *s)</strong> 函数把字符串 s 和一个尾随的换行符写入到 <strong>stdout</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;Enter a value :&quot;</span>);</span><br><span class="line">   gets( str );</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;\nYou entered: &quot;</span>);</span><br><span class="line">   <span class="built_in">puts</span>( str );</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上面的代码被编译和执行时，它会等待您输入一些文本，当输入一个文本并按下回车键时，程序会继续并读取一整行直到该行结束，显示如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$./a.out</span><br><span class="line">Enter a value :runoob</span><br><span class="line"></span><br><span class="line">You entered: runoob</span><br></pre></td></tr></table></figure>
<h2 id="scanf-和-printf-函数"><a class="header-anchor" href="#scanf-和-printf-函数">¶</a>scanf() 和 printf() 函数</h2>
<p><strong>int scanf(const char *format, …)</strong> 函数从标准输入流 <strong>stdin</strong> 读取输入，并根据提供的 <strong>format</strong> 来浏览输入。</p>
<p><strong>int printf(const char *format, …)</strong> 函数把输出写入到标准输出流 <strong>stdout</strong> ，并根据提供的格式产生输出。</p>
<p><strong>format</strong> 可以是一个简单的常量字符串，但是您可以分别指定 %s、%d、%c、%f 等来输出或读取字符串、整数、字符或浮点数。还有许多其他可用的格式选项，可以根据需要使用。如需了解完整的细节，可以查看这些函数的参考手册。现在让我们通过下面这个简单的实例来加深理解：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;Enter a value :&quot;</span>);</span><br><span class="line">   <span class="built_in">scanf</span>(<span class="string">&quot;%s %d&quot;</span>, str, &amp;i);</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;\nYou entered: %s %d &quot;</span>, str, i);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上面的代码被编译和执行时，它会等待输入一些文本，当您输入一个文本并按下回车键时，程序会继续并读取输入，显示如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$.&#x2F;a.out</span><br><span class="line">Enter a value :runoob 123</span><br><span class="line"></span><br><span class="line">You entered: runoob 123 </span><br></pre></td></tr></table></figure>
<blockquote>
<p>在这里，应当指出的是，scanf() 期待输入的格式与给出的 %s 和 %d 相同，这意味着您必须提供有效的输入，比如 “string integer”，如果提供的是 “string string” 或 “integer integer”，它会被认为是错误的输入。另外，在读取字符串时，只要遇到一个空格，scanf() 就会停止读取，所以 “this is test” 对 scanf() 来说是三个字符串。</p>
</blockquote>
<h1>C 文件读写</h1>
<h2 id="打开文件"><a class="header-anchor" href="#打开文件">¶</a>打开文件</h2>
<p>可以使用 <strong>fopen( )</strong> 函数来创建一个新的文件或者打开一个已有的文件，这个调用会初始化类型 <strong>FILE</strong> 的一个对象，类型 <strong>FILE</strong> 包含了所有用来控制流的必要的信息。下面是这个函数调用的原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> * filename, <span class="keyword">const</span> <span class="keyword">char</span> * mode )</span></span>;</span><br></pre></td></tr></table></figure>
<p>在这里，<strong>filename</strong> 是字符串，用来命名文件，访问模式 <strong>mode</strong> 的值可以是下列值中的一个：</p>
<table>
<thead>
<tr>
<th style="text-align:left">模式</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">r</td>
<td style="text-align:left">打开一个已有的文本文件，允许读取文件。</td>
</tr>
<tr>
<td style="text-align:left">w</td>
<td style="text-align:left">打开一个文本文件，允许写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会从文件的开头写入内容。如果文件存在，则该会被截断为零长度，重新写入。</td>
</tr>
<tr>
<td style="text-align:left">a</td>
<td style="text-align:left">打开一个文本文件，以追加模式写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会在已有的文件内容中追加内容。</td>
</tr>
<tr>
<td style="text-align:left">r+</td>
<td style="text-align:left">打开一个文本文件，允许读写文件。</td>
</tr>
<tr>
<td style="text-align:left">w+</td>
<td style="text-align:left">打开一个文本文件，允许读写文件。如果文件已存在，则文件会被截断为零长度，如果文件不存在，则会创建一个新文件。</td>
</tr>
<tr>
<td style="text-align:left">a+</td>
<td style="text-align:left">打开一个文本文件，允许读写文件。如果文件不存在，则会创建一个新文件。读取会从文件的开头开始，写入则只能是追加模式。</td>
</tr>
</tbody>
</table>
<p>如果处理的是二进制文件，则需使用下面的访问模式来取代上面的访问模式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;rb&quot;, &quot;wb&quot;, &quot;ab&quot;, &quot;rb+&quot;, &quot;r+b&quot;, &quot;wb+&quot;, &quot;w+b&quot;, &quot;ab+&quot;, &quot;a+b&quot;</span><br></pre></td></tr></table></figure>
<h2 id="关闭文件"><a class="header-anchor" href="#关闭文件">¶</a>关闭文件</h2>
<p>为了关闭文件，请使用 fclose( ) 函数。函数的原型如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int fclose( FILE *fp );</span><br></pre></td></tr></table></figure>
<p>如果成功关闭文件，<strong>fclose( )</strong> 函数返回零，如果关闭文件时发生错误，函数返回 <strong>EOF</strong>。这个函数实际上，会清空缓冲区中的数据，关闭文件，并释放用于该文件的所有内存。EOF 是一个定义在头文件 <strong>stdio.h</strong> 中的常量。</p>
<p>C 标准库提供了各种函数来按字符或者以固定长度字符串的形式读写文件。</p>
<h2 id="写入文件"><a class="header-anchor" href="#写入文件">¶</a>写入文件</h2>
<p>下面是把字符写入到流中的最简单的函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputc</span><span class="params">( <span class="keyword">int</span> c, FILE *fp )</span></span>;</span><br></pre></td></tr></table></figure>
<p>函数 <strong>fputc()</strong> 把参数 c 的字符值写入到 fp 所指向的输出流中。如果写入成功，它会返回写入的字符，如果发生错误，则会返回 <strong>EOF</strong>。您可以使用下面的函数来把一个以 null 结尾的字符串写入到流中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputs</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *s, FILE *fp )</span></span>;</span><br></pre></td></tr></table></figure>
<p>函数 <strong>fputs()</strong> 把字符串 <strong>s</strong> 写入到 fp 所指向的输出流中。如果写入成功，它会返回一个非负值，如果发生错误，则会返回 <strong>EOF</strong>。您也可以使用 <strong>int fprintf(FILE *fp,const char *format, …)</strong> 函数来写把一个字符串写入到文件中。尝试下面的实例：</p>
<blockquote>
<p>**注意：**请确保您有可用的 <strong>tmp</strong> 目录，如果不存在该目录，则需要在您的计算机上先创建该目录。</p>
<p><strong>/tmp</strong> 一般是 Linux 系统上的临时目录，如果你在 Windows 系统上运行，则需要修改为本地环境中已存在的目录，例如: <strong>C:\tmp</strong>、<strong>D:\tmp</strong>等。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">   fp = fopen(<span class="string">&quot;/tmp/test.txt&quot;</span>, <span class="string">&quot;w+&quot;</span>);</span><br><span class="line">   <span class="built_in">fprintf</span>(fp, <span class="string">&quot;This is testing for fprintf...\n&quot;</span>);</span><br><span class="line">   <span class="built_in">fputs</span>(<span class="string">&quot;This is testing for fputs...\n&quot;</span>, fp);</span><br><span class="line">   fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上面的代码被编译和执行时，它会在 /tmp 目录中创建一个新的文件 <strong>test.txt</strong>，并使用两个不同的函数写入两行。接下来让我们来读取这个文件。</p>
<h2 id="读取文件"><a class="header-anchor" href="#读取文件">¶</a>读取文件</h2>
<p>下面是从文件读取单个字符的最简单的函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetc</span><span class="params">( FILE * fp )</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>fgetc()</strong> 函数从 fp 所指向的输入文件中读取一个字符。返回值是读取的字符，如果发生错误则返回 <strong>EOF</strong>。下面的函数允许您从流中读取一个字符串：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">fgets</span><span class="params">( <span class="keyword">char</span> *buf, <span class="keyword">int</span> n, FILE *fp )</span></span>;</span><br></pre></td></tr></table></figure>
<p>函数 <strong>fgets()</strong> 从 fp 所指向的输入流中读取 n - 1 个字符。它会把读取的字符串复制到缓冲区 <strong>buf</strong>，并在最后追加一个 <strong>null</strong> 字符来终止字符串。</p>
<p>如果这个函数在读取最后一个字符之前就遇到一个换行符 ‘\n’ 或文件的末尾 EOF，则只会返回读取到的字符，包括换行符。您也可以使用 <strong>int fscanf(FILE *fp, const char *format, …)</strong> 函数来从文件中读取字符串，但是在遇到第一个空格和换行符时，它会停止读取。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line">   <span class="keyword">char</span> buff[<span class="number">255</span>];</span><br><span class="line"> </span><br><span class="line">   fp = fopen(<span class="string">&quot;/tmp/test.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">   <span class="built_in">fscanf</span>(fp, <span class="string">&quot;%s&quot;</span>, buff);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;1: %s\n&quot;</span>, buff );</span><br><span class="line"> </span><br><span class="line">   fgets(buff, <span class="number">255</span>, (FILE*)fp);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;2: %s\n&quot;</span>, buff );</span><br><span class="line">   </span><br><span class="line">   fgets(buff, <span class="number">255</span>, (FILE*)fp);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;3: %s\n&quot;</span>, buff );</span><br><span class="line">   fclose(fp);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上面的代码被编译和执行时，它会读取上一部分创建的文件，产生下列结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1: This</span><br><span class="line">2: is testing for fprintf...</span><br><span class="line"></span><br><span class="line">3: This is testing for fputs...</span><br></pre></td></tr></table></figure>
<p>首先，<strong>fscanf()</strong> 方法只读取了 <strong>This</strong>，因为它在后边遇到了一个空格。其次，调用 <strong>fgets()</strong> 读取剩余的部分，直到行尾。最后，调用 <strong>fgets()</strong> 完整地读取第二行。</p>
<h2 id="二进制-I-O-函数"><a class="header-anchor" href="#二进制-I-O-函数">¶</a>二进制 I/O 函数</h2>
<p>下面两个函数用于二进制输入和输出：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fread</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size_of_elements, </span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">size_t</span> number_of_elements, FILE *a_file)</span></span>;</span><br><span class="line">              </span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fwrite</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size_of_elements, </span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">size_t</span> number_of_elements, FILE *a_file)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这两个函数都是用于存储块的读写 - 通常是数组或结构体。</p>
</blockquote>
<h1>C 预处理器</h1>
<p><strong>C 预处理器</strong>不是编译器的组成部分，但是它是编译过程中一个单独的步骤。简言之，C 预处理器只不过是一个文本替换工具而已，它们会指示编译器在实际编译之前完成所需的预处理。我们将把 C 预处理器（C Preprocessor）简写为 CPP。</p>
<p>所有的预处理器命令都是以井号（#）开头。它必须是第一个非空字符，为了增强可读性，预处理器指令应从第一列开始。下面列出了所有重要的预处理器指令：</p>
<table>
<thead>
<tr>
<th style="text-align:left">指令</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">#define</td>
<td style="text-align:left">定义宏</td>
</tr>
<tr>
<td style="text-align:left">#include</td>
<td style="text-align:left">包含一个源代码文件</td>
</tr>
<tr>
<td style="text-align:left">#undef</td>
<td style="text-align:left">取消已定义的宏</td>
</tr>
<tr>
<td style="text-align:left">#ifdef</td>
<td style="text-align:left">如果宏已经定义，则返回真</td>
</tr>
<tr>
<td style="text-align:left">#ifndef</td>
<td style="text-align:left">如果宏没有定义，则返回真</td>
</tr>
<tr>
<td style="text-align:left">#if</td>
<td style="text-align:left">如果给定条件为真，则编译下面代码</td>
</tr>
<tr>
<td style="text-align:left">#else</td>
<td style="text-align:left">#if 的替代方案</td>
</tr>
<tr>
<td style="text-align:left">#elif</td>
<td style="text-align:left">如果前面的 #if 给定条件不为真，当前条件为真，则编译下面代码</td>
</tr>
<tr>
<td style="text-align:left">#endif</td>
<td style="text-align:left">结束一个 #if……#else 条件编译块</td>
</tr>
<tr>
<td style="text-align:left">#error</td>
<td style="text-align:left">当遇到标准错误时，输出错误消息</td>
</tr>
<tr>
<td style="text-align:left">#pragma</td>
<td style="text-align:left">使用标准化方法，向编译器发布特殊的命令到编译器中</td>
</tr>
</tbody>
</table>
<h2 id="预处理器实例"><a class="header-anchor" href="#预处理器实例">¶</a>预处理器实例</h2>
<p>分析下面的实例来理解不同的指令。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ARRAY_LENGTH 20</span></span><br></pre></td></tr></table></figure>
<p>这个指令告诉 CPP 把所有的 MAX_ARRAY_LENGTH 替换为 20。使用 <em>#define</em> 定义常量来增强可读性。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;myheader.h&quot;</span></span></span><br></pre></td></tr></table></figure>
<p>这些指令告诉 CPP 从<strong>系统库</strong>中获取 stdio.h，并添加文本到当前的源文件中。下一行告诉 CPP 从本地目录中获取 <strong>myheader.h</strong>，并添加内容到当前的源文件中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">undef</span>  FILE_SIZE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_SIZE 42</span></span><br></pre></td></tr></table></figure>
<p>这个指令告诉 CPP 取消已定义的 FILE_SIZE，并定义它为 42。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MESSAGE</span></span><br><span class="line">   <span class="meta">#<span class="meta-keyword">define</span> MESSAGE <span class="meta-string">&quot;You wish!&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>这个指令告诉 CPP 只有当 MESSAGE 未定义时，才定义 MESSAGE。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">   <span class="comment">/* Your debugging statements here */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>这个指令告诉 CPP 如果定义了 DEBUG，则执行处理语句。在编译时，如果您向 gcc 编译器传递了 <em>-DDEBUG</em> 开关量，这个指令就非常有用。它定义了 DEBUG，您可以在编译期间随时开启或关闭调试。</p>
<h2 id="预定义宏"><a class="header-anchor" href="#预定义宏">¶</a>预定义宏</h2>
<p>ANSI C 定义了许多宏。在编程中您可以使用这些宏，但是不能直接修改这些预定义的宏。</p>
<table>
<thead>
<tr>
<th style="text-align:left">宏</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>DATE</strong></td>
<td style="text-align:left">当前日期，一个以 “MMM DD YYYY” 格式表示的字符常量。</td>
</tr>
<tr>
<td style="text-align:left"><strong>TIME</strong></td>
<td style="text-align:left">当前时间，一个以 “HH:MM:SS” 格式表示的字符常量。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE</strong></td>
<td style="text-align:left">这会包含当前文件名，一个字符串常量。</td>
</tr>
<tr>
<td style="text-align:left"><strong>LINE</strong></td>
<td style="text-align:left">这会包含当前行号，一个十进制常量。</td>
</tr>
<tr>
<td style="text-align:left"><strong>STDC</strong></td>
<td style="text-align:left">当编译器以 ANSI 标准编译时，则定义为 1。</td>
</tr>
</tbody>
</table>
<p>让我们来尝试下面的实例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;File :%s\n&quot;</span>, __FILE__ );</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Date :%s\n&quot;</span>, __DATE__ );</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Time :%s\n&quot;</span>, __TIME__ );</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line :%d\n&quot;</span>, __LINE__ );</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;ANSI :%d\n&quot;</span>, __STDC__ );</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上面的代码（在文件 <strong>test.c</strong> 中）被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">File :test.c</span><br><span class="line">Date :Jun <span class="number">2</span> <span class="number">2012</span></span><br><span class="line">Time :<span class="number">03</span>:<span class="number">36</span>:<span class="number">24</span></span><br><span class="line">Line :<span class="number">8</span></span><br><span class="line">ANSI :<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="预处理器运算符"><a class="header-anchor" href="#预处理器运算符">¶</a>预处理器运算符</h2>
<p>C 预处理器提供了下列的运算符来帮助您创建宏：</p>
<h5 id="宏延续运算符（-）"><a class="header-anchor" href="#宏延续运算符（-）">¶</a>宏延续运算符（\）</h5>
<p>一个宏通常写在一个单行上。但是如果宏太长，一个单行容纳不下，则使用宏延续运算符（\）。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  message_for(a, b)  \</span></span><br><span class="line">    <span class="built_in">printf</span>(#a <span class="string">&quot; and &quot;</span> #b <span class="string">&quot;: We love you!\n&quot;</span>)</span><br></pre></td></tr></table></figure>
<h5 id="字符串常量化运算符（-）"><a class="header-anchor" href="#字符串常量化运算符（-）">¶</a>字符串常量化运算符（#）</h5>
<p>在宏定义中，当需要把一个宏的参数转换为字符串常量时，则使用字符串常量化运算符（#）。在宏中使用的该运算符有一个特定的参数或参数列表。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  message_for(a, b)  \</span></span><br><span class="line">    <span class="built_in">printf</span>(#a <span class="string">&quot; and &quot;</span> #b <span class="string">&quot;: We love you!\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   message_for(Carole, Debra);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Carole <span class="keyword">and</span> Debra: We love you!</span><br></pre></td></tr></table></figure>
<h5 id="标记粘贴运算符（-）"><a class="header-anchor" href="#标记粘贴运算符（-）">¶</a>标记粘贴运算符（##）</h5>
<p>宏定义内的标记粘贴运算符（##）会合并两个参数。它允许在宏定义中两个独立的标记被合并为一个标记。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> tokenpaster(n) printf (<span class="meta-string">&quot;token&quot;</span> #n <span class="meta-string">&quot; = %d&quot;</span>, token##n)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> token34 = <span class="number">40</span>;</span><br><span class="line">   </span><br><span class="line">   tokenpaster(<span class="number">34</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">token34 = <span class="number">40</span></span><br></pre></td></tr></table></figure>
<p>这是怎么发生的，因为这个实例会从编译器产生下列的实际输出：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;token34 = %d&quot;</span>, token34);</span><br></pre></td></tr></table></figure>
<p>这个实例演示了 token##n 会连接到 token34 中，在这里，我们使用了<strong>字符串常量化运算符（#）<strong>和</strong>标记粘贴运算符（##）</strong>。</p>
<h5 id="defined-运算符"><a class="header-anchor" href="#defined-运算符">¶</a>defined() 运算符</h5>
<p>预处理器 <strong>defined</strong> 运算符是用在常量表达式中的，用来确定一个标识符是否已经使用 #define 定义过。如果指定的标识符已定义，则值为真（非零）。如果指定的标识符未定义，则值为假（零）。下面的实例演示了 defined() 运算符的用法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined (MESSAGE)</span></span><br><span class="line">   <span class="meta">#<span class="meta-keyword">define</span> MESSAGE <span class="meta-string">&quot;You wish!&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Here is the message: %s\n&quot;</span>, MESSAGE);  </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Here is the message: You wish!</span><br></pre></td></tr></table></figure>
<h2 id="参数化的宏"><a class="header-anchor" href="#参数化的宏">¶</a>参数化的宏</h2>
<p>CPP 一个强大的功能是可以使用参数化的宏来模拟函数。例如，下面的代码是计算一个数的平方：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">square</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以使用宏重写上面的代码，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> square(x) ((x) * (x))</span></span><br></pre></td></tr></table></figure>
<p>在使用带有参数的宏之前，必须使用 <strong>#define</strong> 指令定义。参数列表是括在圆括号内，且必须紧跟在宏名称的后边。宏名称和左圆括号之间不允许有空格。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(x,y) ((x) &gt; (y) ? (x) : (y))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Max between 20 and 10 is %d\n&quot;</span>, MAX(<span class="number">10</span>, <span class="number">20</span>));  </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Max between <span class="number">20</span> <span class="keyword">and</span> <span class="number">10</span> is <span class="number">20</span></span><br></pre></td></tr></table></figure>
<h1>C 头文件</h1>
<p>头文件是扩展名为 <strong>.h</strong> 的文件，包含了 C 函数声明和宏定义，被多个源文件中引用共享。有两种类型的头文件：程序员编写的头文件和编译器自带的头文件。</p>
<p>在程序中要使用头文件，需要使用 C 预处理指令 <strong>#include</strong> 来引用它。前面我们已经看过 <strong>stdio.h</strong> 头文件，它是编译器自带的头文件。</p>
<p>引用头文件相当于复制头文件的内容，但是我们不会直接在源文件中复制头文件的内容，因为这么做很容易出错，特别在程序是由多个源文件组成的时候。</p>
<p>A simple practice in C 或 C++ 程序中，建议把所有的常量、宏、系统全局变量和函数原型写在头文件中，在需要的时候随时引用这些头文件。</p>
<h2 id="引用头文件的语法"><a class="header-anchor" href="#引用头文件的语法">¶</a>引用头文件的语法</h2>
<p>使用预处理指令 <strong>#include</strong> 可以引用用户和系统头文件。它的形式有以下两种：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;file&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>这种形式用于引用系统头文件。它在系统目录的标准列表中搜索名为 file 的文件。在编译源代码时，您可以通过 -I 选项把目录前置在该列表前。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;file&quot;</span></span></span><br></pre></td></tr></table></figure>
<p>这种形式用于引用用户头文件。它在包含当前文件的目录中搜索名为 file 的文件。在编译源代码时，您可以通过 -I 选项把目录前置在该列表前。</p>
<h2 id="引用头文件的操作"><a class="header-anchor" href="#引用头文件的操作">¶</a>引用头文件的操作</h2>
<p><strong>#include</strong> 指令会指示 C 预处理器浏览指定的文件作为输入。预处理器的输出包含了已经生成的输出，被引用文件生成的输出以及 <strong>#include</strong> 指令之后的文本输出。例如，如果您有一个头文件 header.h，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">test</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>和一个使用了头文件的主程序 <em>program.c</em>，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;header.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">puts</span> (test ());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器会看到如下的代码信息：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">test</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">puts</span> (test ());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="只引用一次头文件"><a class="header-anchor" href="#只引用一次头文件">¶</a>只引用一次头文件</h2>
<p>如果一个头文件被引用两次，编译器会处理两次头文件的内容，这将产生错误。为了防止这种情况，标准的做法是把文件的整个内容放在条件编译语句中，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HEADER_FILE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEADER_FILE</span></span><br><span class="line"></span><br><span class="line">the entire header file file</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>这种结构就是通常所说的包装器 <strong>#ifndef</strong>。当再次引用头文件时，条件为假，因为 HEADER_FILE 已定义。此时，预处理器会跳过文件的整个内容，编译器会忽略它。</p>
<h2 id="有条件引用"><a class="header-anchor" href="#有条件引用">¶</a>有条件引用</h2>
<p>有时需要从多个不同的头文件中选择一个引用到程序中。例如，需要指定在不同的操作系统上使用的配置参数。您可以通过一系列条件来实现这点，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SYSTEM_1</span></span><br><span class="line">   <span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&quot;system_1.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> SYSTEM_2</span></span><br><span class="line">   <span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&quot;system_2.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> SYSTEM_3</span></span><br><span class="line">   ...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>但是如果头文件比较多的时候，这么做是很不妥当的，预处理器使用宏来定义头文件的名称。这就是所谓的<strong>有条件引用</strong>。它不是用头文件的名称作为 <strong>#include</strong> 的直接参数，您只需要使用宏名称代替即可：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSTEM_H <span class="meta-string">&quot;system_1.h&quot;</span></span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> SYSTEM_H</span></span><br></pre></td></tr></table></figure>
<p>SYSTEM_H 会扩展，预处理器会查找 system_1.h，就像 <strong>#include</strong> 最初编写的那样。SYSTEM_H 可通过 -D 选项被您的 Makefile 定义。</p>
<h1>C 强制类型转换</h1>
<p>强制类型转换是把变量从一种类型转换为另一种数据类型。例如，如果您想存储一个 long 类型的值到一个简单的整型中，您需要把 long 类型强制转换为 int 类型。您可以使用<strong>强制类型转换运算符</strong>来把值显式地从一种类型转换为另一种类型，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(type_name) expression</span><br></pre></td></tr></table></figure>
<p>请看下面的实例，使用强制类型转换运算符把一个整数变量除以另一个整数变量，得到一个浮点数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> sum = <span class="number">17</span>, count = <span class="number">5</span>;</span><br><span class="line">   <span class="keyword">double</span> mean;</span><br><span class="line"> </span><br><span class="line">   mean = (<span class="keyword">double</span>) sum / count;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Value of mean : %f\n&quot;</span>, mean );</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Value of mean : 3.400000</span><br></pre></td></tr></table></figure>
<p>这里要注意的是强制类型转换运算符的优先级大于除法，因此 <strong>sum</strong> 的值首先被转换为 <strong>double</strong> 型，然后除以 count，得到一个类型为 double 的值。</p>
<p>类型转换可以是隐式的，由编译器自动执行，也可以是显式的，通过使用<strong>强制类型转换运算符</strong>来指定。在编程时，有需要类型转换的时候都用上强制类型转换运算符，是一种良好的编程习惯。</p>
<h2 id="整数提升"><a class="header-anchor" href="#整数提升">¶</a>整数提升</h2>
<p>整数提升是指把小于 <strong>int</strong> 或 <strong>unsigned int</strong> 的整数类型转换为 <strong>int</strong> 或 <strong>unsigned int</strong> 的过程。请看下面的实例，在 int 中添加一个字符：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span>  i = <span class="number">17</span>;</span><br><span class="line">   <span class="keyword">char</span> c = <span class="string">&#x27;c&#x27;</span>; <span class="comment">/* ascii 值是 99 */</span></span><br><span class="line">   <span class="keyword">int</span> sum;</span><br><span class="line"> </span><br><span class="line">   sum = i + c;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Value of sum : %d\n&quot;</span>, sum );</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Value of sum : 116</span><br></pre></td></tr></table></figure>
<p>在这里，sum 的值为 116，因为编译器进行了整数提升，在执行实际加法运算时，把 ‘c’ 的值转换为对应的 ascii 值。</p>
<h2 id="常用的算术转换"><a class="header-anchor" href="#常用的算术转换">¶</a>常用的算术转换</h2>
<p><strong>常用的算术转换</strong>是隐式地把值强制转换为相同的类型。编译器首先执行<strong>整数提升</strong>，如果操作数类型不同，则它们会被转换为下列层次中出现的最高层次的类型：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/stardust14/picture/img/20200916210142.png" alt="Usual Arithmetic Conversion"></p>
<p>常用的算术转换不适用于赋值运算符、逻辑运算符 &amp;&amp; 和 ||。让我们看看下面的实例来理解这个概念：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span>  i = <span class="number">17</span>;</span><br><span class="line">   <span class="keyword">char</span> c = <span class="string">&#x27;c&#x27;</span>; <span class="comment">/* ascii 值是 99 */</span></span><br><span class="line">   <span class="keyword">float</span> sum;</span><br><span class="line"> </span><br><span class="line">   sum = i + c;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Value of sum : %f\n&quot;</span>, sum );</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Value of sum : 116.000000</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在这里，c 首先被转换为整数，但是由于最后的值是 float 型的，所以会应用常用的算术转换，编译器会把 i 和 c 转换为浮点型，并把它们相加得到一个浮点数。</p>
</blockquote>
<h1>C 错误处理</h1>
<p>C 语言不提供对错误处理的直接支持，但是作为一种系统编程语言，它以返回值的形式允许您访问底层数据。在发生错误时，大多数的 C 或 UNIX 函数调用返回 1 或 NULL，同时会设置一个错误代码 <strong>errno</strong>，该错误代码是全局变量，表示在函数调用期间发生了错误。您可以在 errno.h 头文件中找到各种各样的错误代码。</p>
<p>所以，C 程序员可以通过检查返回值，然后根据返回值决定采取哪种适当的动作。开发人员应该在程序初始化时，把 errno 设置为 0，这是一种良好的编程习惯。0 值表示程序中没有错误。</p>
<h2 id="errno、perror-和-strerror"><a class="header-anchor" href="#errno、perror-和-strerror">¶</a>errno、perror() 和 strerror()</h2>
<p>C 语言提供了 <strong>perror()</strong> 和 <strong>strerror()</strong> 函数来显示与 <strong>errno</strong> 相关的文本消息。</p>
<ul>
<li><strong>perror()</strong> 函数显示您传给它的字符串，后跟一个冒号、一个空格和当前 errno 值的文本表示形式。</li>
<li><strong>strerror()</strong> 函数，返回一个指针，指针指向当前 errno 值的文本表示形式。</li>
</ul>
<p>让我们来模拟一种错误情况，尝试打开一个不存在的文件。可以使用多种方式来输出错误消息，在这里我们使用函数来演示用法。另外有一点需要注意，应该使用 <strong>stderr</strong> 文件流来输出所有的错误。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> errno ;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   FILE * pf;</span><br><span class="line">   <span class="keyword">int</span> errnum;</span><br><span class="line">   pf = fopen (<span class="string">&quot;unexist.txt&quot;</span>, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">   <span class="keyword">if</span> (pf == <span class="literal">NULL</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      errnum = errno;</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;错误号: %d\n&quot;</span>, errno);</span><br><span class="line">      perror(<span class="string">&quot;通过 perror 输出错误&quot;</span>);</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;打开文件错误: %s\n&quot;</span>, strerror( errnum ));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">      fclose (pf);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">错误号: <span class="number">2</span></span><br><span class="line">通过 perror 输出错误: No such file <span class="keyword">or</span> directory</span><br><span class="line">打开文件错误: No such file <span class="keyword">or</span> directory</span><br></pre></td></tr></table></figure>
<h2 id="被零除的错误"><a class="header-anchor" href="#被零除的错误">¶</a>被零除的错误</h2>
<p>在进行除法运算时，如果不检查除数是否为零，则会导致一个运行时错误。</p>
<p>为了避免这种情况发生，下面的代码在进行除法运算前会先检查除数是否为零：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">int</span> dividend = <span class="number">20</span>;</span><br><span class="line">   <span class="keyword">int</span> divisor = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> quotient;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">if</span>( divisor == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;除数为 0 退出运行...\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   quotient = dividend / divisor;</span><br><span class="line">   <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;quotient 变量的值为 : %d\n&quot;</span>, quotient );</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">除数为 0 退出运行...</span><br></pre></td></tr></table></figure>
<h2 id="程序退出状态"><a class="header-anchor" href="#程序退出状态">¶</a>程序退出状态</h2>
<p>通常情况下，程序成功执行完一个操作正常退出的时候会带有值 EXIT_SUCCESS。在这里，EXIT_SUCCESS 是宏，它被定义为 0。</p>
<p>如果程序中存在一种错误情况，当您退出程序时，会带有状态值 EXIT_FAILURE，被定义为 -1。所以，上面的程序可以写成：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">int</span> dividend = <span class="number">20</span>;</span><br><span class="line">   <span class="keyword">int</span> divisor = <span class="number">5</span>;</span><br><span class="line">   <span class="keyword">int</span> quotient;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">if</span>( divisor == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;除数为 0 退出运行...\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">   &#125;</span><br><span class="line">   quotient = dividend / divisor;</span><br><span class="line">   <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;quotient 变量的值为: %d\n&quot;</span>, quotient );</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">quotient 变量的值为 : <span class="number">4</span></span><br></pre></td></tr></table></figure>
<h1>C 递归</h1>
<p>递归指的是在函数的定义中使用函数自身的方法。</p>
<blockquote>
<p>举个例子：<br>
从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？“从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？‘从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？……’”</p>
</blockquote>
<p>语法格式如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">void recursion()</span><br><span class="line">&#123;</span><br><span class="line">   statements;</span><br><span class="line">   ... ... ...</span><br><span class="line">   recursion(); /<span class="emphasis">* 函数调用自身 *</span>/</span><br><span class="line">   ... ... ...</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   recursion();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>流程图：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/stardust14/picture/img/20200916210456.png" alt="img"></p>
<p>C 语言支持递归，即一个函数可以调用其自身。但在使用递归时，程序员需要注意定义一个从函数退出的条件，否则会进入死循环。</p>
<p>递归函数在解决许多数学问题上起了至关重要的作用，比如计算一个数的阶乘、生成斐波那契数列，等等。</p>
<h2 id="数的阶乘"><a class="header-anchor" href="#数的阶乘">¶</a>数的阶乘</h2>
<p>下面的实例使用递归函数计算一个给定的数的阶乘：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">factorial</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(i &lt;= <span class="number">1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> i * factorial(i - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">15</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d 的阶乘为 %f\n&quot;</span>, i, factorial(i));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">15 的阶乘为 1307674368000.000000</span><br></pre></td></tr></table></figure>
<h2 id="斐波那契数列"><a class="header-anchor" href="#斐波那契数列">¶</a>斐波那契数列</h2>
<p>下面的实例使用递归函数生成一个给定的数的斐波那契数列：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fibonaci</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(i == <span class="number">1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> fibonaci(i<span class="number">-1</span>) + fibonaci(i<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;%d\t\n&quot;</span>, fibonaci(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>    </span><br><span class="line"><span class="number">1</span>    </span><br><span class="line"><span class="number">1</span>    </span><br><span class="line"><span class="number">2</span>    </span><br><span class="line"><span class="number">3</span>    </span><br><span class="line"><span class="number">5</span>    </span><br><span class="line"><span class="number">8</span>    </span><br><span class="line"><span class="number">13</span>    </span><br><span class="line"><span class="number">21</span>    </span><br><span class="line"><span class="number">34</span></span><br></pre></td></tr></table></figure>
<h1>C 可变参数</h1>
<p>有时，可能会碰到这样的情况，希望函数带有可变数量的参数，而不是预定义数量的参数。C 语言为这种情况提供了一个解决方案，它允许定义一个函数，能根据具体的需求接受可变数量的参数。下面的实例演示了这种函数的定义。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>, ... )</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   .</span><br><span class="line">   .</span><br><span class="line">   .</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   func(<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">   func(<span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，函数 <strong>func()</strong> 最后一个参数写成省略号，即三个点号（<strong>…</strong>），省略号之前的那个参数是 <strong>int</strong>，代表了要传递的可变参数的总数。为了使用这个功能，您需要使用 <strong>stdarg.h</strong> 头文件，该文件提供了实现可变参数功能的函数和宏。具体步骤如下：</p>
<ul>
<li>定义一个函数，最后一个参数为省略号，省略号前面可以设置自定义参数。</li>
<li>在函数定义中创建一个 <strong>va_list</strong> 类型变量，该类型是在 stdarg.h 头文件中定义的。</li>
<li>使用 <strong>int</strong> 参数和 <strong>va_start</strong> 宏来初始化 <strong>va_list</strong> 变量为一个参数列表。宏 va_start 是在 stdarg.h 头文件中定义的。</li>
<li>使用 <strong>va_arg</strong> 宏和 <strong>va_list</strong> 变量来访问参数列表中的每个项。</li>
<li>使用宏 <strong>va_end</strong> 来清理赋予 <strong>va_list</strong> 变量的内存。</li>
</ul>
<p>现在让我们按照上面的步骤，来编写一个带有可变数量参数的函数，并返回它们的平均值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">average</span><span class="params">(<span class="keyword">int</span> num,...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">    va_list valist;</span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 为 num 个参数初始化 valist */</span></span><br><span class="line">    va_start(valist, num);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 访问所有赋给 valist 的参数 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">       sum += va_arg(valist, <span class="keyword">int</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 清理为 valist 保留的内存 */</span></span><br><span class="line">    va_end(valist);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> sum/num;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Average of 2, 3, 4, 5 = %f\n&quot;</span>, average(<span class="number">4</span>, <span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>));</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Average of 5, 10, 15 = %f\n&quot;</span>, average(<span class="number">3</span>, <span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上面的代码被编译和执行时，它会产生下列结果。应该指出的是，函数 <strong>average()</strong> 被调用两次，每次第一个参数都是表示被传的可变参数的总数。省略号被用来传递可变数量的参数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Average of <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> = <span class="number">3.500000</span></span><br><span class="line">Average of <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span> = <span class="number">10.000000</span></span><br></pre></td></tr></table></figure>
<h1>C 内存管理</h1>
<p>C 语言为内存的分配和管理提供了几个函数。这些函数可以在 <strong>&lt;stdlib.h&gt;</strong> 头文件中找到。</p>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">函数和描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><strong>void *calloc(int num, int size);</strong> 在内存中动态地分配 num 个长度为 size 的连续空间，并将每一个字节都初始化为 0。所以它的结果是分配了 num*size 个字节长度的内存空间，并且每个字节的值都是0。</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><strong>void free(void *address);</strong> 该函数释放 address 所指向的内存块,释放的是动态分配的内存空间。</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><strong>void *malloc(int num);</strong> 在堆区分配一块指定大小的内存空间，用来存放数据。这块内存空间在函数执行完成后不会被初始化，它们的值是未知的。</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left"><strong>void *realloc(void *address, int newsize);</strong> 该函数重新分配内存，把内存扩展到 <strong>newsize</strong>。</td>
</tr>
</tbody>
</table>
<p>**注意：**void * 类型表示未确定类型的指针。C、C++ 规定 void * 类型可以通过类型转换强制转换为任何其它类型的指针。</p>
<h2 id="动态分配内存"><a class="header-anchor" href="#动态分配内存">¶</a>动态分配内存</h2>
<p>编程时，如果预先知道数组的大小，那么定义数组时就比较容易。例如，一个存储人名的数组，它最多容纳 100 个字符，所以您可以定义数组，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> name[<span class="number">100</span>];</span><br></pre></td></tr></table></figure>
<p>但是，如果预先不知道需要存储的文本长度，例如想存储有关一个主题的详细描述。在这里，需要定义一个指针，该指针指向未定义所需内存大小的字符，后续再根据需求来分配内存，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">char</span> name[<span class="number">100</span>];</span><br><span class="line">   <span class="keyword">char</span> *description;</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">strcpy</span>(name, <span class="string">&quot;Zara Ali&quot;</span>);</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 动态分配内存 */</span></span><br><span class="line">   description = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>( <span class="number">200</span> * <span class="keyword">sizeof</span>(<span class="keyword">char</span>) );</span><br><span class="line">   <span class="keyword">if</span>( description == <span class="literal">NULL</span> )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error - unable to allocate required memory\n&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">strcpy</span>( description, <span class="string">&quot;Zara ali a DPS student in class 10th&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Name = %s\n&quot;</span>, name );</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Description: %s\n&quot;</span>, description );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Name = Zara Ali</span><br><span class="line">Description: Zara ali a DPS student in class <span class="number">10</span>th</span><br></pre></td></tr></table></figure>
<p>上面的程序也可以使用 <strong>calloc()</strong> 来编写，只需要把 malloc 替换为 calloc 即可，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">calloc</span>(<span class="number">200</span>, <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br></pre></td></tr></table></figure>
<p>当动态分配内存时，有完全控制权，可以传递任何大小的值。而那些预先定义了大小的数组，一旦定义则无法改变大小。</p>
<h2 id="重新调整内存的大小和释放内存"><a class="header-anchor" href="#重新调整内存的大小和释放内存">¶</a>重新调整内存的大小和释放内存</h2>
<p>当程序退出时，操作系统会自动释放所有分配给程序的内存，但是，建议您在不需要内存时，都应该调用函数 <strong>free()</strong> 来释放内存。</p>
<p>或者，可以通过调用函数 <strong>realloc()</strong> 来增加或减少已分配的内存块的大小。让我们使用 realloc() 和 free() 函数，再次查看上面的实例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">char</span> name[<span class="number">100</span>];</span><br><span class="line">   <span class="keyword">char</span> *description;</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">strcpy</span>(name, <span class="string">&quot;Zara Ali&quot;</span>);</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 动态分配内存 */</span></span><br><span class="line">   description = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>( <span class="number">30</span> * <span class="keyword">sizeof</span>(<span class="keyword">char</span>) );</span><br><span class="line">   <span class="keyword">if</span>( description == <span class="literal">NULL</span> )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error - unable to allocate required memory\n&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">strcpy</span>( description, <span class="string">&quot;Zara ali a DPS student.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/* 假设您想要存储更大的描述信息 */</span></span><br><span class="line">   description = (<span class="keyword">char</span> *) <span class="built_in">realloc</span>( description, <span class="number">100</span> * <span class="keyword">sizeof</span>(<span class="keyword">char</span>) );</span><br><span class="line">   <span class="keyword">if</span>( description == <span class="literal">NULL</span> )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error - unable to allocate required memory\n&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">strcat</span>( description, <span class="string">&quot;She is in class 10th&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Name = %s\n&quot;</span>, name );</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Description: %s\n&quot;</span>, description );</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 使用 free() 函数释放内存 */</span></span><br><span class="line">   <span class="built_in">free</span>(description);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Name = Zara Ali</span><br><span class="line">Description: Zara ali a DPS student.She is in class <span class="number">10</span>th</span><br></pre></td></tr></table></figure>
<p>可以尝试一下不重新分配额外的内存，strcat() 函数会生成一个错误，因为存储 description 时可用的内存不足。</p>
<h1>C 命令行参数</h1>
<p>执行程序时，可以从命令行传值给 C 程序。这些值被称为<strong>命令行参数</strong>，它们对程序很重要，特别是当您想从外部控制程序，而不是在代码内对这些值进行硬编码时，就显得尤为重要了。</p>
<p>命令行参数是使用 main() 函数参数来处理的，其中，<strong>argc</strong> 是指传入参数的个数，<strong>argv[]</strong> 是一个指针数组，指向传递给程序的每个参数。下面是一个简单的实例，检查命令行是否有提供参数，并根据参数执行相应的动作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[] )</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>( argc == <span class="number">2</span> )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;The argument supplied is %s\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>( argc &gt; <span class="number">2</span> )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Too many arguments supplied.\n&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;One argument expected.\n&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用一个参数，编译并执行上面的代码，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$./a.out testing</span><br><span class="line">The argument supplied is testing</span><br></pre></td></tr></table></figure>
<p>使用两个参数，编译并执行上面的代码，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$./a.out testing1 testing2</span><br><span class="line">Too many arguments supplied.</span><br></pre></td></tr></table></figure>
<p>不传任何参数，编译并执行上面的代码，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$./a.out</span><br><span class="line">One argument expected</span><br></pre></td></tr></table></figure>
<p>应当指出的是，<strong>argv[0]</strong> 存储程序的名称，<strong>argv[1]</strong> 是一个指向第一个命令行参数的指针，*argv[n] 是最后一个参数。如果没有提供任何参数，argc 将为 1，否则，如果传递了一个参数，<strong>argc</strong> 将被设置为 2。</p>
<p>多个命令行参数之间用空格分隔，但是如果参数本身带有空格，那么传递参数的时候应把参数放置在双引号 “” 或单引号 ‘’ 内部。让我们重新编写上面的实例，有一个空间，那么你可以通过这样的观点，把它们放在双引号或单引号&quot;&quot;&quot;&quot;。让我们重新编写上面的实例，向程序传递一个放置在双引号内部的命令行参数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[] )</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Program name %s\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">if</span>( argc == <span class="number">2</span> )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;The argument supplied is %s\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>( argc &gt; <span class="number">2</span> )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Too many arguments supplied.\n&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;One argument expected.\n&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用一个用空格分隔的简单参数，参数括在双引号中，编译并执行上面的代码，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$./a.out <span class="string">&quot;testing1 testing2&quot;</span></span><br><span class="line"></span><br><span class="line">Progranm name ./a.out</span><br><span class="line">The argument supplied is testing1 testing2</span><br></pre></td></tr></table></figure>
<h1>C 排序算法</h1>
<h3 id="冒泡排序"><a class="header-anchor" href="#冒泡排序">¶</a>冒泡排序</h3>
<p>冒泡排序（英语：Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序（如从大到小、首字母从A到Z）错误就把他们交换过来。</p>
<p>过程演示:</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/stardust14/picture/img/20200916211627.gif" alt="img"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, temp;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++)</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123; <span class="number">22</span>, <span class="number">34</span>, <span class="number">3</span>, <span class="number">32</span>, <span class="number">82</span>, <span class="number">55</span>, <span class="number">89</span>, <span class="number">50</span>, <span class="number">37</span>, <span class="number">5</span>, <span class="number">64</span>, <span class="number">35</span>, <span class="number">9</span>, <span class="number">70</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> len = (<span class="keyword">int</span>) <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(*arr);</span><br><span class="line">    bubble_sort(arr, len);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="选择排序"><a class="header-anchor" href="#选择排序">¶</a>选择排序</h3>
<p>选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<p>过程演示：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/stardust14/picture/img/20200916211934.gif" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/stardust14/picture/img/20200916211942.gif" alt="img"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> *b)</span> <span class="comment">//交換兩個變數</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; len - <span class="number">1</span> ; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> min = i;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; len; j++)     <span class="comment">//走訪未排序的元素</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[min])    <span class="comment">//找到目前最小值</span></span><br><span class="line">                min = j;    <span class="comment">//紀錄最小值</span></span><br><span class="line">           swap(&amp;arr[min], &amp;arr[i]);    <span class="comment">//做交換</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插入排序"><a class="header-anchor" href="#插入排序">¶</a>插入排序</h3>
<p>插入排序（英语：Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到 {\displaystyle O(1)} {\displaystyle O(1)}的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后</p>
<p>挪位，为最新元素提供插入空间。</p>
<p>过程演示：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/stardust14/picture/img/20200916212129.gif" alt="img"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertion_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,temp;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">            temp = arr[i];</span><br><span class="line">            <span class="keyword">for</span> (j=i;j&gt;<span class="number">0</span> &amp;&amp; arr[j<span class="number">-1</span>]&gt;temp;j--)</span><br><span class="line">                    arr[j] = arr[j<span class="number">-1</span>];</span><br><span class="line">            arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="希尔排序"><a class="header-anchor" href="#希尔排序">¶</a>希尔排序</h3>
<p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。</p>
<p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>
<ul>
<li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率</li>
<li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位</li>
</ul>
<p>过程演示：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/stardust14/picture/img/20200916212044.gif" alt="img"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> gap, i, j;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span> (gap = len &gt;&gt; <span class="number">1</span>; gap &gt; <span class="number">0</span>; gap = gap &gt;&gt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> (i = gap; i &lt; len; i++) &#123;</span><br><span class="line">            temp = arr[i];</span><br><span class="line">            <span class="keyword">for</span> (j = i - gap; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp; j -= gap)</span><br><span class="line">                arr[j + gap] = arr[j];</span><br><span class="line">            arr[j + gap] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="归并排序"><a class="header-anchor" href="#归并排序">¶</a>归并排序</h3>
<p>把数据分为两段，从两段中逐个选最小的元素移入新数据段的末尾。</p>
<p>可从上到下或从下到上进行。</p>
<p>过程演示：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/stardust14/picture/img/20200916212112.gif" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/stardust14/picture/img/20200916212119.gif" alt="img"></p>
<h4 id="迭代法"><a class="header-anchor" href="#迭代法">¶</a>迭代法</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt; y ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* a = arr;</span><br><span class="line">    <span class="keyword">int</span>* b = (<span class="keyword">int</span>*) <span class="built_in">malloc</span>(len * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">int</span> seg, start;</span><br><span class="line">    <span class="keyword">for</span> (seg = <span class="number">1</span>; seg &lt; len; seg += seg) &#123;</span><br><span class="line">        <span class="keyword">for</span> (start = <span class="number">0</span>; start &lt; len; start += seg + seg) &#123;</span><br><span class="line">            <span class="keyword">int</span> low = start, mid = min(start + seg, len), high = min(start + seg + seg, len);</span><br><span class="line">            <span class="keyword">int</span> k = low;</span><br><span class="line">            <span class="keyword">int</span> start1 = low, end1 = mid;</span><br><span class="line">            <span class="keyword">int</span> start2 = mid, end2 = high;</span><br><span class="line">            <span class="keyword">while</span> (start1 &lt; end1 &amp;&amp; start2 &lt; end2)</span><br><span class="line">                b[k++] = a[start1] &lt; a[start2] ? a[start1++] : a[start2++];</span><br><span class="line">            <span class="keyword">while</span> (start1 &lt; end1)</span><br><span class="line">                b[k++] = a[start1++];</span><br><span class="line">            <span class="keyword">while</span> (start2 &lt; end2)</span><br><span class="line">                b[k++] = a[start2++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>* temp = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a != arr) &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">            b[i] = a[i];</span><br><span class="line">        b = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="递归法"><a class="header-anchor" href="#递归法">¶</a>递归法</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort_recursive</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> reg[], <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> len = end - start, mid = (len &gt;&gt; <span class="number">1</span>) + start;</span><br><span class="line">    <span class="keyword">int</span> start1 = start, end1 = mid;</span><br><span class="line">    <span class="keyword">int</span> start2 = mid + <span class="number">1</span>, end2 = end;</span><br><span class="line">    merge_sort_recursive(arr, reg, start1, end1);</span><br><span class="line">    merge_sort_recursive(arr, reg, start2, end2);</span><br><span class="line">    <span class="keyword">int</span> k = start;</span><br><span class="line">    <span class="keyword">while</span> (start1 &lt;= end1 &amp;&amp; start2 &lt;= end2)</span><br><span class="line">        reg[k++] = arr[start1] &lt; arr[start2] ? arr[start1++] : arr[start2++];</span><br><span class="line">    <span class="keyword">while</span> (start1 &lt;= end1)</span><br><span class="line">        reg[k++] = arr[start1++];</span><br><span class="line">    <span class="keyword">while</span> (start2 &lt;= end2)</span><br><span class="line">        reg[k++] = arr[start2++];</span><br><span class="line">    <span class="keyword">for</span> (k = start; k &lt;= end; k++)</span><br><span class="line">        arr[k] = reg[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">const</span> <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> reg[len];</span><br><span class="line">    merge_sort_recursive(arr, reg, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="快速排序"><a class="header-anchor" href="#快速排序">¶</a>快速排序</h3>
<p>在区间中随机挑选一个元素作基准，将小于基准的元素放在基准之前，大于基准的元素放在基准之后，再分别对小数区与大数区进行排序。</p>
<p>过程演示：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/stardust14/picture/img/20200916213114.gif" alt="img"></p>
<h4 id="迭代法-v2"><a class="header-anchor" href="#迭代法-v2">¶</a>迭代法</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Range</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> start, end;</span><br><span class="line">&#125; Range;</span><br><span class="line"><span class="function">Range <span class="title">new_Range</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    Range r;</span><br><span class="line">    r.start = s;</span><br><span class="line">    r.end = e;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *x, <span class="keyword">int</span> *y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = *x;</span><br><span class="line">    *x = *y;</span><br><span class="line">    *y = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">const</span> <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 避免len等於負值時引發段錯誤（Segment Fault）</span></span><br><span class="line">    <span class="comment">// r[]模擬列表,p為數量,r[p++]為push,r[--p]為pop且取得元素</span></span><br><span class="line">    Range r[len];</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    r[p++] = new_Range(<span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        Range range = r[--p];</span><br><span class="line">        <span class="keyword">if</span> (range.start &gt;= range.end)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = arr[(range.start + range.end) / <span class="number">2</span>]; <span class="comment">// 選取中間點為基準點</span></span><br><span class="line">        <span class="keyword">int</span> left = range.start, right = range.end;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (arr[left] &lt; mid) ++left;   <span class="comment">// 檢測基準點左側是否符合要求</span></span><br><span class="line">            <span class="keyword">while</span> (arr[right] &gt; mid) --right; <span class="comment">//檢測基準點右側是否符合要求</span></span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (left &lt;= right)</span><br><span class="line">            &#123;</span><br><span class="line">                swap(&amp;arr[left],&amp;arr[right]);</span><br><span class="line">                left++;right--;               <span class="comment">// 移動指針以繼續</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (left &lt;= right);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (range.start &lt; right) r[p++] = new_Range(range.start, right);</span><br><span class="line">        <span class="keyword">if</span> (range.end &gt; left) r[p++] = new_Range(left, range.end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="递归法-v2"><a class="header-anchor" href="#递归法-v2">¶</a>递归法</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *x, <span class="keyword">int</span> *y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = *x;</span><br><span class="line">    *x = *y;</span><br><span class="line">    *y = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort_recursive</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = arr[end];</span><br><span class="line">    <span class="keyword">int</span> left = start, right = end - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">while</span> (arr[left] &lt; mid &amp;&amp; left &lt; right)</span><br><span class="line">            left++;</span><br><span class="line">        <span class="keyword">while</span> (arr[right] &gt;= mid &amp;&amp; left &lt; right)</span><br><span class="line">            right--;</span><br><span class="line">        swap(&amp;arr[left], &amp;arr[right]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arr[left] &gt;= arr[end])</span><br><span class="line">        swap(&amp;arr[left], &amp;arr[end]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        left++;</span><br><span class="line">    <span class="keyword">if</span> (left)</span><br><span class="line">        quick_sort_recursive(arr, start, left - <span class="number">1</span>);</span><br><span class="line">    quick_sort_recursive(arr, left + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    quick_sort_recursive(arr, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:邮箱">stardust</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://stardust14.com/2020/09/08/C%E8%AF%AD%E8%A8%80/">http://stardust14.com/2020/09/08/C%E8%AF%AD%E8%A8%80/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://stardust14.com" target="_blank">STAR</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/stardust14/picture/img/Number_one_gril.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/"/></a><div class="post-qr-code-desc"></div></li><li class="reward-item"><a href="/" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/"/></a><div class="post-qr-code-desc"></div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/09/22/MATLAB%E4%BE%8B%E9%A2%98/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/stardust14/picture/img/test06.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">MATLAB例题</div></div></a></div><div class="next-post pull-right"><a href="/2020/08/13/MATLAB%E8%AF%AD%E8%A8%80/"><img class="next-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/stardust14/picture/img/test06.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">MATLAB语言</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2020/09/24/C语言例题/" title="C语言例题"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/stardust14/picture/img/test04.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-24</div><div class="title">C语言例题</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">引言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">C语言基本</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">2.1.</span> <span class="toc-text">基本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-number">2.1.1.</span> <span class="toc-text">标识符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">2.1.2.</span> <span class="toc-text">关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E4%B8%AD%E7%9A%84%E7%A9%BA%E6%A0%BC"><span class="toc-number">2.1.3.</span> <span class="toc-text">C 中的空格</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.1.4.</span> <span class="toc-text">C 数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.1.4.1.</span> <span class="toc-text">整数类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.1.4.2.</span> <span class="toc-text">浮点类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#void-%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.1.4.3.</span> <span class="toc-text">void 类型</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">C 变量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89"><span class="toc-number">3.1.</span> <span class="toc-text">C 中的变量定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E"><span class="toc-number">3.2.</span> <span class="toc-text">C 中的变量声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E4%B8%AD%E7%9A%84%E5%B7%A6%E5%80%BC%EF%BC%88Lvalues%EF%BC%89%E5%92%8C%E5%8F%B3%E5%80%BC%EF%BC%88Rvalues%EF%BC%89"><span class="toc-number">3.3.</span> <span class="toc-text">C 中的左值（Lvalues）和右值（Rvalues）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">C 常量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E5%B8%B8%E9%87%8F"><span class="toc-number">4.1.</span> <span class="toc-text">整数常量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E5%B8%B8%E9%87%8F"><span class="toc-number">4.2.</span> <span class="toc-text">浮点常量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E5%B8%B8%E9%87%8F"><span class="toc-number">4.3.</span> <span class="toc-text">字符常量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F"><span class="toc-number">4.4.</span> <span class="toc-text">字符串常量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%B8%B8%E9%87%8F"><span class="toc-number">4.5.</span> <span class="toc-text">定义常量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#define-%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">4.5.1.</span> <span class="toc-text">#define 预处理器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">4.5.2.</span> <span class="toc-text">const 关键字</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">C 存储类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#auto-%E5%AD%98%E5%82%A8%E7%B1%BB"><span class="toc-number">5.1.</span> <span class="toc-text">auto 存储类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#register-%E5%AD%98%E5%82%A8%E7%B1%BB"><span class="toc-number">5.2.</span> <span class="toc-text">register 存储类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#static-%E5%AD%98%E5%82%A8%E7%B1%BB"><span class="toc-number">5.3.</span> <span class="toc-text">static 存储类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#extern-%E5%AD%98%E5%82%A8%E7%B1%BB"><span class="toc-number">5.4.</span> <span class="toc-text">extern 存储类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">C 运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">6.1.</span> <span class="toc-text">算术运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B"><span class="toc-number">6.1.1.</span> <span class="toc-text">实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">6.2.</span> <span class="toc-text">关系运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-v2"><span class="toc-number">6.2.1.</span> <span class="toc-text">实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">6.3.</span> <span class="toc-text">逻辑运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-v3"><span class="toc-number">6.3.1.</span> <span class="toc-text">实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">6.4.</span> <span class="toc-text">位运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-v4"><span class="toc-number">6.4.1.</span> <span class="toc-text">实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">6.5.</span> <span class="toc-text">赋值运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-v5"><span class="toc-number">6.5.1.</span> <span class="toc-text">实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%82%E9%A1%B9%E8%BF%90%E7%AE%97%E7%AC%A6-%E2%86%A6-sizeof-%E4%B8%89%E5%85%83"><span class="toc-number">6.6.</span> <span class="toc-text">杂项运算符 ↦ sizeof &amp; 三元</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-v6"><span class="toc-number">6.6.1.</span> <span class="toc-text">实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E4%B8%AD%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">6.7.</span> <span class="toc-text">C 中的运算符优先级</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-v7"><span class="toc-number">6.7.1.</span> <span class="toc-text">实例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">C 判断</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E8%AF%AD%E5%8F%A5"><span class="toc-number">7.1.</span> <span class="toc-text">判断语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#if-%E8%AF%AD%E5%8F%A5"><span class="toc-number">7.1.1.</span> <span class="toc-text">if 语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#if%E2%80%A6else%E8%AF%AD%E5%8F%A5"><span class="toc-number">7.1.2.</span> <span class="toc-text">if…else语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97-if-%E8%AF%AD%E5%8F%A5"><span class="toc-number">7.1.3.</span> <span class="toc-text">嵌套 if 语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#switch-%E8%AF%AD%E5%8F%A5"><span class="toc-number">7.1.4.</span> <span class="toc-text">switch 语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97-switch-%E8%AF%AD%E5%8F%A5"><span class="toc-number">7.1.5.</span> <span class="toc-text">嵌套 switch 语句</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6-%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">7.2.</span> <span class="toc-text">? : 运算符(三元运算符)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-v8"><span class="toc-number">7.2.1.</span> <span class="toc-text">实例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">8.</span> <span class="toc-text">C 循环</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E7%B1%BB%E5%9E%8B"><span class="toc-number">8.1.</span> <span class="toc-text">循环类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#while-%E5%BE%AA%E7%8E%AF"><span class="toc-number">8.1.1.</span> <span class="toc-text">while 循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#for-%E5%BE%AA%E7%8E%AF"><span class="toc-number">8.1.2.</span> <span class="toc-text">for 循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#do%E2%80%A6while-%E5%BE%AA%E7%8E%AF"><span class="toc-number">8.1.3.</span> <span class="toc-text">do…while 循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF"><span class="toc-number">8.1.4.</span> <span class="toc-text">嵌套循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-v9"><span class="toc-number">8.1.5.</span> <span class="toc-text">实例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#for-%E5%BE%AA%E7%8E%AF-v2"><span class="toc-number">8.1.5.1.</span> <span class="toc-text">for 循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#while-%E5%B5%8C%E5%A5%97%E5%AE%9E%E4%BE%8B"><span class="toc-number">8.1.5.2.</span> <span class="toc-text">while 嵌套实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#do-while-%E5%B5%8C%E5%A5%97%E5%AE%9E%E4%BE%8B"><span class="toc-number">8.1.5.3.</span> <span class="toc-text">do-while 嵌套实例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5"><span class="toc-number">8.2.</span> <span class="toc-text">循环控制语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#break-%E8%AF%AD%E5%8F%A5"><span class="toc-number">8.2.1.</span> <span class="toc-text">break 语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#continue-%E8%AF%AD%E5%8F%A5"><span class="toc-number">8.2.2.</span> <span class="toc-text">continue 语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#goto-%E8%AF%AD%E5%8F%A5"><span class="toc-number">8.2.3.</span> <span class="toc-text">goto 语句</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">9.</span> <span class="toc-text">C 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0"><span class="toc-number">9.1.</span> <span class="toc-text">定义函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-v10"><span class="toc-number">9.1.1.</span> <span class="toc-text">实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="toc-number">9.2.</span> <span class="toc-text">函数声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">9.3.</span> <span class="toc-text">调用函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-number">9.4.</span> <span class="toc-text">函数参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E5%80%BC%E6%96%B9%E5%BC%8F%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">9.4.1.</span> <span class="toc-text">传值方式调用函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E6%96%B9%E5%BC%8F%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">9.4.2.</span> <span class="toc-text">引用方式调用函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">10.</span> <span class="toc-text">C 作用域规则</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">10.1.</span> <span class="toc-text">局部变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-number">10.2.</span> <span class="toc-text">全局变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%A2%E5%BC%8F%E5%8F%82%E6%95%B0"><span class="toc-number">10.3.</span> <span class="toc-text">形式参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-number">10.4.</span> <span class="toc-text">初始化局部变量和全局变量</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">11.</span> <span class="toc-text">C 数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E6%95%B0%E7%BB%84"><span class="toc-number">11.1.</span> <span class="toc-text">声明数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E7%BB%84"><span class="toc-number">11.2.</span> <span class="toc-text">初始化数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0"><span class="toc-number">11.3.</span> <span class="toc-text">访问数组元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E4%B8%AD%E6%95%B0%E7%BB%84%E8%AF%A6%E8%A7%A3"><span class="toc-number">11.4.</span> <span class="toc-text">C 中数组详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">11.4.1.</span> <span class="toc-text">多维数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">11.4.1.1.</span> <span class="toc-text">二维数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">11.4.1.2.</span> <span class="toc-text">初始化二维数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0"><span class="toc-number">11.4.1.3.</span> <span class="toc-text">访问二维数组元素</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E9%80%92%E6%95%B0%E7%BB%84%E7%BB%99%E5%87%BD%E6%95%B0"><span class="toc-number">11.4.2.</span> <span class="toc-text">传递数组给函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F-1"><span class="toc-number">11.4.2.1.</span> <span class="toc-text">方式 1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F-2"><span class="toc-number">11.4.2.2.</span> <span class="toc-text">方式 2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F-3"><span class="toc-number">11.4.2.3.</span> <span class="toc-text">方式 3</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-v11"><span class="toc-number">11.4.2.4.</span> <span class="toc-text">实例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E6%95%B0%E7%BB%84"><span class="toc-number">11.4.3.</span> <span class="toc-text">从函数返回数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E5%90%91%E6%95%B0%E7%BB%84%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">11.4.4.</span> <span class="toc-text">指向数组的指针</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">12.</span> <span class="toc-text">C enum(枚举)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">12.1.</span> <span class="toc-text">枚举变量的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%86%E6%95%B4%E6%95%B0%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%9E%9A%E4%B8%BE"><span class="toc-number">12.2.</span> <span class="toc-text">将整数转换为枚举</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">13.</span> <span class="toc-text">C 指针</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8C%87%E9%92%88%EF%BC%9F"><span class="toc-number">13.1.</span> <span class="toc-text">什么是指针？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%8C%87%E9%92%88%EF%BC%9F"><span class="toc-number">13.2.</span> <span class="toc-text">如何使用指针？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E4%B8%AD%E7%9A%84-NULL-%E6%8C%87%E9%92%88"><span class="toc-number">13.3.</span> <span class="toc-text">C 中的 NULL 指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3"><span class="toc-number">13.4.</span> <span class="toc-text">C 指针详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E7%9A%84%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97"><span class="toc-number">13.4.1.</span> <span class="toc-text">指针的算术运算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%A2%9E%E4%B8%80%E4%B8%AA%E6%8C%87%E9%92%88"><span class="toc-number">13.4.1.1.</span> <span class="toc-text">递增一个指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%87%8F%E4%B8%80%E4%B8%AA%E6%8C%87%E9%92%88"><span class="toc-number">13.4.1.2.</span> <span class="toc-text">递减一个指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">13.4.1.3.</span> <span class="toc-text">指针的比较</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84"><span class="toc-number">13.4.2.</span> <span class="toc-text">指针数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E5%90%91%E6%8C%87%E9%92%88%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">13.4.3.</span> <span class="toc-text">指向指针的指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E9%80%92%E6%8C%87%E9%92%88%E7%BB%99%E5%87%BD%E6%95%B0"><span class="toc-number">13.4.4.</span> <span class="toc-text">传递指针给函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E6%8C%87%E9%92%88"><span class="toc-number">13.4.5.</span> <span class="toc-text">从函数返回指针</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">14.</span> <span class="toc-text">C 函数指针与回调函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">14.1.</span> <span class="toc-text">函数指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-v12"><span class="toc-number">14.1.1.</span> <span class="toc-text">实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-number">14.2.</span> <span class="toc-text">回调函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E4%BD%9C%E4%B8%BA%E6%9F%90%E4%B8%AA%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-number">14.2.1.</span> <span class="toc-text">函数指针作为某个函数的参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-v13"><span class="toc-number">14.2.2.</span> <span class="toc-text">实例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">15.</span> <span class="toc-text">C 字符串</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">16.</span> <span class="toc-text">C 结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E7%BB%93%E6%9E%84"><span class="toc-number">16.1.</span> <span class="toc-text">定义结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">16.2.</span> <span class="toc-text">结构体变量的初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E7%BB%93%E6%9E%84%E6%88%90%E5%91%98"><span class="toc-number">16.3.</span> <span class="toc-text">访问结构成员</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-number">16.4.</span> <span class="toc-text">结构作为函数参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E5%90%91%E7%BB%93%E6%9E%84%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">16.5.</span> <span class="toc-text">指向结构的指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E5%9F%9F"><span class="toc-number">16.6.</span> <span class="toc-text">位域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E5%9F%9F%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%8D%E5%9F%9F%E5%8F%98%E9%87%8F%E7%9A%84%E8%AF%B4%E6%98%8E"><span class="toc-number">16.6.1.</span> <span class="toc-text">位域的定义和位域变量的说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E5%9F%9F%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">16.6.2.</span> <span class="toc-text">位域的使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">17.</span> <span class="toc-text">C 共用体</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%85%B1%E7%94%A8%E4%BD%93"><span class="toc-number">17.1.</span> <span class="toc-text">定义共用体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%85%B1%E7%94%A8%E4%BD%93%E6%88%90%E5%91%98"><span class="toc-number">17.2.</span> <span class="toc-text">访问共用体成员</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">18.</span> <span class="toc-text">C 位域</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E5%9F%9F%E5%A3%B0%E6%98%8E"><span class="toc-number">18.1.</span> <span class="toc-text">位域声明</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">19.</span> <span class="toc-text">C typedef</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#typedef-vs-define"><span class="toc-number">19.1.</span> <span class="toc-text">typedef vs #define</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">20.</span> <span class="toc-text">C 输入 &amp; 输出</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E6%96%87%E4%BB%B6"><span class="toc-number">20.1.</span> <span class="toc-text">标准文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#getchar-putchar-%E5%87%BD%E6%95%B0"><span class="toc-number">20.2.</span> <span class="toc-text">getchar() &amp; putchar() 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gets-puts-%E5%87%BD%E6%95%B0"><span class="toc-number">20.3.</span> <span class="toc-text">gets() &amp; puts() 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#scanf-%E5%92%8C-printf-%E5%87%BD%E6%95%B0"><span class="toc-number">20.4.</span> <span class="toc-text">scanf() 和 printf() 函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">21.</span> <span class="toc-text">C 文件读写</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6"><span class="toc-number">21.1.</span> <span class="toc-text">打开文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%97%AD%E6%96%87%E4%BB%B6"><span class="toc-number">21.2.</span> <span class="toc-text">关闭文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6"><span class="toc-number">21.3.</span> <span class="toc-text">写入文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6"><span class="toc-number">21.4.</span> <span class="toc-text">读取文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6-I-O-%E5%87%BD%E6%95%B0"><span class="toc-number">21.5.</span> <span class="toc-text">二进制 I&#x2F;O 函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">22.</span> <span class="toc-text">C 预处理器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E5%AE%9E%E4%BE%8B"><span class="toc-number">22.1.</span> <span class="toc-text">预处理器实例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%84%E5%AE%9A%E4%B9%89%E5%AE%8F"><span class="toc-number">22.2.</span> <span class="toc-text">预定义宏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">22.3.</span> <span class="toc-text">预处理器运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%8F%E5%BB%B6%E7%BB%AD%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88-%EF%BC%89"><span class="toc-number">22.3.0.0.1.</span> <span class="toc-text">宏延续运算符（\）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E5%8C%96%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88-%EF%BC%89"><span class="toc-number">22.3.0.0.2.</span> <span class="toc-text">字符串常量化运算符（#）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E7%B2%98%E8%B4%B4%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88-%EF%BC%89"><span class="toc-number">22.3.0.0.3.</span> <span class="toc-text">标记粘贴运算符（##）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#defined-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">22.3.0.0.4.</span> <span class="toc-text">defined() 运算符</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E5%8C%96%E7%9A%84%E5%AE%8F"><span class="toc-number">22.4.</span> <span class="toc-text">参数化的宏</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">23.</span> <span class="toc-text">C 头文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="toc-number">23.1.</span> <span class="toc-text">引用头文件的语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">23.2.</span> <span class="toc-text">引用头文件的操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AA%E5%BC%95%E7%94%A8%E4%B8%80%E6%AC%A1%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-number">23.3.</span> <span class="toc-text">只引用一次头文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E6%9D%A1%E4%BB%B6%E5%BC%95%E7%94%A8"><span class="toc-number">23.4.</span> <span class="toc-text">有条件引用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">24.</span> <span class="toc-text">C 强制类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E6%8F%90%E5%8D%87"><span class="toc-number">24.1.</span> <span class="toc-text">整数提升</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E7%AE%97%E6%9C%AF%E8%BD%AC%E6%8D%A2"><span class="toc-number">24.2.</span> <span class="toc-text">常用的算术转换</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">25.</span> <span class="toc-text">C 错误处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#errno%E3%80%81perror-%E5%92%8C-strerror"><span class="toc-number">25.1.</span> <span class="toc-text">errno、perror() 和 strerror()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A2%AB%E9%9B%B6%E9%99%A4%E7%9A%84%E9%94%99%E8%AF%AF"><span class="toc-number">25.2.</span> <span class="toc-text">被零除的错误</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E9%80%80%E5%87%BA%E7%8A%B6%E6%80%81"><span class="toc-number">25.3.</span> <span class="toc-text">程序退出状态</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">26.</span> <span class="toc-text">C 递归</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%9A%84%E9%98%B6%E4%B9%98"><span class="toc-number">26.1.</span> <span class="toc-text">数的阶乘</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97"><span class="toc-number">26.2.</span> <span class="toc-text">斐波那契数列</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">27.</span> <span class="toc-text">C 可变参数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">28.</span> <span class="toc-text">C 内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98"><span class="toc-number">28.1.</span> <span class="toc-text">动态分配内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E6%96%B0%E8%B0%83%E6%95%B4%E5%86%85%E5%AD%98%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%92%8C%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98"><span class="toc-number">28.2.</span> <span class="toc-text">重新调整内存的大小和释放内存</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">29.</span> <span class="toc-text">C 命令行参数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">30.</span> <span class="toc-text">C 排序算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">30.0.1.</span> <span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">30.0.2.</span> <span class="toc-text">选择排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">30.0.3.</span> <span class="toc-text">插入排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-number">30.0.4.</span> <span class="toc-text">希尔排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">30.0.5.</span> <span class="toc-text">归并排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E6%B3%95"><span class="toc-number">30.0.5.1.</span> <span class="toc-text">迭代法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E6%B3%95"><span class="toc-number">30.0.5.2.</span> <span class="toc-text">递归法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">30.0.6.</span> <span class="toc-text">快速排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E6%B3%95-v2"><span class="toc-number">30.0.6.1.</span> <span class="toc-text">迭代法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E6%B3%95-v2"><span class="toc-number">30.0.6.2.</span> <span class="toc-text">递归法</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/stardust14/picture/img/Number_one_gril.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By stardust</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.css"><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', '', 'katex-wrap')
  })
})()</script><script>if (document.getElementsByClassName('mermaid').length) {
  if (window.mermaidJsLoad) mermaid.init()
  else {
    getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(() => {
      window.mermaidJsLoad = true
      mermaid.initialize({
        theme: 'default',
      })
      false && mermaid.init()
    })
  }
}</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'HTNDsPzD87VFJzxigXr0LgQT-gzGzoHsz',
      appKey: 'rujMRAYTJMNb3muoM0nm6YCs',
      placeholder: '请留下你来过的痕迹吧~',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'en',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '//i0.hdslb.com/bfs/emote/',
      emojiMaps: {"[tv_白眼]":"c1d59f439e379ee50eef488bcb5e5378e5044ea4.png","[tv_doge]":"6ea59c827c414b4a2955fe79e0f6fd3dcd515e24.png","[tv_坏笑]":"1f0b87f731a671079842116e0991c91c2c88645a.png","[tv_难过]":"87f46748d3f142ebc6586ff58860d0e2fc8263ba.png","[tv_生气]":"26702dcafdab5e8225b43ffd23c94ac1ff932654.png","[tv_委屈]":"d04dba7b5465779e9755d2ab6f0a897b9b33bb77.png","[tv_斜眼笑]":"911f987aa8bc1bee12d52aafe62bc41ef4474e6c.png","[tv_呆]":"fe1179ebaa191569b0d31cecafe7a2cd1c951c9d.png","[tv_发怒]":"34ba3cd204d5b05fec70ce08fa9fa0dd612409ff.png","[tv_惊吓]":"0d15c7e2ee58e935adc6a7193ee042388adc22af.png","[tv_呕吐]":"9f996894a39e282ccf5e66856af49483f81870f3.png","[tv_思考]":"90cf159733e558137ed20aa04d09964436f618a1.png","[tv_微笑]":"70dc5c7b56f93eb61bddba11e28fb1d18fddcd4c.png","[tv_疑问]":"0793d949b18d7be716078349c202c15ff166f314.png","[tv_大哭]":"23269aeb35f99daee28dda129676f6e9ea87934f.png","[tv_鼓掌]":"1d21793f96ef4e6f48b23e53e3b9e42da833a0f6.png","[tv_抠鼻]":"c666f55e88d471e51bbd9fab9bb308110824a6eb.png","[tv_亲亲]":"a8111ad55953ef5e3be3327ef94eb4a39d535d06.png","[tv_调皮]":"b9c41de8e82dd7a8515ae5e3cb63e898bf245186.png","[tv_笑哭]":"1abc628f6d4f4caf9d0e7800878f4697abbc8273.png","[tv_晕]":"5443c22b4d07fb1907ccc610c8e6db254f2461b7.png","[tv_点赞]":"f85c354995bd99e28fc76c869bfe42ba6438eff4.png","[tv_害羞]":"a37683fb5642fa3ddfc7f4e5525fd13e42a2bdb1.png","[tv_睡着]":"8b196675b53af58264f383c50ad0945048290b33.png","[tv_色]":"61822c7e9aae5da76475e7892534545336b23a6f.png","[tv_吐血]":"09dd16a7aa59b77baa1155d47484409624470c77.png","[tv_无奈]":"ea8ed89ee9878f2fece2dda0ea8a5dbfe21b5751.png","[tv_再见]":"180129b8ea851044ce71caf55cc8ce44bd4a4fc8.png","[tv_流汗]":"cead1c351ab8d79e9f369605beb90148db0fbed3.png","[tv_偷笑]":"bb690d4107620f1c15cff29509db529a73aee261.png","[tv_抓狂]":"fe31c08edad661d63762b04e17b8d5ae3c71a757.png","[tv_黑人问号]":"45821a01f51bc867da9edbaa2e070410819a95b2.png","[tv_困]":"241ee304e44c0af029adceb294399391e4737ef2.png","[tv_打脸]":"56ab10b624063e966bfcb76ea5dc4794d87dfd47.png","[tv_闭嘴]":"c9e990da7f6e93975e25fd8b70e2e290aa4086ef.png","[tv_鄙视]":"6e72339f346a692a495b123174b49e4e8e781303.png","[tv_腼腆]":"89712c0d4af73e67f89e35cbc518420380a7f6f4.png","[tv_馋]":"fc7e829b845c43c623c8b490ee3602b7f0e76a31.png","[tv_可爱]":"9e55fd9b500ac4b96613539f1ce2f9499e314ed9.png","[tv_发财]":"34db290afd2963723c6eb3c4560667db7253a21a.png","[tv_生病]":"8b0ec90e6b86771092a498c54f09fc94621c1900.png","[tv_流鼻血]":"c32d39db2737f89b904ca32700d140a9241b0767.png","[tv_尴尬]":"7cfa62dafc59798a3d3fb262d421eeeff166cfa4.png","[tv_大佬]":"093c1e2c490161aca397afc45573c877cdead616.png","[tv_流泪]":"7e71cde7858f0cd50d74b0264aa26db612a8a167.png","[tv_冷漠]":"b9cbc755c2b3ee43be07ca13de84e5b699a3f101.png","[tv_皱眉]":"72ccad6679fea0d14cce648b4d818e09b8ffea2d.png","[tv_鬼脸]":"0ffbbddf8a94d124ca2f54b360bbc04feb6bbfea.png","[tv_调侃]":"4bc022533ef31544ca0d72c12c808cf4a1cce3e3.png","[tv_目瞪口呆]":"0b8cb81a68de5d5365212c99375e7ace3e7891b7.png","[2233娘_大笑]":"16b8794be990cefa6caeba4d901b934a227ee3b8.png","[2233娘_疑问]":"0b41f509351958dbb63d472fec0132d1bd03bd14.png","[2233娘_吃惊]":"d1628c43d35b1530c0504a643ff80b6189fa0a43.png","[2233娘_汗]":"247cd9df8cdf84b18368c21e3b2dd374e84c0927.png","[2233娘_大哭]":"476a2a60f6e337b8c0697a592e0aa82781f6b33b.png","[2233娘_困惑]":"714eeb4eae0d0933b4ff08b7df788b1982f6b940.png","[2233娘_耶]":"d7178e258a0efc969b65ccc2b1322fb235f5dff4.png","[2233娘_怒]":"f31953119c51b9748016440ac0b632f779929b37.png","[2233娘_卖萌]":"ea893aa25355de95ab4f03c2dad3f0c58d0c159e.png","[2233娘_委屈]":"d9d0bf9d358af8d5761093ec66d4e3f60d963a63.png","[2233娘_郁闷]":"485203fe7100f2c8fc40b2800a18fe20b35f2f1a.png","[2233娘_第一]":"3754ee6e5985bd0bd7dfb668981f2a8733398ebd.png","[2233娘_喝水]":"695bf5429472049b52c1e0de586f8a2511195a23.png","[2233娘_吐魂]":"e999af499edf38a91ca68b1a9d2f97042c1d6734.png","[2233娘_无言]":"fdb5870f32cfaf7949e0f88a13f6feba4a48b719.png","[加油武汉]":"eb966aaa5b690d3f9308a9f936f5b5a72a7f956b.png","[口罩]":"3ad2f66b151496d2a5fb0a8ea75f32265d778dd3.png","[鸡腿]":"c7860392815d345fa69c4f00ef18d67dccfbd574.png","[微笑]":"685612eadc33f6bc233776c6241813385844f182.png","[笑]":"81edf17314cea3b48674312b4364df44d5c01f17.png","[呲牙]":"b5a5898491944a4268360f2e7a84623149672eb6.png","[OK]":"4683fd9ffc925fa6423110979d7dcac5eda297f4.png","[星星眼]":"63c9d1a31c0da745b61cdb35e0ecb28635675db2.png","[哦呼]":"362bded07ea5434886271d23fa25f5d85d8af06c.png","[嫌弃]":"de4c0783aaa60ec03de0a2b90858927bfad7154b.png","[喜欢]":"8a10a4d73a89f665feff3d46ca56e83dc68f9eb8.png","[酸了]":"92b1c8cbceea3ae0e8e32253ea414783e8ba7806.png","[大哭]":"2caafee2e5db4db72104650d87810cc2c123fc86.png","[害羞]":"9d2ec4e1fbd6cb1b4d12d2bbbdd124ccb83ddfda.png","[无语]":"44667b7d9349957e903b1b62cb91fb9b13720f04.png","[疑惑]":"b7840db4b1f9f4726b7cb23c0972720c1698d661.png","[调皮]":"8290b7308325e3179d2154327c85640af1528617.png","[喜极而泣]":"485a7e0c01c2d70707daae53bee4a9e2e31ef1ed.png","[奸笑]":"bb84906573472f0a84cebad1e9000eb6164a6f5a.png","[偷笑]":"6c49d226e76c42cd8002abc47b3112bc5a92f66a.png","[大笑]":"ca94ad1c7e6dac895eb5b33b7836b634c614d1c0.png","[阴险]":"ba8d5f8e7d136d59aab52c40fd3b8a43419eb03c.png","[捂脸]":"6921bb43f0c634870b92f4a8ad41dada94a5296d.png","[囧]":"12e41d357a9807cc80ef1e1ed258127fcc791424.png","[呆]":"33ad6000d9f9f168a0976bc60937786f239e5d8c.png","[抠鼻]":"cb89184c97e3f6d50acfd7961c313ce50360d70f.png","[惊喜]":"0afecaf3a3499479af946f29749e1a6c285b6f65.png","[惊讶]":"f8e9a59cad52ae1a19622805696a35f0a0d853f3.png","[笑哭]":"c3043ba94babf824dea03ce500d0e73763bf4f40.png","[妙啊]":"b4cb77159d58614a9b787b91b1cd22a81f383535.png","[doge]":"bba7c12aa51fed0199c241465560dfc2714c593e.png","[滑稽]":"d15121545a99ac46774f1f4465b895fe2d1411c3.png","[吃瓜]":"4191ce3c44c2b3df8fd97c33f85d3ab15f4f3c84.png ","[打call]":"431432c43da3ee5aab5b0e4f8931953e649e9975.png","[点赞]":"1a67265993913f4c35d15a6028a30724e83e7d35.png","[鼓掌]":"895d1fc616b4b6c830cf96012880818c0e1de00d.png  ","[尴尬]":"cb321684ed5ce6eacdc2699092ab8fe7679e4fda.png","[冷]":"cb0ebbd0668640f07ebfc0e03f7a18a8cd00b4ed.png","[灵魂出窍]":"43d3db7d97343c01b47e22cfabeca84b4251f35a.png","[委屈]":"d2f26cbdd6c96960320af03f5514c5b524990840.png","[傲娇]":"010540d0f61220a0db4922e4a679a1d8eca94f4e.png","[疼]":"905fd9a99ec316e353b9bd4ecd49a5f0a301eabf.png","[吓]":"9c10c5ebc7bef27ec641b8a1877674e0c65fea5d.png","[生病]":"0f25ce04ae1d7baf98650986454c634f6612cb76.png","[吐]":"06946bfe71ac48a6078a0b662181bb5cad09decc.png","[嘘声]":"e64af664d20716e090f10411496998095f62f844.png","[捂眼]":"c5c6d6982e1e53e478daae554b239f2b227b172b.png","[思考]":"cfa9b7e89e4bfe04bbcd34ccb1b0df37f4fa905c.png","[再见]":"fc510306bae26c9aec7e287cdf201ded27b065b9.png","[翻白眼]":"eba54707c7168925b18f6f8b1f48d532fe08c2b1.png","[哈欠]":"888d877729cbec444ddbd1cf4c9af155a7a06086.png","[奋斗]":"bb2060c15dba7d3fd731c35079d1617f1afe3376.png","[墨镜]":"3a03aebfc06339d86a68c2d893303b46f4b85771.png","[撇嘴]":"531863568e5668c5ac181d395508a0eeb1f0cda4.png","[难过]":"a651db36701610aa70a781fa98c07c9789b11543.png","[抓狂]":"4c87afff88c22439c45b79e9d2035d21d5622eba.png","[生气]":"3195714219c4b582a4fb02033dd1519913d0246d.png","[干杯]":"8da12d5f55a2c7e9778dcc05b40571979fe208e6.png","[爱心]":"ed04066ea7124106d17ffcaf75600700e5442f5c.png","[锦鲤]":"643d6c19c8164ffd89e3e9cdf093cf5d773d979c.png","[胜利]":"b49fa9f4b1e7c3477918153b82c60b114d87347c.png","[加油]":"c7aaeacb21e107292d3bb053e5abde4a4459ed30.png","[保佑]":"fafe8d3de0dc139ebe995491d2dac458a865fb30.png","[抱拳]":"89516218158dbea18ab78e8873060bf95d33bbbe.png","[响指]":"1b5c53cf14336903e1d2ae3527ca380a1256a077.png","[支持]":"3c210366a5585706c09d4c686a9d942b39feeb50.png","[拥抱]":"41780a4254750cdaaccb20735730a36044e98ef3.png","[怪我咯]":"07cc6077f7f7d75b8d2c722dd9d9828a9fb9e46d.png","[跪了]":"f2b3aee7e521de7799d4e3aa379b01be032698ac.png","[黑洞]":"e90ec4c799010f25391179118ccd9f66b3b279ba.png","[老鼠]":"8e6fb491eb1bb0d5862e7ec8ccf9a3da12b6c155.png","[2020]":"dc709fac0d361370bcf0d36d32adb97df7c95824.png","[福到了]":"5de5373d354c373cf1617b6b836f3a8d53c5a655.png"},
      enableQQ: false,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script src="//lib.baomitu.com/jquery/3.5.1/jquery.min.js"></script><script src="https://myhkw.cn/api/player/159721473362" id="myhk" key="159721473362" m="1"></script><script src="https://cdn.jsdelivr.net/gh/stardust14/CDN/HexoStatic/js/Foster.js"></script><script src="https://cdn.jsdelivr.net/gh/stardust14/CDN/HexoStatic/js/hideCategory.min.js"></script><script src="https://cdn.jsdelivr.net/gh/stardust14/CDN/HexoStatic/js/title.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>function history_calendar_injector_config(){
                var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
                var item_html = '<div class="card-widget card-history"><div class="card-content"><div class="item-headline"><i class="fas fa-clock fa-spin"></i><span>那年今日</span></div><div id="history-baidu" style="height: 100px;overflow: hidden"><div class="history_swiper-container" id="history-container" style="width: 100%;height: 100%"><div class="swiper-wrapper" id="history_container_wrapper" style="height:20px"></div></div></div></div>';
                console.log('已挂载history_calendar')
                // parent_div_git.innerHTML=item_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",item_html) // 有报错，但不影响使用(支持pjax跳转)
            }if( document.getElementsByClassName('sticky_layout')[0] && (location.pathname ==='all'|| 'all' ==='all')){

            history_calendar_injector_config()
        } </script><script data-pjax  src="https://cdn.jsdelivr.net/npm/swiper/swiper-bundle.min.js"></script><script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/js/main.js"></script><script data-pjax>function electric_clock_injector_config(){
                var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
                var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img id="card-clock-loading" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-clock/clock/images/weather/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading" class="entered loading"></div></div></div></div></div>';
                console.log('已挂载electric_clock')
                // parent_div_git.innerHTML=item_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",item_html) // 有报错，但不影响使用(支持pjax跳转)
            }if( document.getElementsByClassName('sticky_layout')[0] && (location.pathname ==='all'|| 'all' ==='all')){

            electric_clock_injector_config()
        } </script><script src="https://pv.sohu.com/cityjson?ie=utf-8"></script><script data-pjax  src="https://cdn.jsdelivr.net/gh/Zfour/hexo-electric-clock@1.0.6/clock.js"></script><!-- hexo injector body_end end --></body></html>