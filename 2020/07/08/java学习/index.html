<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>java基础知识学习笔记 | STAR</title><meta name="description" content="定义方法 ¶1、定义一个方法（函数）的格式： public static void 方法名称()&amp;#123;  	方法体  &amp;#125;  ¶2、调用方法（函数），格式： 方法名称(); 对于byte&#x2F;short&#x2F;char三种类型来说，如果右侧赋值的数值没有超过范围，那么Java编译器将会自动隐含的为我们补上一个（byte）（short）（char） 循环 三种循环的区别。 1、如"><meta name="keywords" content="java"><meta name="author" content="stardust,邮箱"><meta name="copyright" content="stardust"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/stardust14.github.io/img/favicon.png"><link rel="canonical" href="http://stardust14.com/2020/07/08/java%E5%AD%A6%E4%B9%A0/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="java基础知识学习笔记"><meta property="og:url" content="http://stardust14.com/2020/07/08/java%E5%AD%A6%E4%B9%A0/"><meta property="og:site_name" content="STAR"><meta property="og:description" content="定义方法 ¶1、定义一个方法（函数）的格式： public static void 方法名称()&amp;#123;  	方法体  &amp;#125;  ¶2、调用方法（函数），格式： 方法名称(); 对于byte&#x2F;short&#x2F;char三种类型来说，如果右侧赋值的数值没有超过范围，那么Java编译器将会自动隐含的为我们补上一个（byte）（short）（char） 循环 三种循环的区别。 1、如"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg3.png"><meta property="article:published_time" content="2020-07-08T05:44:13.000Z"><meta property="article:modified_time" content="2020-07-08T05:44:13.000Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'true'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/stardust14.github.io/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/stardust14.github.io/',
  hexoversion: '5.0.0',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: {"limitDay":30,"position":"top","messagePrev":"已经距离上次更新","messageNext":"天了。"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: true,
  islazyload: true,
  isanchor: false    
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isSidebar: true,
  postUpdate: '2020-07-08 13:44:13'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 5.0.0"><link rel="alternate" href="/stardust14.github.io/atom.xml" title="STAR" type="application/atom+xml">
</head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" data-lazy-src="/stardust14.github.io/images/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/stardust14.github.io/archives/"><div class="headline">文章</div><div class="length_num">7</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/stardust14.github.io/tags/"><div class="headline">标签</div><div class="length_num">3</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/stardust14.github.io/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/stardust14.github.io/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/stardust14.github.io/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/stardust14.github.io/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 放松一下</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/stardust14.github.io/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/stardust14.github.io/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page" href="/stardust14.github.io/photograph/"><i class="fa-fw fas fa-globe"></i><span> Photograph</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/stardust14.github.io/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/stardust14.github.io/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/stardust14.github.io/about/"><i class="fa-fw fas fa-heart"></i><span> 关于me</span></a></div></div></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">定义方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%EF%BC%88%E5%87%BD%E6%95%B0%EF%BC%89%E7%9A%84%E6%A0%BC%E5%BC%8F%EF%BC%9A"><span class="toc-number">1.0.1.</span> <span class="toc-text">1、定义一个方法（函数）的格式：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%88%E5%87%BD%E6%95%B0%EF%BC%89%EF%BC%8C%E6%A0%BC%E5%BC%8F%EF%BC%9A"><span class="toc-number">1.0.2.</span> <span class="toc-text">2、调用方法（函数），格式：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">循环</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">IDEA的常用快捷键</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%EF%BC%88overload%EF%BC%89"><span class="toc-number">4.1.</span> <span class="toc-text">方法重载（overload）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%98%EF%BC%88%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%EF%BC%89"><span class="toc-number">4.1.1.</span> <span class="toc-text">练习题（方法重载）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">5.1.</span> <span class="toc-text">数组的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%92%E5%88%86"><span class="toc-number">5.2.</span> <span class="toc-text">内存划分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE"><span class="toc-number">5.3.</span> <span class="toc-text">数组的内存图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">5.4.</span> <span class="toc-text">常见的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95%E8%B6%8A%E7%95%8C%E5%BC%82%E5%B8%B8"><span class="toc-number">5.4.1.</span> <span class="toc-text">1、数组索引越界异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E7%A9%BA%E6%8C%87%E9%92%88%E5%BC%82%E5%B8%B8"><span class="toc-number">5.4.2.</span> <span class="toc-text">2、空指针异常</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%95%B0%E7%BB%84%E7%9A%84%E9%95%BF%E5%BA%A6"><span class="toc-number">5.5.</span> <span class="toc-text">获取数组的长度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E5%8F%8D%E8%BD%AC"><span class="toc-number">5.6.</span> <span class="toc-text">数组元素反转</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%BD%9C%E4%B8%BA%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0"><span class="toc-number">5.7.</span> <span class="toc-text">数组作为方法参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%BD%9C%E4%B8%BA%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">5.8.</span> <span class="toc-text">数组作为方法返回值</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">面向对象思想</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">6.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.2.</span> <span class="toc-text">类和对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-number">6.2.1.</span> <span class="toc-text">类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.2.2.</span> <span class="toc-text">对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">6.2.3.</span> <span class="toc-text">类和对象的关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">6.3.</span> <span class="toc-text">类的定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E7%89%A9%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">6.3.1.</span> <span class="toc-text">事物与类的对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%AE%9A%E4%B9%89%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="toc-number">6.3.2.</span> <span class="toc-text">类定义的格式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8"><span class="toc-number">6.4.</span> <span class="toc-text">对象的创建及其使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%8B%E6%9C%BA%E7%B1%BB%E7%9A%84%E7%BB%83%E4%B9%A0%E9%A2%98"><span class="toc-number">6.4.1.</span> <span class="toc-text">手机类的练习题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE"><span class="toc-number">6.5.</span> <span class="toc-text">一个对象的内存图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1%E4%BD%BF%E7%94%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE"><span class="toc-number">6.6.</span> <span class="toc-text">两个对象使用同一个方法的内存图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E5%BC%95%E7%94%A8%E6%8C%87%E5%90%91%E5%90%8C%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE"><span class="toc-number">6.7.</span> <span class="toc-text">两个引用指向同一个对象的内存图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E4%BD%9C%E4%B8%BA%E6%96%B9%E6%B3%95%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-number">6.8.</span> <span class="toc-text">使用对象类型作为方法的参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E4%BD%9C%E4%B8%BA%E6%96%B9%E6%B3%95%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">6.9.</span> <span class="toc-text">使用对象类型作为方法的返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.10.</span> <span class="toc-text">成员变量和局部变量的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81%E4%B9%8B%E5%B0%81%E8%A3%85%E6%80%A7"><span class="toc-number">6.11.</span> <span class="toc-text">面向对象三大特征之封装性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%98"><span class="toc-number">6.12.</span> <span class="toc-text">练习题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">6.13.</span> <span class="toc-text">this关键字的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">6.14.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E6%A0%87%E5%87%86%E7%9A%84%E7%B1%BB"><span class="toc-number">6.15.</span> <span class="toc-text">定义一个标准的类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">API</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-v2"><span class="toc-number">7.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#API%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4"><span class="toc-number">7.2.</span> <span class="toc-text">API使用步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Scanner%E7%B1%BB"><span class="toc-number">7.3.</span> <span class="toc-text">Scanner类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-v3"><span class="toc-number">7.3.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4"><span class="toc-number">7.3.2.</span> <span class="toc-text">使用步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%98-v2"><span class="toc-number">7.3.2.1.</span> <span class="toc-text">练习题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AF%B4%E6%98%8E"><span class="toc-number">7.4.</span> <span class="toc-text">匿名对象的说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BA%E6%96%B9%E6%B3%95%E7%9A%84%E5%8F%82%E6%95%B0%E5%92%8C%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">7.5.</span> <span class="toc-text">匿名对象作为方法的参数和返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Random"><span class="toc-number">7.6.</span> <span class="toc-text">Random</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0%E5%92%8C%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">7.6.1.</span> <span class="toc-text">概述和基本使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%98-v3"><span class="toc-number">7.6.1.1.</span> <span class="toc-text">练习题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84"><span class="toc-number">7.7.</span> <span class="toc-text">对象数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ArrayList%E7%B1%BB"><span class="toc-number">7.8.</span> <span class="toc-text">ArrayList类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%92%8C%E6%A6%82%E8%BF%B0"><span class="toc-number">7.8.1.</span> <span class="toc-text">基本使用和概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E5%92%8C%E9%81%8D%E5%8E%86"><span class="toc-number">7.8.2.</span> <span class="toc-text">常用方法和遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E5%AD%98%E5%82%A8%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">7.8.3.</span> <span class="toc-text">集合存储基本数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%98-v4"><span class="toc-number">7.8.4.</span> <span class="toc-text">练习题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%AD%98%E5%82%A8%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%AD%97"><span class="toc-number">7.8.4.1.</span> <span class="toc-text">1、存储随机数字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E5%AD%98%E5%82%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1"><span class="toc-number">7.8.4.2.</span> <span class="toc-text">2、存储自定义对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E6%8C%89%E6%8C%87%E5%AE%9A%E6%A0%BC%E5%BC%8F%E9%81%8D%E5%8E%86%E9%9B%86%E5%90%88"><span class="toc-number">7.8.4.3.</span> <span class="toc-text">3、按指定格式遍历集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E7%AD%9B%E9%80%89%E9%9B%86%E5%90%88%E4%B8%AD%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%95%B0"><span class="toc-number">7.8.4.4.</span> <span class="toc-text">4、筛选集合中的随机数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88String%EF%BC%89"><span class="toc-number">7.9.</span> <span class="toc-text">字符串（String）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0%E5%92%8C%E7%89%B9%E7%82%B9"><span class="toc-number">7.9.1.</span> <span class="toc-text">概述和特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%92%8C%E7%9B%B4%E6%8E%A5%E5%88%9B%E5%BB%BA"><span class="toc-number">7.9.2.</span> <span class="toc-text">构造方法和直接创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-number">7.9.3.</span> <span class="toc-text">字符串的常量池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%AF%94%E8%BE%83%E6%96%B9%E6%B3%95"><span class="toc-number">7.9.4.</span> <span class="toc-text">字符串的比较方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%8E%B7%E5%8F%96%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95"><span class="toc-number">7.9.5.</span> <span class="toc-text">字符串获取相关方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%88%AA%E5%8F%96%E6%96%B9%E6%B3%95"><span class="toc-number">7.9.6.</span> <span class="toc-text">字符串的截取方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%BD%AC%E6%8D%A2%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95"><span class="toc-number">7.9.7.</span> <span class="toc-text">字符串的转换相关方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%86%E5%89%B2%E6%96%B9%E6%B3%95"><span class="toc-number">7.9.8.</span> <span class="toc-text">字符串的分割方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%98-v5"><span class="toc-number">7.9.9.</span> <span class="toc-text">练习题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E6%8C%89%E6%8C%87%E5%AE%9A%E6%A0%BC%E5%BC%8F%E6%8B%BC%E6%8E%A5%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">7.9.9.1.</span> <span class="toc-text">1、按指定格式拼接字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E7%BB%9F%E8%AE%A1%E8%BE%93%E5%85%A5%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%90%84%E7%A7%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="toc-number">7.9.9.2.</span> <span class="toc-text">2、统计输入的字符串中各种字符的个数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81static%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">7.10.</span> <span class="toc-text">静态static关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-v4"><span class="toc-number">7.10.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">7.10.2.</span> <span class="toc-text">修饰成员变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-number">7.10.3.</span> <span class="toc-text">修饰成员方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%9B%BE"><span class="toc-number">7.10.4.</span> <span class="toc-text">内存图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">7.10.5.</span> <span class="toc-text">静态代码块</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%B7%A5%E5%85%B7%E7%B1%BBArrays"><span class="toc-number">7.11.</span> <span class="toc-text">数组工具类Arrays</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%98-v6"><span class="toc-number">7.11.0.1.</span> <span class="toc-text">练习题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">7.12.</span> <span class="toc-text">数学工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%98-v7"><span class="toc-number">7.12.0.1.</span> <span class="toc-text">练习题</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">8.</span> <span class="toc-text">继承性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-v5"><span class="toc-number">8.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F"><span class="toc-number">8.2.</span> <span class="toc-text">格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E8%AE%BF%E9%97%AE%E7%89%B9%E7%82%B9"><span class="toc-number">8.3.</span> <span class="toc-text">成员变量的访问特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BA%E5%88%86%E5%AD%90%E7%B1%BB%E6%96%B9%E6%B3%95%E4%B8%AD%E9%87%8D%E5%90%8D%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-number">8.4.</span> <span class="toc-text">区分子类方法中重名的三种方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%E7%9A%84%E8%AE%BF%E9%97%AE%E7%89%B9%E7%82%B9"><span class="toc-number">8.5.</span> <span class="toc-text">成员方法的访问特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E8%A6%86%E7%9B%96%E9%87%8D%E5%86%99"><span class="toc-number">8.6.</span> <span class="toc-text">方法的覆盖重写</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%89%B9%E7%82%B9"><span class="toc-number">8.6.1.</span> <span class="toc-text">概念与特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">8.6.2.</span> <span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">8.6.3.</span> <span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E8%AE%BF%E9%97%AE%E7%89%B9%E7%82%B9"><span class="toc-number">8.7.</span> <span class="toc-text">构造方法的访问特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#super%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%B8%89%E7%A7%8D%E7%94%A8%E6%B3%95"><span class="toc-number">8.8.</span> <span class="toc-text">super关键字的三种用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%B8%89%E7%A7%8D%E7%94%A8%E6%B3%95"><span class="toc-number">8.9.</span> <span class="toc-text">this关键字的三种用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#super%E5%92%8Cthis%E5%85%B3%E9%94%AE%E5%AD%97%E5%9B%BE%E8%A7%A3"><span class="toc-number">8.10.</span> <span class="toc-text">super和this关键字图解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E7%BB%A7%E6%89%BF%E7%9A%84%E4%B8%89%E4%B8%AA%E7%89%B9%E7%82%B9"><span class="toc-number">8.11.</span> <span class="toc-text">Java继承的三个特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1"><span class="toc-number">8.12.</span> <span class="toc-text">抽象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">8.12.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-number">8.12.2.</span> <span class="toc-text">抽象方法和抽象类的格式和使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-v2"><span class="toc-number">8.12.3.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%98-v8"><span class="toc-number">8.13.</span> <span class="toc-text">练习题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B-%E7%BE%A4%E4%B8%BB%E5%8F%91%E6%99%AE%E9%80%9A%E7%BA%A2%E5%8C%85"><span class="toc-number">8.13.1.</span> <span class="toc-text">综合案例:群主发普通红包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="toc-number">8.13.1.1.</span> <span class="toc-text">实现：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">9.</span> <span class="toc-text">接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0%E4%B8%8E%E7%94%9F%E6%B4%BB%E4%BE%8B%E4%B8%BE"><span class="toc-number">9.1.</span> <span class="toc-text">概述与生活例举</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A0%BC%E5%BC%8F"><span class="toc-number">9.2.</span> <span class="toc-text">定义的基本格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">9.3.</span> <span class="toc-text">接口的抽象方法的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="toc-number">9.4.</span> <span class="toc-text">接口的默认方法定义与使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="toc-number">9.5.</span> <span class="toc-text">接口的静态方法定义与使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="toc-number">9.6.</span> <span class="toc-text">接口的私有方法定义与使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B8%B8%E9%87%8F%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-number">9.7.</span> <span class="toc-text">接口的常量定义和使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">9.8.</span> <span class="toc-text">小结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%88%B6%E7%B1%BB%E5%B9%B6%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%A7%8D%E6%8E%A5%E5%8F%A3"><span class="toc-number">9.9.</span> <span class="toc-text">继承父类并实现多种接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E4%B9%8B%E9%97%B4%E7%9A%84%E5%A4%9A%E7%BB%A7%E6%89%BF"><span class="toc-number">9.10.</span> <span class="toc-text">接口之间的多继承</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">10.</span> <span class="toc-text">多态性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-v6"><span class="toc-number">10.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="toc-number">10.2.</span> <span class="toc-text">格式与使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%BF%E7%94%A8%E7%89%B9%E7%82%B9"><span class="toc-number">10.3.</span> <span class="toc-text">成员变量的使用特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8%E7%89%B9%E7%82%B9"><span class="toc-number">10.4.</span> <span class="toc-text">成员方法的使用特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%A4%9A%E6%80%81%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">10.5.</span> <span class="toc-text">使用多态的好处</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B%E5%92%8C%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B"><span class="toc-number">10.6.</span> <span class="toc-text">对象的向上转型和向下转型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8instanceof%E5%85%B3%E9%94%AE%E5%AD%97%E8%BF%9B%E8%A1%8C%E5%88%A4%E6%96%AD"><span class="toc-number">10.7.</span> <span class="toc-text">用instanceof关键字进行判断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%94%E8%AE%B0%E6%9C%ACUSB%E6%8E%A5%E5%8F%A3%E6%A1%88%E4%BE%8B"><span class="toc-number">10.8.</span> <span class="toc-text">笔记本USB接口案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%94%B5%E8%84%91"><span class="toc-number">10.8.1.</span> <span class="toc-text">笔记本电脑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90"><span class="toc-number">10.8.2.</span> <span class="toc-text">案例分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E5%AE%9E%E7%8E%B0"><span class="toc-number">10.8.3.</span> <span class="toc-text">案例实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">11.</span> <span class="toc-text">final关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%94%A8%E6%B3%95"><span class="toc-number">11.1.</span> <span class="toc-text">概念及用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E4%BA%8E%E4%BF%AE%E9%A5%B0%E7%B1%BB"><span class="toc-number">11.2.</span> <span class="toc-text">用于修饰类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E4%BA%8E%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-number">11.3.</span> <span class="toc-text">用于修饰成员方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E4%BA%8E%E4%BF%AE%E9%A5%B0%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">11.4.</span> <span class="toc-text">用于修饰局部变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E4%BA%8E%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">11.5.</span> <span class="toc-text">用于修饰成员变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E7%A7%8D%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">11.6.</span> <span class="toc-text">四种权限修饰符</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">12.</span> <span class="toc-text">内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%88%86%E7%B1%BB"><span class="toc-number">12.1.</span> <span class="toc-text">概念与分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">12.2.</span> <span class="toc-text">成员内部类的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">12.3.</span> <span class="toc-text">成员内部类的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%90%8C%E5%90%8D%E5%8F%98%E9%87%8F%E8%AE%BF%E9%97%AE"><span class="toc-number">12.4.</span> <span class="toc-text">内部类的同名变量访问</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB%E5%AE%9A%E4%B9%89"><span class="toc-number">12.5.</span> <span class="toc-text">局部内部类定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84final%E9%97%AE%E9%A2%98"><span class="toc-number">12.6.</span> <span class="toc-text">局部内部类的final问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E5%8F%8A%E5%85%B6%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">12.7.</span> <span class="toc-text">匿名内部类及其注意事项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E4%BD%9C%E4%B8%BA%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-number">12.8.</span> <span class="toc-text">类作为成员变量类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E4%BD%9C%E4%B8%BA%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-number">12.9.</span> <span class="toc-text">接口作为成员变量类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E4%BD%9C%E4%B8%BA%E6%96%B9%E6%B3%95%E7%9A%84%E5%8F%82%E6%95%B0%E6%88%96%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">12.10.</span> <span class="toc-text">接口作为方法的参数或返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%91%E7%BA%A2%E5%8C%85%E6%A1%88%E4%BE%8B"><span class="toc-number">12.11.</span> <span class="toc-text">发红包案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90"><span class="toc-number">12.11.1.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E7%BA%A2%E5%8C%85%E5%B9%B3%E5%9D%87%E5%88%86%E5%8F%91"><span class="toc-number">12.11.2.</span> <span class="toc-text">普通红包平均分发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%8B%E6%B0%94%E7%BA%A2%E5%8C%85%E9%9A%8F%E6%9C%BA%E5%88%86%E5%8F%91"><span class="toc-number">12.11.3.</span> <span class="toc-text">手气红包随机分发</span></a></li></ol></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg3.png)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/stardust14.github.io/">STAR</a></span><span class="pull-right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/stardust14.github.io/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/stardust14.github.io/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/stardust14.github.io/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/stardust14.github.io/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 放松一下</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/stardust14.github.io/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/stardust14.github.io/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page" href="/stardust14.github.io/photograph/"><i class="fa-fw fas fa-globe"></i><span> Photograph</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/stardust14.github.io/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/stardust14.github.io/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/stardust14.github.io/about/"><i class="fa-fw fas fa-heart"></i><span> 关于me</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">java基础知识学习笔记</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-07-08T05:44:13.000Z" title="发表于 2020-07-08 13:44:13">2020-07-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-07-08T05:44:13.000Z" title="更新于 2020-07-08 13:44:13">2020-07-08</time></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">26.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>106分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1>定义方法</h1>
<h3 id="1、定义一个方法（函数）的格式："><a class="header-anchor" href="#1、定义一个方法（函数）的格式：">¶</a>1、定义一个方法（函数）的格式：</h3>
<pre><code class="language-java">public static void 方法名称()&amp;#123;

	方法体

&amp;#125;
</code></pre>
<h3 id="2、调用方法（函数），格式："><a class="header-anchor" href="#2、调用方法（函数），格式：">¶</a>2、调用方法（函数），格式：</h3>
<p>方法名称();</p>
<p>对于byte/short/char三种类型来说，如果右侧赋值的数值没有超过范围，那么Java编译器将会自动隐含的为我们补上一个（byte）（short）（char）<!--强制转换--></p>
<h1>循环</h1>
<p><strong>三种循环的区别。</strong></p>
<p>1、如果条件判断从来没有满足过，那么for循环和while循环将会执行0次，但是do-while循环会执行至少一次。</p>
<p>2、for循环的变量在小括号当中定义，只有循环内部才可以使用。while循环和do-while循环初始化语句本来就在外面，所以出来循环之后还可以继续使用。</p>
<p><strong>break关键字的用法有常见的两种:</strong><br>
1.可以用在switch语句当中，一旦执行，整个switch语句立刻结束。<br>
2.还可以用在循环语句当中，-一 旦执行，整个循环语句立刻结束。打断循环。<br>
关于循环的选择，有一个小建议:<br>
凡是次数确定的场景多用for循环;否则多用while循环。|</p>
<p><strong>另一种循环控制语句是continue关键字。</strong><br>
一旦执行，立刻跳过当前次循环剩余内容，马上开始下一次循环。</p>
<p>永远停不下来的循环，叫做<strong>死循环</strong>。<br>
死循环的标准格式:<br>
while (true) {<br>
循环体</p>
<p>}</p>
<h1>IDEA的常用快捷键</h1>
<table>
<thead>
<tr>
<th>快捷键</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Alt+Enter</code></td>
<td style="text-align:left">导入包，自动修正代码</td>
</tr>
<tr>
<td><code>Ctrl+Y</code></td>
<td style="text-align:left">删除光标所在行</td>
</tr>
<tr>
<td><code>Ctrl+D</code></td>
<td style="text-align:left">复制光标所在行的内容，插入光标位置下面</td>
</tr>
<tr>
<td><code>Ctrl+Alt+L</code></td>
<td style="text-align:left">格式化代码（使代码规整）</td>
</tr>
<tr>
<td><code>Ctrl+/</code></td>
<td style="text-align:left">单行注释，再按取消注释</td>
</tr>
<tr>
<td><code>Ctrl+Shift+/</code></td>
<td style="text-align:left">选中代码注释，多行注释，再按取消注释</td>
</tr>
<tr>
<td><code>Alt+Ins</code></td>
<td style="text-align:left">自动生成代码，toString, get, set等方法</td>
</tr>
<tr>
<td><code>Alt+Shift+上下箭头</code></td>
<td style="text-align:left">移动当前代码行</td>
</tr>
<tr>
<td><code>Alt+4</code></td>
<td style="text-align:left">控制台调出</td>
</tr>
<tr>
<td><code>Alt+/</code></td>
<td style="text-align:left">缩写提示</td>
</tr>
<tr>
<td><code>shift+F6</code></td>
<td style="text-align:left">对每个相同的变量一次性改变</td>
</tr>
<tr>
<td><code>数字.fori</code></td>
<td style="text-align:left">for循环的快捷方式,【正序】</td>
</tr>
<tr>
<td><code>数字.forr</code></td>
<td style="text-align:left">for循环的快捷方式,【逆序】</td>
</tr>
</tbody>
</table>
<p><strong>注意事项:</strong><br>
对于有返回值的方法，可以使用单独调用、打印调用或者赋值调用。<br>
但是对于无返回值的方法，只能使用单独调用，不能使用打印调用或者赋值调用。</p>
<h1>方法</h1>
<p><strong>使用方法的时候，注意事项:</strong><br>
1、方法应该定义在类当中，但是不能在方法当中再定义方法。不能嵌套。<br>
2、方法定义的前后顺序无所谓。<br>
3、方法定义之后不会执行，如果希望执行，- -定要调用:单独调用、打印调用、赋值调用。<br>
4、如果方法有返回值，那么必须写.上“return 返回值;”，不能没有。</p>
<p>5、return后面的返回值数据，必须和方法的返回值类型，对应起来。<br>
6、对于一个void没有返回值的方法，不能写return后面的返回值，只能写return自己。</p>
<p>7、对于void方法，对于方法当中最后一行的return可以省略不写。</p>
<p>8、一个方法当中可以有多个return语句，但是必须保证同时只有一个会被执行到，两个return不能连写。</p>
<p>判断是否一般用Boolean值</p>
<h2 id="方法重载（overload）"><a class="header-anchor" href="#方法重载（overload）">¶</a><strong>方法重载（overload）</strong></h2>
<p>多个方法的名称一样，但是参数列表不一样</p>
<p>好处是只需要记住唯一一个方法名称，就可以实现类似的多个功能。</p>
<p>在调用输出语句的时候，println方法其实就是进行了多种数据类型的重载形式。</p>
<p><strong>方法重载与下列因素相关:</strong><br>
1、参数个数不同<br>
2、参数类型不同<br>
3、参数的多类型顺序不同<br>
<strong>方法重载与下列因素无关:</strong><br>
1、与参数的名称无关<br>
2、与方法的返回值类型无关</p>
<h3 id="练习题（方法重载）"><a class="header-anchor" href="#练习题（方法重载）">¶</a>练习题（方法重载）</h3>
<p>1、这题也包括了Boolean的是否判断的方法<img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/stardust14/picture/master/img/20200711220604.png" alt="image-20200711220601237"></p>
<p>2、判断是否是重载</p>
<pre><code class="language-java">public static void open()&amp;#123;&amp;#125; //正确重载
public static void open(int a)&amp;#123;&amp;#125; //正确重载.
static void open(int a,int b)&amp;#123;&amp;#125; //代码错误:和第8行冲突
public static void open(double a,int b)&amp;#123;&amp;#125; //正确重载
public static void open(int. a,double. b)&amp;#123;&amp;#125; //代码错误:和第6行冲突
public void open(int i,double d)&amp;#123;&amp;#125; //代码错误:和第5行冲突
public static void OPEN()&amp;#123;&amp;#125; //代码正确不会报错，但是并不是有效重载
public static void. open(int i,int j)&amp;#123;&amp;#125; //代码错误:和第3行冲突
</code></pre>
<h1>数组</h1>
<h2 id="数组的概念"><a class="header-anchor" href="#数组的概念">¶</a>数组的概念</h2>
<pre><code class="language-java">/*
数组的初始化:在内存当中创建一个数组， 并且向其中赋予一些默认值。
两种常见的初始化方式:
1.动态初始化(指定长度)
2.静态初始化(指定内容)
动态初始化数组的格式:
数据类型[]数组名称= new 数据类型[数组长度];
解析含义:
左侧数据类型:也就是数组当中保存的数据，全都是统-的什么类型
左侧的中括号:代表我是一个数组
左侧数组名称:给数组取一个名字
右侧的new:代表创建数组的动作
右侧数据类型:必须和左边的数据类型保持-致
右侧中括号的长度:也就是数组当中，到底可以保存多少个数据，是一个int数字
*/
</code></pre>
<p><strong>区别</strong></p>
<pre><code class="language-java">/*
动态初始化(指定长度) :在创建数组的时候，直接指定数组当中的数据元素个数。
静态初始化(指定内容) :在创建数组的时候，不直接指定数据个数多少，而是直接将具体的数据内容进行指定。
静态初始化基本格式:
数据类型[]数组名称= new 数据类型[] &amp;#123;元素1,元素2，... &amp;#125;;
*/

</code></pre>
<p>使用静态初始化数组的时候，格式还可以省略一下。<br>
标准格式:<br>
数据类型[]数组名称= neW  数据类型[] {元素1,元素2，… };<br>
省略格式:<br>
数据类型[]数组名称= {元素1,元素2，… };</p>
<p><strong>注意事项:</strong><br>
1.静态初始化没有直接指定长度，但是仍然会自动推算得到长度。<br>
2.静态初始化标准格式可以拆分成为两个步骤。<br>
3.动态初始化也可以拆分成为两个步骤。<br>
4.静态初始化一 旦使用省略格式，就不能拆分成为两个步骤了。<br>
<strong>使用建议:</strong><br>
如果不确定数组当中的具体内容，用动态初始化;否则，已经确定了具体的内容，用静态初始化。|</p>
<p>直接打印数组名称，得到的是数组对应的:内存地址哈希值<br>
**访问数组元素的格式:**数组名称[索引值]<br>
索引值:就是一个int数字，代表数组当中元素的编号。<br>
[注意]索引值从开始，- -直到“数组的长度-1为止。</p>
<p>使用<strong>动态初始化数组</strong>的时候，其中的元素将会自动拥有一个默认值。规则如下:<br>
如果是整数类型，那么默认为0;<br>
如果是浮点类型，那么默认为0.0;<br>
如果是字符类型，那么默认为’\u0000’;（看不见）<br>
如果是布尔类型，那么默认为false;<br>
如果是引用类型，那么默认为null。</p>
<p><strong>注意事项:</strong><br>
静态初始化其实也有默认值的过程，只不过系统自动马.上将默认值替换成为了大括号当中的具体数值。</p>
<h2 id="内存划分"><a class="header-anchor" href="#内存划分">¶</a>内存划分</h2>
<p>Java的内存需要划分成为5个部分:<br>
1.<strong>栈(Stack)</strong> :存放的都是方法中的局部变量。<br>
局部变量:方法的参数，或者是方法{}内部的变量<br>
作用域:一旦超出作用域，立刻从栈内存当中消失。<br>
2.<strong>堆(Heap)</strong> :凡是new出来的东西,都在堆当中。<br>
堆内存里面的东西都有一个地址值: 11 6进制<br>
堆内存里面的数据，都有默认值。规则:<br>
如果是整数				默认为0<br>
如果是浮点数			默认为0.0<br>
如果是字符				默认为’\u0000’<br>
如果是布尔				默认为false<br>
如果是引用类型		默认为null<br>
3.<strong>方法区(Method Area)</strong> :存储.class相关信息，包含方法的信息。<br>
4.<strong>本地方法栈(Native Method Stack)</strong> :与操作系统相关。<br>
5.**寄存器(**pc Register) :与CPU相关。</p>
<h2 id="数组的内存图"><a class="header-anchor" href="#数组的内存图">¶</a>数组的内存图</h2>
<p><strong>一个数组的内存图：</strong></p>
<p><img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/stardust14/picture/master/img/20200712164516.png" alt="image-20200712164514236"></p>
<p><strong>两个数组的内存图：</strong></p>
<p><img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/stardust14/picture/master/img/20200712165859.png" alt="image-20200712165123071"></p>
<p><strong>两个引用指向同一个数组的内存图</strong></p>
<p><img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/stardust14/picture/master/img/20200712165840.png" alt="image-20200712165838206"></p>
<h2 id="常见的问题"><a class="header-anchor" href="#常见的问题">¶</a>常见的问题</h2>
<h3 id="1、数组索引越界异常"><a class="header-anchor" href="#1、数组索引越界异常">¶</a><strong>1、数组索引越界异常</strong></h3>
<p>如果访问数组元素的时候，索引编号并不存在，那么将会发生数组索引越界异常<br>
<code>ArrayIndexOutOfBoundsException</code><br>
原因:索引编号写错了。<br>
解决:修改成为存在的正确索引编号。</p>
<h3 id="2、空指针异常"><a class="header-anchor" href="#2、空指针异常">¶</a>2、空指针异常</h3>
<p>所有的引用类型变量，都可以赋值为一-个null值。但是代表其中什么都没有。<br>
数组必须进行new初始化才能使用其中的元素。<br>
如果只是赋值了一个null，没有进行new创建，<br>
那么将会发生:<br>
空指针异常<code>NullPointerException</code><br>
<strong>原因</strong>:忘了new<br>
<strong>解决</strong>:补上new</p>
<h2 id="获取数组的长度"><a class="header-anchor" href="#获取数组的长度">¶</a>获取数组的长度</h2>
<p>如何获取数组的长度，格式:<br>
数组名称. length<br>
这将会得到一个int数字，代表数组的长度。<br>
数组一旦创建，程序运行期间，<em><strong>长度不可改变</strong></em>。</p>
<p><img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/stardust14/picture/master/img/20200712171637.png" alt="image-20200712171219524"></p>
<p><strong>数组的遍历输出：使用for循环</strong></p>
<p><strong>数组的最值：使用for循环和if判断</strong></p>
<h2 id="数组元素反转"><a class="header-anchor" href="#数组元素反转">¶</a>数组元素反转</h2>
<p><img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/stardust14/picture/master/img/20200713111225.png" alt="image-20200713111223768"></p>
<pre><code class="language-java">pub1ic class Demo07ArrayReverse &amp;#123;
public static void main(String[] args) &amp;#123;
int[] array = &amp;#123; 10，20，30，40, 50 &amp;#125;;
//遍历打印数组本来的样子
for (int i = 0; i &lt; array.1ength; i++) &amp;#123;
System. out. println(array[i]);
System.out. println(&quot;===========&quot;);
/*
初始化语句: int min =日, max = array. length - 1
条件判断: min &lt; max
步进表达式: min+t, max--
循环体:用第三个变量倒手
*/
for (int min = 0, max = array.1ength - 1; min &lt; max; min++, max--) &amp;#123;
int temp = array[min] ;
array[min] = array[max];
array[max] = temp;
&amp;#125;
I
//再次打印遍历输出数组后来的样子
for (int i = 0; i &lt; array.1ength; i++) &amp;#123;
System. out. println(array[i]);
&amp;#125;
&amp;#125;
</code></pre>
<h2 id="数组作为方法参数"><a class="header-anchor" href="#数组作为方法参数">¶</a>数组作为方法参数</h2>
<pre><code class="language-java">/*
数组可以作为方法的参数。
当调用方法的时候，向方法的小括号进行传参，传递进去的其实是数组的地址值。
*/
pub1ic class Demo01ArrayParam &amp;#123;
public static void main(String[] args) &amp;#123;
int[]array=&amp;#123;_10，20，30，40，50&amp;#125;;
System. out . println(array); //地址值
printArray(array); //传递进去的就是array当中保存的地址值
System . out. println(&quot;==========AAA==========&quot;);
printArray(array);
System. out. println(&quot;==========BBB-=========&quot;);
printArray(array);
&amp;#125;
/*
三要素
返回值类型:只是进行打印而已，不需要进行计算，也没有结果，用void
方法名称: printArray
参数列表:必须给我数组，我才能打印其中的元素。int[] array
*/
public static void printArray(int[] array) &amp;#123;
System . out. println(&quot;printArray方法收到的参数是: &quot;);
System. out . println(array); //地址值
for (int i = 0; i &lt; array. length; i++) &amp;#123;
System. out. println(array[i]);
&amp;#125;
&amp;#125;
</code></pre>
<p>得到的结果：</p>
<p><img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/stardust14/picture/master/img/20200713112817.png" alt="image-20200713112816224"></p>
<h2 id="数组作为方法返回值"><a class="header-anchor" href="#数组作为方法返回值">¶</a>数组作为方法返回值</h2>
<pre><code class="language-java">/*
一个方法可以有0、1、多个参数;但是只能有0或者1个返回值，不能有多个返回值。
如果希望一个方法当中产生了多个结果数据进行返回，怎么办?
解决方案:使用一个数组作为返回值类型即可。

任何数据类型都能作为方法的参数类型，或者返回值类型。

数组作为方法的参数，传递进去的其实是数组的地址值。
数组作为方法的返回值，返回的其实也是数组的地址值。
*/
public class Demo02ArrayReturn &amp;#123;
public static void main(String[] args) &amp;#123;
	int[] result = calculate( a: 10，b: 20，C: 30);
    System. out . println( &quot;main方法接收到的返回值数组是: &quot;);
	System. out. println(result);

	System. out. println(&quot;总和: &quot; + result[0]);
	System. out. println(&quot;平均数:&quot; + result[1]);
public static int[] calculate(int a, int b，int c) &amp;#123;
	intsum=a+b+c;//总和
	intavg=sum/3;//平均数
	//两个结果都希望进行返回
	//需要一个数组，也就是一个塑料兜，数组可以保存多个结果
	/*这是一种方法
	int[] array = new int[2];
	array[0] = sum; //总和
	array[1] = avg; //平均数
	*/
    //这是另一种方法
	int[ ] array = &amp;#123; sum， avg &amp;#125;;
    System. out . println(&quot;calculate方法内部数组是: &quot;); 
	System. out . println(array); //地址值

	return array;
	&amp;#125;
&amp;#125;
</code></pre>
<p>输出的结果：</p>
<p><img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/stardust14/picture/master/img/20200713113840.png" alt="image-20200713113838924"></p>
<h1>面向对象思想</h1>
<h2 id="概述"><a class="header-anchor" href="#概述">¶</a>概述</h2>
<pre><code class="language-java">/*
面向过程:当需要实现-个功能的时候，每一一个具体的步骤都要亲力亲为，详细处理每一个细节 。
面向对象:当需要实现一个功能的时候，不关心具体的步骤，而是找一个已经具有该功能的人，来帮我做事儿。
*/
public class Demo01PrintArray &amp;#123;
	public static void main(String[] args) &amp;#123;
		int[] array = &amp;#123; 10，20，30， 40， 50， 60 &amp;#125;;
	//要求打印格式为: [10, 20，30, 40, 50]
	//使用面向过程，每一个步骤细节都要 亲力亲为。
		System. out. print(&quot;[&quot;);
		for (int i = 0; i &lt; array.1ength; i++) &amp;#123;
			if (i == array. length - 1) &amp;#123; //如果是最后一个元素
			System. out . println(array[i] + &quot;]&quot;);
			&amp;#125; else &amp;#123; //如果不是最后一-个元素
			System. out . print(array[i] + &quot;，&quot;);
	&amp;#125;
&amp;#125;
			System. out . print1n(&quot;============&quot;);
			//使用面向对象
       	 	//找一个JDk给我们提供好的Arrays类,
			//其中有一个toString方法，直接就能把数组变成想要的格式的字符串
			System. out . println(Arrays . toString(array));
	&amp;#125;
&amp;#125;
</code></pre>
<p>●面向过程:强调步骤。<br>
●面向对象:强调对象，这里的对象就是洗衣机。</p>
<p>特点：</p>
<p>面向对象思想是一种更符合我们思考习惯的思想，它可以将复杂的事情简单化，并将我们从执行者变成了指挥者。<br>
面向对象的语言中，包含了三大<strong>基本特征</strong>，即封装、继承和多态。</p>
<h2 id="类和对象"><a class="header-anchor" href="#类和对象">¶</a>类和对象</h2>
<h3 id="类"><a class="header-anchor" href="#类">¶</a>类</h3>
<p>●类:是一组相关属性和行为的集合。可以看成是一 类事物的模板,使用事物的属性特征和行为特征来描述该类<br>
事物。<br>
现实中，描述一类事物:<br>
●属性:就是该事物的状态信息。<br>
●行为:就是该事物能够做什么。</p>
<h3 id="对象"><a class="header-anchor" href="#对象">¶</a>对象</h3>
<p>●对象:是一类事物的具体体现。对象是类的一个实例(对象并不是找个女朋友) ,必然具备该类事物的属性和行为。</p>
<h3 id="类和对象的关系"><a class="header-anchor" href="#类和对象的关系">¶</a>类和对象的关系</h3>
<p>●类是对一类事物的描述,是抽象的。<br>
●对象是一类事物的实例，是具体的。<br>
●类是对象的模板，对象是类的实体。</p>
<h2 id="类的定义"><a class="header-anchor" href="#类的定义">¶</a>类的定义</h2>
<h3 id="事物与类的对比"><a class="header-anchor" href="#事物与类的对比">¶</a>事物与类的对比</h3>
<p>现实世界的一类事物:<br>
<strong>属性</strong>:事物的状态信息。<br>
<strong>行为</strong>:事物能够做什么。<br>
Java中用class描述事物也是如此:<br>
<strong>成员变量</strong>:对应事物的属性<br>
<strong>成员方法</strong>:对应事物的行为</p>
<h3 id="类定义的格式"><a class="header-anchor" href="#类定义的格式">¶</a>类定义的格式</h3>
<pre><code class="language-java">public class ClassName &amp;#123;
//成员变量
//成员方法
&amp;#125;
</code></pre>
<p>●<strong>定义类:<strong>就是定义类的成员，包括成员变量和成员方法。<br>
●</strong>成员量:<strong>和以前定义变量几乎是一样的。只不过位置发生了改变。<strong>在类中，方法外。</strong><br>
●</strong>成员方法:<strong>和以前定义方法几乎是一样的。只不过把</strong>static</strong>去掉， <strong>static</strong>的作用在面向对象后面课程中再详细讲解。</p>
<p><strong>注意事项:</strong><br>
1.成员变量是直接定义在类当中的，在方法外边。<br>
2.成员方法不要写static关键字。</p>
<h2 id="对象的创建及其使用"><a class="header-anchor" href="#对象的创建及其使用">¶</a>对象的创建及其使用</h2>
<pre><code class="language-java">/*
通常情况下，一个类并不能直接使用，需要根据类创建一个对象， 才能使用。
1.导包:也就是指出需要使用的类，在什么位置。
import包名称.类名称;
import cn. itcast. day06. demo01. Student;
对于和当前类属于同一-个包的情况，可以省略导包语句不写。
2.创建,格式:
类名称对象名= new
类名称();
Student stu = new Student();
3.使用，分为两种情况:
使用成员变量:对象名.成员变量名
使用成员方法:对象名.成员方法名(参数)
(也就是，想用谁，就用对象名点儿谁。)

注意事项:
如果成员变量没有进行赋值，那么将会有一个默认值，规则和数组一样。
*/

public static void main(String[] args) &amp;#123;
	// 1.导包。
	//我需要使用的Student类,和我自己Demo02Student位于同一一个包下，所以省略导包语句不写
	// 2.创建，格式:
	//类名称对象名= new类名称();
	//根据Student类，创建了一个名， 为stu的对象
	Student stu = new Student();
    
	// 3.使用其中的成员变量，格式:
	//对象名.成员变量名.
	System. out. println(stu. name); // null
	System. out . println(stu.age); //0
	System. out . print1n(&quot;==========&quot;);
    
	//改变对象当中的成员变量数值内容
	//将右侧的字符串，赋值交给stu对象当中的name成员变量
	stu.name =“赵丽颖”;
	stu.age = 18;
	System. out . println(stu.name); //赵丽颖
	System. out . println(stu.age); // 18
    System. out . print1n(&quot;==========&quot;);
    
    // 4.使用对象的成员方法，格式:
	//对象名.成员方法名()
	stu.eat();//吃饭饭！
&amp;#125;
</code></pre>
<h3 id="手机类的练习题"><a class="header-anchor" href="#手机类的练习题">¶</a>手机类的练习题</h3>
<pre><code class="language-java">/*
这是手机类
定义一个类，用来模拟“手机”事物。
属性:品牌、价格、颜色
行为:打电话、发短信
对应到类当中:
成员变量(属性) :
String brand; //品牌
double price; //价格.
String color; //颜色
成员方法(行为) :
public void call(String who) &amp;#123;&amp;#125; //打电话
public void sendMessage() &amp;#123;&amp;#125; //群发短信
*/
pub1ic class Phone &amp;#123;
		//成员变量
		String brand; //品牌
		double price; //价格
		String color; //颜色
		//成员方法
	public void call(String who) &amp;#123;
		System. out. println(&quot;给&quot; + who + &quot;打电话&quot;);
	&amp;#125;
	public void sendMessage() &amp;#123;
		System. out . println(&quot;群发短信&quot;);
	&amp;#125;
&amp;#125;
</code></pre>
<pre><code class="language-java">//调用phone
public static void main(String[] args) &amp;#123;
	//根据Phone类，创建一个名为 one的对象
	//格式:类名称对象名= new类名称();
	Phone one = new Phone();
	System. out. println(one.brand); // null
	System. out . println(one.price); // 0.0
	System. out . println(one.co1or); // null
	System. out. println(&quot;=========&quot;);
	
	one.brand = &quot;苹果&quot;;
	one.price = 8388.0;
	one.color = &quot;黑色&quot;;
	System. out . println(one . brand); //苹果
	System. out. println(one.price); // 8388.0
	System. out . println(one.color); //黑色
    System. out. println(&quot;=========&quot;);
    
    one.call( who:&quot;乔布斯&quot;) ;
	one.sendMessage();

&amp;#125;
</code></pre>
<h2 id="一个对象的内存图"><a class="header-anchor" href="#一个对象的内存图">¶</a>一个对象的内存图</h2>
<p>new的东西全在堆之中</p>
<p>压栈，先来的在底下，后进先出，先进后出</p>
<p>黑色的X代表出栈</p>
<p><img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/stardust14/picture/master/img/20200715185054.png" alt="image-20200715184735566"></p>
<h2 id="两个对象使用同一个方法的内存图"><a class="header-anchor" href="#两个对象使用同一个方法的内存图">¶</a>两个对象使用同一个方法的内存图</h2>
<p><img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/stardust14/picture/master/img/20200715185842.png" alt="image-20200715185840625"></p>
<h2 id="两个引用指向同一个对象的内存图"><a class="header-anchor" href="#两个引用指向同一个对象的内存图">¶</a>两个引用指向同一个对象的内存图</h2>
<p><img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/stardust14/picture/master/img/20200715190554.png" alt="image-20200715190552009"></p>
<h2 id="使用对象类型作为方法的参数"><a class="header-anchor" href="#使用对象类型作为方法的参数">¶</a>使用对象类型作为方法的参数</h2>
<p><img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/stardust14/picture/master/img/20200716224605.png" alt="image-20200716223939500"></p>
<p><strong>注意：<strong>当一个对象作为参数，传递到方法当中时，实际上传递进去的是对象的</strong>地址值</strong>。</p>
<h2 id="使用对象类型作为方法的返回值"><a class="header-anchor" href="#使用对象类型作为方法的返回值">¶</a>使用对象类型作为方法的返回值</h2>
<p><img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="../../../picture/PicGo/copypicture/image-20200717164340634.png" alt="image-20200717164340634"></p>
<h2 id="成员变量和局部变量的区别"><a class="header-anchor" href="#成员变量和局部变量的区别">¶</a>成员变量和局部变量的区别</h2>
<p>局部变量和成员变量<br>
1.定义的位置不一样[重点]<br>
局部变量:在方法的内部<br>
成员变量:在方法的外部，直接写在类当中<br>
2.作用范围不一样[重点]<br>
局部变量:只有方法当中才可以使用，出了方法就不能再用<br>
成员变量:整个类全都可以通用,<br>
3.默认值不一样[重点]<br>
局部变量:没有默认值，如果要想使用，必须手动进行赋值<br>
成员变量:如果没有赋值，会有默认值，规则和数组一样<br>
方法的参数就是局部变量，参数在方法调用的时候，必然会被赋值的<br>
4.内存的位置不一样(了解)<br>
局部变量:位于栈内存<br>
成员变量:位于堆内存<br>
5.生命周期不一样(了解)<br>
局部变量:随着方法进栈而诞生，随着方法出栈而消失<br>
成员变量:随着对象创建而诞生，随着对象被垃圾回收而消失</p>
<h2 id="面向对象三大特征之封装性"><a class="header-anchor" href="#面向对象三大特征之封装性">¶</a>面向对象三大特征之封装性</h2>
<p>面向对象三大特征:封装、继承、多态。<br>
封装性在Java当中的体现:<br>
1.方法就是一种封装<br>
2.关键字private也是一种封装<br>
封装就是将一些细节信息隐藏起来， 对于外界不可见。</p>
<pre><code class="language-java">/*
问题描述:定义Person的年龄时，无法阻止不合理的数值被设置进来。
解决方案:用private关键字将需要保护的成员变量进行修饰。
一旦使用了private进行修饰，那么本类当中仍然可以随意访问。
但是!超出了本类范围之外就不能再直接访问了。
	
间接访问private成员变量，就是定义一对儿Getter/Setter方法
必须叫setXxx或者是getXxx命名规则。
对于Getter来说，不能有参数，返回值类型和成员变量对应;
对于Setter来说，不能有返回值，参数类型和成员变量对应。
*/
public class Person &amp;#123;
    
	String name; // 姓名.
	private int age; //年龄
	pub1ic void show() &amp;#123;
	System. out . println(&quot;我叫:&quot;+ name + &quot;,年龄:&quot; + age);
	//这个成员方法，专门用于向age设置数据,往age里放
	public void setAge(int num) &amp;#123;//set必须有参数无返回值void
			if(num&lt;100&amp;&amp;num&gt;=0)&amp;#123;//如果是合理情况
				age = num;
				&amp;#125; else &amp;#123;
				System. out. println( &quot;数据不合理! &quot;);
			&amp;#125;

    &amp;#125;
        //这个成员方法，专门私语获取age的数据
		public int getAge() &amp;#123;//get必须没有参数，有返回值
		return age;
        &amp;#125;
  &amp;#125;
</code></pre>
<pre><code class="language-java">public class Demo03Person &amp;#123;
	public static void main(String[] args) &amp;#123;
		Person person = new Person();
		person. show( ) ;
		person. name =“赵丽颖&quot;;
		//person. age= -20; //直接访问private内容，错误写法!
		person. setAge(20) ;|
		person. show();
&amp;#125;
&amp;#125;
</code></pre>
<h2 id="练习题"><a class="header-anchor" href="#练习题">¶</a>练习题</h2>
<pre><code class="language-java">/*
对于基本类型当中的boolean值，Getter方法一 -定 要写成isXxx的形式，而setXxx规则不变。
*/
public class Student &amp;#123;
    
	private String name; //姓名
	private int age; //年龄
	private boolean male; //是不是爷们儿
    
	public void setMale(boolean b) &amp;#123;
		male=b;
	&amp;#125;
    
	public boolean isMale() &amp;#123;
		return male ;
    &amp;#125;
    
	public void setName(String str) &amp;#123;
		name = str;
	&amp;#125;
    
	public String getName() &amp;#123;
		return name;
	&amp;#125;
    
	public void setAge(int num) &amp;#123;
		age = num;
	&amp;#125;
&amp;#125;
</code></pre>
<h2 id="this关键字的作用"><a class="header-anchor" href="#this关键字的作用">¶</a>this关键字的作用</h2>
<p>当方法的局部变量和类的成员变量重名的时候，根据“就近原则”，优先使用局部变量。<br>
如果需要访问本类当中的成员变量，需要使用格式:<br>
this.成员变量名<br>
“通过谁调用的方法，谁就是this。”</p>
<pre><code class="language-java">publiC class Person &amp;#123;
	String name; //我自己的名字
	//参数name是对方的名字
	//成员变量name是自己的名字
	public void sayHello(String name) &amp;#123;
	System. out . println(name + &quot;,你好。我是&quot;+ this. name);
&amp;#125;
&amp;#125;
</code></pre>
<h2 id="构造方法"><a class="header-anchor" href="#构造方法">¶</a>构造方法</h2>
<p>构造方法是专门用来创建对象的方法，当我们通过关键字new来创建对象时，其实就是在调用构造方法。<br>
格式:<br>
public类名称(参数类型参数名称) {<br>
方法体<br>
注意事项:<br>
1.构造方法的名称必须和所在的类名称完全-样，就连大小写也要一样<br>
2.构造方法不要写返回值类型，连void都不写<br>
3.构造方法不能return一个具体的返回值<br>
4.如果没有编写任何构造方法，那么编译器将会默认赠送一 个构造方法，没有参数、方法体什么事情都不做。<br>
public Student() {}<br>
5.一旦编写了至少一个构造方法，那么编译器将不再赠送。<br>
6.构造方法也是可以进行重载的。<br>
重载:方法名称相同，参数列表不同。</p>
<pre><code class="language-java">public class Student &amp;#123;
	private String name;
	private int age; 
	public Student() &amp;#123;
		System. out . print1n(“无参构造方法执行啦! &quot;);
	&amp;#125;
	public Student(String name, int age) &amp;#123;
		System. out . println(&quot;全参构造方法执行啦! &quot;);
		this.name = name ;
		this.age = age;
	&amp;#125;
    public void setName(String name) &amp;#123;
		this.name = name;
	&amp;#125;
	public String getName() &amp;#123;
		return name ;
	&amp;#125;
	public void setAge(int age) &amp;#123;
		this.age = age;
	&amp;#125;
	public int getAge() &amp;#123;
		return age;
	&amp;#125;
&amp;#125;

</code></pre>
<pre><code class="language-java">public class Demo02Student &amp;#123;
	public static void main(String[] args) &amp;#123;
		Student stul = new Student(); //无参构造
		System. out . println(&quot;===========&quot;);
		Student stu2 = new Student( name: “赵丽颖&quot;，age: 20); //全参构造
		System. out . println(&quot;姓名:”+ stu2. getName() + &quot;，年龄:”+ stu2.getAge());
        //如果需要改变对象当中的成员变量数据内容，仍然还需要使用setXxx方法
		stu2. setAge(21); //改变年龄
		System. out . println(&quot;姓名:”+ stu2.getName() + &quot;，年龄:”+ stu2.getAge());               
	&amp;#125;
&amp;#125;
</code></pre>
<h2 id="定义一个标准的类"><a class="header-anchor" href="#定义一个标准的类">¶</a>定义一个标准的类</h2>
<p><strong>一个标准的类通常要拥有下面四个组成部分:</strong><br>
<strong>1.所有的成员变量都要使用private关键字修饰</strong><br>
<strong>2.为每一个成员变量编写一对儿Getter/Setter方法</strong><br>
<strong>3.编写一个无参数的构造方法</strong><br>
<strong>4.编写一个全参数的构造方法</strong><br>
<strong>这样标准的类也叫做Java Bean</strong></p>
<p><strong>自动生成</strong>*<u>Getter/Setter方法</u>*：Code----&gt;Generate(Alt+inset)-----&gt;Getter and Setter------&gt;全部选中（shift）+ok</p>
<p><strong>自动生成</strong>*<u>无参数的构造方法</u>*：Code----&gt;Generate(Alt+inset)-----&gt;Constructor-------&gt;Select None</p>
<p><strong>自动生成</strong>*<u>全参数的构造方法</u>*：Code----&gt;Generate(Alt+inset)-----&gt;Constructor-------&gt;全部选中（shift）+ok</p>
<pre><code class="language-java">public class Student &amp;#123;

    private String name;//姓名
    private int age;//年龄

    public Student() &amp;#123;
    &amp;#125;

    public Student(String name, int age) &amp;#123;
        this.name = name;
        this.age = age;
    &amp;#125;

    public String getName() &amp;#123;
        return name;
    &amp;#125;

    public void setName(String name) &amp;#123;
        this.name = name;
    &amp;#125;

    public int getAge() &amp;#123;
        return age;
    &amp;#125;

    public void setAge(int age) &amp;#123;
        this.age = age;
    &amp;#125;
&amp;#125;
</code></pre>
<pre><code class="language-java">public class Dome01Student &amp;#123;
    public static void main(String[] args) &amp;#123;
        Student stu1 = new Student();
        stu1.setName(&quot;霉霉&quot;);
        stu1.setAge(20);
        System.out.println(&quot;姓名：&quot;+stu1.getName() +&quot;年龄：&quot;+stu1.getAge());
        System.out.println(&quot;================&quot;);

        Student stu2 = new Student(&quot;水果姐&quot;,20);
        System.out.println(&quot;姓名：&quot;+stu2.getName() +&quot;年龄：&quot;+stu2.getAge());
        stu2.setAge(22);
        System.out.println(&quot;姓名：&quot;+stu2.getName() +&quot;年龄：&quot;+stu2.getAge());

    &amp;#125;
&amp;#125;
</code></pre>
<h1>API</h1>
<h2 id="概述-v2"><a class="header-anchor" href="#概述-v2">¶</a>概述</h2>
<p>API(Application Programming Interface),应用程序编程接口。Java API是一本程序员的<code>字典</code>，是JDK中提供给我们使用的类的<strong>说明文档</strong>。这些类将底层的代码实现封装了起来，我们不需要关心这些类是如何实现的,只需要学习这些类如何使用即可。所以我们可以通过查询API的方式，来学习Java提供的类，并得知如何使用它们。</p>
<h2 id="API使用步骤"><a class="header-anchor" href="#API使用步骤">¶</a>API使用步骤</h2>
<p>1.打开帮助文档。<br>
2.点击显示，找到索引，看到输入框。<br>
3.你要找谁?在输入框里输入，然后回车。<br>
4.看包。java.lang 下的类不需要导包，其他需要。<br>
5.看类的解释和说明。<br>
6.学习构造方法。<br>
7.使用成员方法。</p>
<h2 id="Scanner类"><a class="header-anchor" href="#Scanner类">¶</a>Scanner类</h2>
<h3 id="概述-v3"><a class="header-anchor" href="#概述-v3">¶</a>概述</h3>
<p>一个可以解析基本类型和字符串的简单文本扫描器。<br>
例如，以吓代码使用户能够从System.in中读取一个数:</p>
<pre><code class="language-java">Scanner sC = new Scanner(System. in);
int i = sc.nextInt();
</code></pre>
<blockquote>
<p>备注: <a target="_blank" rel="noopener" href="http://System.in">System.in</a> 系统输入指的是通过键盘录入数据。</p>
</blockquote>
<h3 id="使用步骤"><a class="header-anchor" href="#使用步骤">¶</a>使用步骤</h3>
<pre><code class="language-java">import java. util . Scanner;// 1.导包

/*
**Scanner类的功能:**可以实现键盘输入数据，到程序当中。
引用类型的一般使用步骤: 
**1.导包**
import包路径.类名称;
如果需要使用的目标类，和当前类位于同- -个包下，则可以省略导包语句不写。
只有java. lang包下的内容不需要导包，其他的包都需要import语句。
**2.创建**
类名称对象名= new 类名称();
**3.使用**
对象名.成员方法名()
获取键盘输入的一个int数字: int num = sc. nextInt();
获取键盘输入的一个字符串: String str =sc.next();

*/
public class Demo01Scanner &amp;#123;
    
	public static void main(String[] args) &amp;#123;
		// 2.创建
		//备注: System. in代表从键盘进行输入
		Scanner sc = new Scanner(System. in);
		// 3.获取键盘输入的int数字
		int num = sc.nextInt( );
		System. out. println( &quot;输入的int数字是:&quot; + num);
       // 4.获取键盘输入的字符串
		String str = sc.next( );
		System. out . println( &quot;输入的字符串是:&quot; + str);

	&amp;#125;
&amp;#125;

</code></pre>
<h4 id="练习题-v2"><a class="header-anchor" href="#练习题-v2">¶</a>练习题</h4>
<p>1、键盘输入两个int数字，并求出和值</p>
<pre><code class="language-java">import java.util.Scanner;

public class Dome01ScannerSum &amp;#123;
    public static void main(String[] args) &amp;#123;
        Scanner src = new Scanner(System.in);

        System.out.println(&quot;请输入第一个数字：&quot;);
        int a = src.nextInt();
        System.out.println(&quot;请输入第二个数字：&quot;);
        int b = src.nextInt();

        int result = a + b ;
        System.out.println(&quot;结果是：&quot; + result);
    &amp;#125;
&amp;#125;
</code></pre>
<p>2、键盘输入三个int数字，然后求出其中的最大值</p>
<pre><code class="language-java">import java.util.Scanner;
/*
题目:
键盘输入三个int数字，然后求出其中的最大值。
思路，
芯岭:
1.既然是键盘输入，肯定需要用到Scanner
2. Scanner三个步骤:导包、创建、使用nextInt()方法
3. 既然是三个数字，那么调用三次nextInt()方法，得到三个int变量
4.无法同时判断三个数字谁最大，应该转换成为两个步骤:
    4.1首先判断前两个当中谁最大，拿到前两个的最大值
    4.2拿着前两个中的最大值，再和第三个数字比较，得到三个数字当中的最大值
5.打印最终结果
 */

public class Dome01ScannerMax &amp;#123;
    public static void main(String[] args) &amp;#123;

        int [] array = new int[]&amp;#123;&amp;#125;;

        Scanner src = new Scanner(System.in);
        System.out.println(&quot;请输入第一个数字:&quot;);
        int a = src.nextInt();

        System.out.println(&quot;请输入第二个数字:&quot;);
        int b = src.nextInt();

        System.out.println(&quot;请输入第三个数字:&quot;);
        int c = src.nextInt();

       int temp = a &gt; b ? a:b;
       int max = temp &gt; c ? temp:c;
        System.out.println(&quot;结果：&quot;+max);


    &amp;#125;

&amp;#125;
</code></pre>
<h2 id="匿名对象的说明"><a class="header-anchor" href="#匿名对象的说明">¶</a>匿名对象的说明</h2>
<pre><code class="language-java">/*
创建对象的标准格式:
类名称 对象名= new 类名称();
匿名对象就是只有右边的对象，没有左边的名字和赋值运算符。
new.类名称();

注意事项：
匿名对象只能使用唯一-的一 次，下次再用不得不再创建一个新对 象。
使用建议:如果确定有一个对象只需要使用唯一 的一 次，就可以用匿名对象。
*/
public class Dome02Anonymous &amp;#123;
    public static void main(String[] args) &amp;#123;
        Person one = new Person();
        one.name = &quot;泰勒斯威夫特&quot;;//我叫泰勒斯威夫特
        one.ShowName();
        System.out.println(&quot;=========&quot;);

        new Person().name=&quot;Rose&quot;;
        new Person().ShowName();//我叫null
    &amp;#125;
&amp;#125;
</code></pre>
<h2 id="匿名对象作为方法的参数和返回值"><a class="header-anchor" href="#匿名对象作为方法的参数和返回值">¶</a>匿名对象作为方法的参数和返回值</h2>
<pre><code class="language-java">import java.util.Scanner;

public class Dome03Anonymous &amp;#123;
    public static void main(String[] args) &amp;#123;
        //普通使用方式
        Scanner src = new Scanner(System.in);
        System.out.println(&quot;请输入数值：&quot;);
        int num1 = src.nextInt();
        System.out.println(&quot;===========&quot;);
        System.out.println(&quot;输入的结果是：&quot;+ num1);
        System.out.println(&quot;============&quot;);

        //匿名对象的方式
        System.out.println(&quot;请输入数值：&quot;);
        int num2 = new Scanner(System.in).nextInt();
        System.out.println(&quot;输入的结果是：&quot;+ num2);
        System.out.println(&quot;============&quot;);

        //使用一般方法传入参数
//        Scanner sc = new Scanner(System.in);
//        methodParam(sc);

        //使用匿名对象来进行传递参数
        methodParam(new Scanner(System.in));

        Scanner sc = methodreturn();
        int num3=sc.nextInt();
        System.out.println(&quot;输出：&quot;+num3);
        System.out.println(&quot;============&quot;);
    &amp;#125;
    public static void methodParam(Scanner sc)&amp;#123;
        int num = sc.nextInt();
        System.out.println(&quot;输入的是：&quot;+ num);
        System.out.println(&quot;============&quot;);

    &amp;#125;
    public static Scanner methodreturn()&amp;#123;
//        Scanner sc = new Scanner(System.in);
//        return sc;
        return new Scanner(System.in);
    &amp;#125;
&amp;#125;
</code></pre>
<h2 id="Random"><a class="header-anchor" href="#Random">¶</a>Random</h2>
<h3 id="概述和基本使用"><a class="header-anchor" href="#概述和基本使用">¶</a>概述和基本使用</h3>
<pre><code class="language-java">/*
Random类用来生成随机数字。使用起来也是三个步骤:
1.导包
import java . util . Random;
2.创建
Random r = new Random(); //小括号当中留空即可
3.使用
获取一个随机的int数字(范围是int所有范围，有正负两种) : int num =r.nextInt()
获取一个随机的int数字(参数代表了范围，左闭右开区间) : int num = r. nextInt(3)
实际上代表的含义是: [0,3)， 也就是0~2

*/

import java.util.Random;

public class Dome01Random &amp;#123;
    public static void main(String[] args) &amp;#123;
        Random r = new Random();
        int num = r.nextInt();
        System.out.println(&quot;随机数为：&quot;+num);
        System.out.println(&quot;============&quot;);

        for (int i = 0; i &lt; 100; i++) &amp;#123;
            int num1 = r.nextInt(10);
            System.out.println(num1);
        &amp;#125;
    &amp;#125;
&amp;#125;
</code></pre>
<h4 id="练习题-v3"><a class="header-anchor" href="#练习题-v3">¶</a>练习题</h4>
<p>1、生成1-n之间的随机数</p>
<pre><code class="language-java">import java.util.Random;

/*
题目要求:
根据int变量n的值，来获取随机数字，范围是[1,n]， 可以取到1也可以取到n。
思路
1.定义一个int变量n，随意赋值
2.要使用Random: 三个步骤，导包、创建、使用
3.如果写10，那么就是0~9，然而想要的是1~10，可以发现:整体+1即可。
4.打印随机数字
*/
public class Dome02Random &amp;#123;
    public static void main(String[] args) &amp;#123;
        int n = 10;
        Random r = new Random();
        //第一种方法
            int num = r.nextInt(n);
            System.out.println(num + 1);
        System.out.println(&quot;==========&quot;);
        //第二种方法
        int result = r.nextInt(n) + 1;
        System.out.println(result);//本来范围是[0,1)，整体+1之后变成了[1,n+1)， 也就是[1,n]

    &amp;#125;
&amp;#125;
</code></pre>
<p>2、猜数字小游戏</p>
<pre><code class="language-java">/*
题目:
用代码模拟猜数字的小游戏。
思路:
1.首先需要产生一个随机数字，并且- - 旦产生不再变化。用Random的nextInt方法
2.需要键盘输入，所以用到了Scanner
3.获取键盘输入的数字，用Scanner当中的nextInt方法
4.已经得到了两个数字，判断(if) -下:
    如果太大了，提示太大，并且重试;
    如果太小了，提示太小，并且重试:
    如果猜中了，游戏结束。
5.重试就是再来一次， 循环次数不确定，用while(true)。
*/

import java.util.Random;
import java.util.Scanner;

public class Dome03RandomGame &amp;#123;
    public static void main(String[] args) &amp;#123;
        Random r = new Random();
        int num = r.nextInt(100)+1;//范围是在[1，100]区间

        Scanner sc = new Scanner(System.in);

        while (true) &amp;#123;
            System.out.println(&quot;请输入你猜测的数字：&quot;);
            int num1 = sc.nextInt();//读取键盘输入的数字
            if (num1 &lt; num) &amp;#123;
                System.out.println(&quot;猜测的数字偏小，请重新输入！&quot;);
            &amp;#125; else if (num1 &gt; num) &amp;#123;
                System.out.println(&quot;猜测的数字偏大，请重新输入！&quot;);
            &amp;#125; else&amp;#123;
                System.out.println(&quot;恭喜你猜对了！！！！！&quot;);
                break;//Game over 退出游戏
            &amp;#125;
        &amp;#125;
    &amp;#125;
&amp;#125;
</code></pre>
<h2 id="对象数组"><a class="header-anchor" href="#对象数组">¶</a>对象数组</h2>
<pre><code class="language-java">/*
题目:
定义一个数组，用来存储3个Person对象。

数组有一个缺点：一旦创建，程序运行期间长度不可以发生改变
 */
public class Dome04Array &amp;#123;
    public static void main(String[] args) &amp;#123;
        //首先创建一个长度为3的数组，里面用来存放Person类型的对象
        Person [] array = new Person[3];

        Person one = new Person(&quot;霉霉&quot;,18);
        Person two = new Person(&quot;水果姐&quot;,18);
        Person three = new Person(&quot;Rechel&quot;,20);

        array[0] = one;  //将one当中的地址值赋值到数组的0号元素位置
        array[1] = two;//将two当中的地址值赋值到数组的1号元素位置
        array[2] = three;//将three当中的地址值赋值到数组的2号元素位置

        System.out.println(array[0].getName() + &quot;  &quot;+ array[0].getAge());
        System.out.println(array[1].getName() + &quot;  &quot; + array[1].getAge());
        System.out.println(array[2].getName() + &quot;  &quot; + array[2].getAge());
    &amp;#125;
&amp;#125;
</code></pre>
<h2 id="ArrayList类"><a class="header-anchor" href="#ArrayList类">¶</a>ArrayList类</h2>
<p><code>java.util. Arraylist</code> 是<strong>大小可变的数组</strong>的实现，存储在内的数据称为元素。此类提供一 些方法来操作内部存储的元素。<code>ArrayList</code> 中可不断添加元素，其大小也自动增长。</p>
<blockquote>
<p>和数组的区别：<br>
数组的长度不可以发生改变。<br>
但是ArrayList集合的长度是可以随意变化的。</p>
</blockquote>
<h3 id="基本使用和概述"><a class="header-anchor" href="#基本使用和概述">¶</a>基本使用和概述</h3>
<pre><code class="language-java">import java.util.ArrayList;

/*

对于ArrayList来说，有一个尖括号&lt;E&gt;代表泛型。
泛型:也就是装在集合当中的所有元素，全都是统- -的什么类型。
注意:泛型只能是引用类型，不能是基本类型。

注意事项:
对于ArrayList集合来说，直接打印得到的不是地址值，而是内容。
如果内容是空，得到的是空的中括号: []

 */
public class Dome05ArrayList &amp;#123;
    public static void main(String[] args) &amp;#123;
        //创建了一个ArrayList集合，集合的名称是list， 里面装的全都是String字符串类型的数据
        //备注:从JDK 1.7+开始，右侧的尖括号内部可以不写内容，但是&lt;&gt;本身还是要写的。
        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
        System.out.println(list);

        //向集合中放一些数据，需要用到add方法
        list.add(&quot;Rose&quot;);
        System.out.println(list);
        System.out.println(&quot;===========&quot;);

        list.add(&quot;Rechel&quot;);
        list.add(&quot;Manica&quot;);
        list.add(&quot;Jeoy&quot;);
        list.add(&quot;Phobe&quot;);
        list.add(&quot;Bing&quot;);
        System.out.println(list);

        //list.add(100);//错误写法!因为创建的时候尖括号泛型已经说了是字符串，
                         // 添加进去的元素就必须都是字符串才行
    &amp;#125;
&amp;#125;
</code></pre>
<h3 id="常用方法和遍历"><a class="header-anchor" href="#常用方法和遍历">¶</a>常用方法和遍历</h3>
<pre><code class="language-java">import java.util.ArrayList;

/*
ArrayL ist当中的常用方法有:

public boolean add(E e): 向集合当中添加元素，参数的类型和泛型一致。
备注:对于ArrayL ist集合来说，add添加动作一定是成功的，所以返回值可用可不用。
但是对于其他集合(今后学习)来说，add添加动作不一定成功。

public E get(int index): 从集合当中获取元素，参数是索引编号，返回值就是对应位置的元素。

public E remove(int index): 从集合当中删除元素，参数是索引编号，返回值就是被删除掉的元素。

public int size(): 获取集合的尺寸长度，返回值是集合中包含的元素个数。

 */
public class Dome01ArrayListMethod &amp;#123;
    public static void main(String[] args) &amp;#123;
        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
        System.out.println(list);

        //向集合中添加元素：add
        boolean success = list.add(&quot;柳岩&quot;);
        System.out.println(list);
        System.out.println(&quot;添加的动作是否成功&quot; + success);
        System.out.println(&quot;============&quot;);

        list.add(&quot;Rose&quot;);
        list.add(&quot;Rechel&quot;);
        list.add(&quot;Bing&quot;);
        list.add(&quot;Jeoy&quot;);
        System.out.println(list);//[柳岩, Rose, Rechel, Bing, Jeoy]

        //从集合中获取元素: get。 索引值从开始0开始
        String name = list.get(2);
        System.out.println(&quot;第二号位索引值为：&quot; + name);//Rechel
        System.out.println(&quot;=============&quot;);

        //从集合中删除元素：remove。索引值从0开始
        String whoRemove = list.remove(0);
        System.out.println(list);
        System.out.println(&quot;被删除的是：&quot; + whoRemove);
        System.out.println(&quot;===========&quot;);

        //获取集合的长度，也就是集合中的元素数
        int size = list.size();
        System.out.println(&quot;集合的长度是：&quot; + size);
        System.out.println(list);

    &amp;#125;
&amp;#125;
</code></pre>
<pre><code class="language-java">import java.util.ArrayList;

public class Dome01ArrayListEach &amp;#123;
    public static void main(String[] args) &amp;#123;
        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add(&quot;Rose&quot;);
        list.add(&quot;Rechel&quot;);
        list.add(&quot;Manica&quot;);
        list.add(&quot;Chandler&quot;);
        list.add(&quot;Pheebs&quot;);
        list.add(&quot;Joey&quot;);

        //遍历集合
        for (int i = 0; i &lt; list.size(); i++) &amp;#123;
            System.out.println(list.get(i));
        &amp;#125;
    &amp;#125;
&amp;#125;
</code></pre>
<h3 id="集合存储基本数据类型"><a class="header-anchor" href="#集合存储基本数据类型">¶</a>集合存储基本数据类型</h3>
<pre><code class="language-java">/*
如果希望向集合ArrayList当中存储基本类型数据，必须使用基本类型对应的“包装类”。

从JDK 1.5+开始， 支持自动装箱、自动拆箱。

自动装箱:基本类型--&gt; 包装类型（引用类型）
自动拆箱:包装类型--&gt;基本类型
 */
import java.util.ArrayList;

public class Dome01ArrayListBasic &amp;#123;
    public static void main(String[] args) &amp;#123;
        ArrayList&lt;String&gt; listA = new ArrayList&lt;&gt;();
        //错误写法!泛型只能是引用类型，不能是基本类型
       //ArrayList&lt;int&gt; listB = new ArrayList&lt;&gt;();

        ArrayList&lt;Integer&gt; listC = new ArrayList&lt;&gt;();
        listC.add(1000);
        listC.add(18888);
        listC.add(300);
        int num = listC.get(1);
        System.out.println(&quot;第一号元素是：&quot; + num);
    &amp;#125;
&amp;#125;
</code></pre>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>包装类(引用类型，包装类都位于<code>java. lang</code>包下)</th>
</tr>
</thead>
<tbody>
<tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer          <strong>[特殊]</strong></td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>char</td>
<td>Character      <strong>[特殊]</strong></td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
</tbody>
</table>
<h3 id="练习题-v4"><a class="header-anchor" href="#练习题-v4">¶</a>练习题</h3>
<h4 id="1、存储随机数字"><a class="header-anchor" href="#1、存储随机数字">¶</a>1、存储随机数字</h4>
<pre><code class="language-java">import java.util.ArrayList;
import java.util.Random;

/*
题目:
生成6个1~33之间的随机整数，添加到集合，并遍历集合。

思路:
1.需要存储6个数字，创建一个集合， &lt;Integer&gt;
2.产生随机数，需要用到Random
3.用循环6次，来产生6个随机数字: for循环
4.循环内调用r. nextInt(int n)，参数是33，0~32，整体+1才是1~33
5.把数字添加到集合中: add
6.遍历集合: for、size、 get
 */
public class Dome02ArrayListRandom &amp;#123;
    public static void main(String[] args) &amp;#123;
        ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();
        Random r = new Random();
        for (int i = 0; i &lt; 6; i++) &amp;#123;
            int num = r.nextInt(33);
            list.add(num);
        &amp;#125;
        //遍历集合
        for (int j = 0; j &lt; list.size(); j++) &amp;#123;
            System.out.println(&quot;第&quot; +j+ &quot;号元素为：&quot; + list.get(j));
        &amp;#125;
    &amp;#125;

&amp;#125;
</code></pre>
<h4 id="2、存储自定义对象"><a class="header-anchor" href="#2、存储自定义对象">¶</a>2、存储自定义对象</h4>
<pre><code class="language-java">import java.util.ArrayList;

/*
题目:
自定义4个学生对象，添加到集合，并遍历。

思路:
1.自定义Student学生类， 四个部分。
2.创建一个集合，用来存储学生对象。泛型: &lt;Student&gt;
3.根据类，创建4个学生对象。
4.将4个学生对象添加到集合中: add
5.遍历集合: for、size、 get

 */
public class Dome03ArrayListStudent &amp;#123;
    public static void main(String[] args) &amp;#123;
        ArrayList&lt;Student&gt; list = new ArrayList&lt;&gt;();
        Student stu1 = new Student(&quot;Rose&quot;,18);
        Student stu2 = new Student(&quot;Pheebs&quot;,23);
        Student stu3 = new Student(&quot;Manica&quot;,26);
        Student stu4 = new Student(&quot;Rayray&quot;,18);

        list.add(stu1);
        list.add(stu2);
        list.add(stu3);
        list.add(stu4);

        //遍历集合
        for (int i = 0; i &lt; list.size(); i++) &amp;#123;
            Student one = list.get(i);
            System.out.println(&quot;第&quot; + i + &quot;名学生是：&quot; + one.getName() + &quot;，年龄是：&quot; + one.getAge());
        &amp;#125;
    &amp;#125;


&amp;#125;
</code></pre>
<pre><code class="language-java">public class Student &amp;#123;
    private String name;
    private int age;

    public Student() &amp;#123;
    &amp;#125;

    public Student(String name, int age) &amp;#123;
        this.name = name;
        this.age = age;
    &amp;#125;

    public String getName() &amp;#123;
        return name;
    &amp;#125;

    public void setName(String name) &amp;#123;
        this.name = name;
    &amp;#125;

    public int getAge() &amp;#123;
        return age;
    &amp;#125;

    public void setAge(int age) &amp;#123;
        this.age = age;
    &amp;#125;
&amp;#125;
</code></pre>
<h4 id="3、按指定格式遍历集合"><a class="header-anchor" href="#3、按指定格式遍历集合">¶</a>3、按指定格式遍历集合</h4>
<pre><code class="language-java">import java.util.ArrayList;

/*
题目:
定义以指定格式打印集合的方法(ArrayList类型作为参数)，使用&amp;#123;&amp;#125;扩起集合，使用@分隔每个元素。
格式参照&amp;#123;元素@元素@元素&amp;#125;。
System. out. println(list);     [10, 20, 30]
printArrayList(list);           &amp;#123;10@20@30&amp;#125;

 */
public class Dome04ArrayListPrint &amp;#123;
    public static void main(String[] args) &amp;#123;
        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add(&quot;Rose&quot;);
        list.add(&quot;Rachel&quot;);
        list.add(&quot;Monica&quot;);
        list.add(&quot;Chandler&quot;);
        list.add(&quot;Pheebs&quot;);
        list.add(&quot;Joey&quot;);
        System.out.println(list);
        printArraylist(list);
    &amp;#125;
    /*
    定义方法的三要素
    返回值类型:只是进行打印而已，没有运算，没有结果，所以用void
    方法名称: printArraylist
    参数列表: Arraylist
     */
    public static void printArraylist(ArrayList&lt;String&gt; list)&amp;#123;
        System.out.print(&quot;&amp;#123;&quot;);
        for (int i = 0; i &lt; list.size(); i++) &amp;#123;
            String name = list.get(i);
        if (i == list.size() - 1)&amp;#123;
            System.out.println(name + &quot;&amp;#125;&quot;);
        &amp;#125;else &amp;#123;
            System.out.print(name + &quot;@&quot;);
        &amp;#125;
        &amp;#125;
    &amp;#125;
&amp;#125;
</code></pre>
<h4 id="4、筛选集合中的随机数"><a class="header-anchor" href="#4、筛选集合中的随机数">¶</a>4、筛选集合中的随机数</h4>
<pre><code class="language-java">import java.util.ArrayList;
import java.util.Random;

/*
题目:
用一个大集合存入20个随机数字，然后筛选其中的偶数元素，放到小集合当中。
要求使用自定义的方法来实现筛选。
分析:
1.需要创建一个大集合，用来存储int数字: &lt;Integer&gt;
2.随机数字就用Random nextInt
3.循环20次，把随机数字放入大集合: for循环、add方法
4.定义一个方法，用来进行筛选。
筛选:根据大集合，筛选符合要求的元素，得到小集合。
三要素
返回值类型: ArrayLlist小集合(里面元素个数不确定)
方法名称: getSmalllist
参数列表: ArrayList大集合(装着20个随机数字)
5.判断(if)是偶数:num%2==0
6.如果是偶数，就放到小集合当中，否则不放。
 */
public class Dome05ArrayListReturn &amp;#123;
    public static void main(String[] args) &amp;#123;
        ArrayList&lt;Integer&gt; biglist = new ArrayList&lt;&gt;();
        Random r = new Random();
        for (int i = 0; i &lt; 20; i++) &amp;#123;
            int num1 = r.nextInt(100) + 1;//1~100
            biglist.add(num1);
        &amp;#125;
        System.out.println(&quot;大集合是：&quot; + biglist);
        System.out.println(&quot;==============================&quot;);

        //调用方法，me
        selectMethod(biglist);
        System.out.println(&quot;=============&quot;);

        //teacher
        ArrayList&lt;Integer&gt; SmallList = getsmallList(biglist);
        for (int i = 0; i &lt; SmallList.size(); i++) &amp;#123;
            System.out.println(SmallList.get(i));
        &amp;#125;
        System.out.println(&quot;==================&quot;);
        System.out.println(SmallList);
        System.out.println(&quot;偶数一共&quot;+ SmallList.size() + &quot;个&quot;);
    &amp;#125;
    //定义筛选方法，me
    public static void selectMethod(ArrayList&lt;Integer&gt; biglist)&amp;#123;
        ArrayList&lt;Integer&gt; smallList = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; biglist.size(); i++) &amp;#123;
            if (biglist.get(i) % 2 ==0)&amp;#123;
                int num2 = biglist.get(i);
                smallList.add(num2);
            &amp;#125;
        &amp;#125;
            System.out.println(&quot;小集合是：&quot; + smallList);
            System.out.println(&quot;偶数一共&quot; + smallList.size() + &quot;个&quot;);
    &amp;#125;

    //接收大集合参数，返回小集合结果,teacher
    public static ArrayList&lt;Integer&gt; getsmallList(ArrayList&lt;Integer&gt; biglist)&amp;#123;
        //创建一个小集合，用来装偶数结果
        ArrayList&lt;Integer&gt; SmallList = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; biglist.size(); i++) &amp;#123;
            int num3 = biglist.get(i);
            if (num3%2 == 0)&amp;#123;
                SmallList.add(num3);
            &amp;#125;
        &amp;#125;
        return SmallList;
    &amp;#125;
&amp;#125;
</code></pre>
<h2 id="字符串（String）"><a class="header-anchor" href="#字符串（String）">¶</a>字符串（String）</h2>
<h3 id="概述和特点"><a class="header-anchor" href="#概述和特点">¶</a>概述和特点</h3>
<p><code>java. lang. String</code>类代表字符串。<br>
API当中说: Java程序中的所有字符串字面值(如&quot;abc&quot; )都作为此类的实例实现。<br>
其实就是说:程序当中所有的双引号字符串，都是String类的对象。(就算没有new， 也照样是。)<br>
字符串的特点:<br>
1.字符串的内容<strong>永不可变</strong>。[重点]<br>
2.正是因为字符串不可改变，所以字符串是可以共享使用的。<br>
3.字符串效果上相当于是char[ ]字符数组， 但是底层原理是byte[]字节数组。</p>
<h3 id="构造方法和直接创建"><a class="header-anchor" href="#构造方法和直接创建">¶</a>构造方法和直接创建</h3>
<p>创建字符串的常见3+1种方式。<br>
三种构造方法:<br>
public String(): 创建一个空白字符串， 不含有任何内容。<br>
public String(char[] array): 根据字符数组的内容，来创建对应的字符串。<br>
public String(byte[] array): 根据字节数组的内容，来创建对应的字符串。<br>
一种直接创建:<br>
<code>String str = &quot;Hello&quot;; //右边直接用双引号</code></p>
<pre><code class="language-java">public class Dome01String &amp;#123;
    public static void main(String[] args) &amp;#123;
        //使用空参构造
        String str1 = new String();
        System.out.println(&quot;第一个字符串：&quot; + str1);

        //根据字符数组创建字符串
        char[] charArry = &amp;#123;'4', '5' ,'6'&amp;#125;;
        String str2 = new String(charArry);
        System.out.println(&quot;第二个字符串：&quot; + str2);

        //根据字节数组创建字符串
        byte[] byteArray = &amp;#123;97,98,99&amp;#125;;
        String str3 = new String(byteArray);
        System.out.println(&quot;第三个字符串：&quot; + str3);

        //直接创建字符串
        String str = &quot;hello&quot;;
        System.out.println(&quot;第四个字符串：&quot; + str);
    &amp;#125;
&amp;#125;
</code></pre>
<h3 id="字符串的常量池"><a class="header-anchor" href="#字符串的常量池">¶</a>字符串的常量池</h3>
<pre><code class="language-java">public class Dome01StringPool &amp;#123;
    public static void main(String[] args) &amp;#123;
        String str1 = &quot;abc&quot;;
        String str2 = &quot;abc&quot;;

        char[] charArray = &amp;#123;'a','b','c'&amp;#125;;
        String str3 = new String(charArray);
        System.out.println(str1 == str2);//true
        System.out.println(str1 == str3);//false
        System.out.println(str2 == str3);//false
    &amp;#125;

&amp;#125;
</code></pre>
<p><img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/stardust14/picture/master/img/20200726121234.png" alt="image-20200726121231535"></p>
<h3 id="字符串的比较方法"><a class="header-anchor" href="#字符串的比较方法">¶</a>字符串的比较方法</h3>
<pre><code class="language-java">/*
==是进行对象的地址值比较，如果确买需要子符串的内容比较，可以使用两个方法:

public. boolean equals(Object. obj): 参数可以是任何对象，只有参数是一个字符串并 且内容相同的才会给true;否则返回false。
备注:任何对象都能用object进行接收。

注意事项:
1.任何对象都能用object进行接收。
2. equals方法具有 对称性，也就是a. equals(b)和b. equals(a)效果-样。
3.如果比较双方一个常量-一个变量，推荐把常量字符串写在前面。
推荐: &quot;abc&quot;. equals(str)不推荐: str. equals(&quot;abc&quot;)
public boolean equalsIgnoreCase(String str): 忽略大小写，进行内容比较。
 */
public class Dome01StringEquals &amp;#123;
    public static void main(String[] args) &amp;#123;
        String str1 = &quot;Hello&quot;;
        String str2 = &quot;Hello&quot;;

        char[] charArray = &amp;#123;'H','e','l','l','o'&amp;#125;;
        String str3 = new String(charArray);

        System.out.println(str1.equals(str2));//true
        System.out.println(str1.equals(str3));//true
        System.out.println(str3.equals(&quot;Hello&quot;));//true
        System.out.println(&quot;Hello&quot;.equals(str3));//true
        System.out.println(&quot;================&quot;);

        String str4 = &quot;hello&quot;;
        System.out.println(str1.equals(str4));//false
        System.out.println(&quot;================&quot;);

        String str5 = null;
        System.out.println(&quot;abc&quot;.equals(str5));//推荐：false
        //System.out.println(str5.equals(&quot;abc&quot;));//不推荐，报错，空指针异常NullPointerException
        System.out.println(&quot;=============&quot;);

        System.out.println(str1.equalsIgnoreCase(str4));//true,忽略大小写
        //注意：只有英文字母区分大小写，汉字不区分
    &amp;#125;
&amp;#125;
</code></pre>
<h3 id="字符串获取相关方法"><a class="header-anchor" href="#字符串获取相关方法">¶</a>字符串获取相关方法</h3>
<pre><code class="language-java">/*
String当中与获取相关的常用方法有:

public int length(); 获取字符串当中含有的字符个数，拿到字符串长度。
public String concat(String str): 将当前字符串和参数字符串拼接成为返回值新的字符串。
public char charAt(int index): 获取指定索引位置的单个字符。( 索引从开始。)
public int index0f(String str): 查找参数字符串在本字符串当中首次出现的索引位置，如果没有返回-1值。

 */
public class Dome01StringGet &amp;#123;
    public static void main(String[] args) &amp;#123;
        //获取字符串长度
        int length = &quot;askkjfbakjkjdbajhvbajbvn&quot;.length();
        System.out.println(&quot;字符串的个数：&quot; + length);

        //拼接字符串
        String str1 = &quot;Hello&quot;;
        String str2 = &quot;World&quot;;
        String str3 = str1.concat(str2);
        System.out.println(str1);//Hello
        System.out.println(str2);//World
        System.out.println(str3);//HelloWorld,新的字符串
        System.out.println(&quot;====================&quot;);

        //获取指定索引位置的单个字符
        char ch = &quot;Hello&quot;.charAt(0);
        System.out.println(&quot;第零号索引位置的字符是：&quot; + ch);//H
        System.out.println(&quot;=================&quot;);

        //查找参数字符串在本来字符串当中出现的第一次索引的位置
        //如果没有，返回-1值
        String original = &quot;HelloWorldHelloWorld&quot;;
        int index = original.indexOf(&quot;llo&quot;);
        System.out.println(&quot;第一次索引值：&quot; + index);//2

        System.out.println(&quot;HelloWorld&quot;.indexOf(&quot;abc&quot;));//-1
    &amp;#125;
&amp;#125;
</code></pre>
<h3 id="字符串的截取方法"><a class="header-anchor" href="#字符串的截取方法">¶</a>字符串的截取方法</h3>
<blockquote>
<p>字符串的截取方法: .<br>
public String substring(int index): 截取从参数位置- -直到字符串末尾，返回新字符串。<br>
public String substring(int begin, int end): 截取从begin开始， 一直到end结束，中间的字符串。<br>
备注: [begin,end)， 包含左边，不包含右边。</p>
</blockquote>
<pre><code class="language-java">public class Dome01SubString &amp;#123;
    public static void main(String[] args) &amp;#123;
        String str1 = &quot;HelloWorld&quot;;
        String str2 = str1.substring(5);
        System.out.println(str1);//原封不动
        System.out.println(str2);//World,新字符串
        System.out.println(&quot;=============&quot;);

        String str3 = str1.substring(4,7);
        System.out.println(str3);//oWo
        System.out.println(&quot;==============&quot;);

        //下面这种写法，字符串的内容仍然是没有改变的
        //下面有两个字符串: &quot;Hello&quot;，&quot;Java&quot;
        //strA当中保存的是地址值。
        //本来地址值是Hello的0x666,
        //后来地址值变成了Java的0x999
        String strA = &quot;Hello&quot;;
        System.out.println(strA);//Hello
        strA = &quot;Java&quot;;
        System.out.println(strA);//Java
    &amp;#125;
&amp;#125;
</code></pre>
<h3 id="字符串的转换相关方法"><a class="header-anchor" href="#字符串的转换相关方法">¶</a>字符串的转换相关方法</h3>
<blockquote>
<p>String当中与转换相关的常用方法有:</p>
<p>public char[] toCharArray(): 将当前字符串拆分成为字符数组作为返回值。<br>
public byte[] getBytes(): 获得当前字符串底层的字节数组。<br>
public String replace(CharSequence oldString, CharSequence newString):<br>
将所有出现的老字符串替换成为新的字符串，返回替换之后的结果新字符串。<br>
备注: CharSequence意思就是说可以接受字符串类型。</p>
</blockquote>
<pre><code class="language-java">public class Dome01StringConvert &amp;#123;
    public static void main(String[] args) &amp;#123;
        //转换成字符数组
        char[] chars = &quot;Hello&quot;.toCharArray();
        System.out.println(chars[0]);//H
        System.out.println(chars.length);//5
        System.out.println(&quot;===========&quot;);

        //转换成字节数组
        byte[] bytes = &quot;abc&quot;.getBytes();
        System.out.println(bytes);
        for (int i = 0; i &lt; bytes.length; i++) &amp;#123;
            System.out.println(bytes[i]);
        &amp;#125;
        System.out.println(&quot;===================&quot;);

        //字符串的内容替换
        String str1 = &quot;How you doing?&quot;;
        String str2 = str1.replace(&quot;?&quot;, &quot;(·——·)&quot;);
        System.out.println(str1);//How you doing?
        System.out.println(str2);//How you doing(·——·)
        System.out.println(&quot;++++++++++++++++&quot;);

        String lang1 = &quot;你他妈的会不会玩，我操,我操！！！&quot;;
        String lang2 = lang1.replace(&quot;我操&quot;, &quot;我*&quot;);
        String lang3 = lang2.replace(&quot;他妈的&quot;, &quot;***&quot;);
        System.out.println(lang3);//你***会不会玩，我*,我*！！！
    &amp;#125;
&amp;#125;
</code></pre>
<h3 id="字符串的分割方法"><a class="header-anchor" href="#字符串的分割方法">¶</a>字符串的分割方法</h3>
<p>分割字符串的方法: .<br>
public String[] split(String regex): 按照参数的规则，将字符串切分成为若干部分。</p>
<p><strong>注意事项</strong>:<br>
split方法的参数其实是一个“<strong>正则表达式</strong>”，今后学习。<br>
今天要注意:如果按照英文句点**“.”**进行切分，必须写<code>&quot;\\.&quot;</code></p>
<pre><code class="language-java">public class Dome01StringSplit &amp;#123;
    public static void main(String[] args) &amp;#123;
        String str1 = &quot;a,bb,ccc,dddd,eeeee&quot;;
        String[] str2 = str1.split(&quot;,&quot;);//以逗号为规则进行切割
        System.out.println(str2);
        for (int i = 0; i &lt; str2.length; i++) &amp;#123;
            System.out.println(str2[i]);
        &amp;#125;
        System.out.println(&quot;============&quot;);
        String str3 = &quot;A BB CCC DDDD EEEEE FFFFFF&quot;;
        String[] str4 = str3.split(&quot; &quot;);//以空格为规则进行切割
        for (int i = 0; i &lt; str4.length; i++) &amp;#123;
            System.out.println(str4[i]);
        &amp;#125;
        System.out.println(&quot;------------------&quot;);

        //以“.”必须用“\\.”表示，比较特殊的切割
        String str5 = &quot;XXXX.YYYY.ZZZZ&quot;;
        String[] str6 = str5.split(&quot;\\.&quot;);
        for (int i = 0; i &lt; str6.length; i++) &amp;#123;
            System.out.println(str6[i]);
        &amp;#125;
    &amp;#125;
&amp;#125;
</code></pre>
<h3 id="练习题-v5"><a class="header-anchor" href="#练习题-v5">¶</a>练习题</h3>
<h4 id="1、按指定格式拼接字符串"><a class="header-anchor" href="#1、按指定格式拼接字符串">¶</a>1、按指定格式拼接字符串</h4>
<pre><code class="language-java">/*
题目:
定义一个方法，把数组&amp;#123;1, 2, 3&amp;#125;按照指定格式拼接成一个字符串 。格式参照如下: [word1#word2#word3]。

分析:
1.首先准备一个int[]数组，内容是: 1、2、3
2.定义一个方法，用来将数组变成字符串
三要素
返回值类型: String
方法名称: fromArrayToString
参数列表: int[]
3.格式: [word1 #word2#word3]
用到: for循环、字符串拼接、每个数组元素之前都有-个word字样、分隔使用的是#、区分- -下是不是最后-一个
4.调用方法，得到返回值，并打印结果字符串
 */
public class Dome02StringPractise &amp;#123;
    public static void main(String[] args) &amp;#123;
        int[] Array = &amp;#123;1,2,3&amp;#125;;
        String result = fromArrayToString(Array);
        System.out.println(result);
    &amp;#125;
    public static String fromArrayToString(int[] Array)&amp;#123;
        String str = &quot;[&quot;;
        for (int i = 0; i &lt; Array.length; i++) &amp;#123;
            if (i ==Array.length - 1 )&amp;#123;
                str += &quot;word&quot; + Array[i] + &quot;]&quot;;
            &amp;#125;else &amp;#123;
                str += &quot;word&quot; + Array[i] + &quot;#&quot;;
            &amp;#125;
        &amp;#125;
        return str;
    &amp;#125;
&amp;#125;
</code></pre>
<h4 id="2、统计输入的字符串中各种字符的个数"><a class="header-anchor" href="#2、统计输入的字符串中各种字符的个数">¶</a>2、统计输入的字符串中各种字符的个数</h4>
<pre><code class="language-java">/*
题目:
键盘输入一个字符串，并且统计其中各种字符出现的次数。
种类有:大写字母、小写字母、数字、其他

思路:
1.既然用到键盘输入，肯定是Scanner
2.键盘输入的是字符串，那么: String str = sc.next();
3.定义四个变量，分别代表四种字符各自的出现次数。
4.需要对字符串一个字、一个字检查，String--&gt;char[],方法就是toCharArray()
5.遍历char[ ]字符数组，对当前字符的种类进行判断，并且用四个变量进行++动作。
6.打印输出四个变量，分别代表四种字符出现次数。
 */
public class Dome02StringCount &amp;#123;
    public static void main(String[] args) &amp;#123;
        Scanner sc = new Scanner(System.in);
        System.out.println(&quot;请输入一个字符串：&quot;);
        String input = sc.next();

        int countUpper = 0;//大写字母
        int countLower = 0;//小写字母
        int countNumber = 0;//数字
        int countOther = 0;//其他字符


        char[] Array = input.toCharArray();
        for (int i = 0; i &lt; Array.length; i++) &amp;#123;
            char ch = Array[i];//当前单个字符
            if ('A' &lt;= ch &amp;&amp; ch &lt;='Z')&amp;#123;
                countUpper++;
            &amp;#125;else if ('a' &lt;= ch &amp;&amp; ch &lt;= 'z')&amp;#123;
                countLower++;
            &amp;#125;else if ('0' &lt;=ch &amp;&amp; ch&lt;='9')&amp;#123;
                countNumber++;
            &amp;#125;else &amp;#123;
                countOther++;
            &amp;#125;
        &amp;#125;
        System.out.println(&quot;大写字母的个数：&quot; + countUpper);
        System.out.println(&quot;小写字母的个数：&quot; + countLower);
        System.out.println(&quot;数字的个数：&quot; + countNumber);
        System.out.println(&quot;其他字符的个数：&quot; + countOther);
    &amp;#125;
&amp;#125;
</code></pre>
<blockquote>
<p>输入的字符串不能有空格存在</p>
</blockquote>
<h2 id="静态static关键字"><a class="header-anchor" href="#静态static关键字">¶</a>静态static关键字</h2>
<h3 id="概述-v4"><a class="header-anchor" href="#概述-v4">¶</a>概述</h3>
<p><img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/stardust14/picture/master/img/20200727143324.png" alt="image-20200726215716336"></p>
<h3 id="修饰成员变量"><a class="header-anchor" href="#修饰成员变量">¶</a>修饰成员变量</h3>
<pre><code class="language-java">/*
如果一个成员变量使用了static关键字， 那么这个变量不再属于对象自己，而是属于所在的类。多个对象共享同一-份数据。.
 */
public class Dome01StaticField &amp;#123;
    public static void main(String[] args) &amp;#123;
        Student one = new Student(&quot;霉霉&quot;,18);
        one.room = &quot;101教室&quot;;
        System.out.println(&quot;姓名：&quot; + one.getName() + &quot;,年龄：&quot;
                + one.getAge() + &quot;,教室：&quot; + one.room
        +&quot;，学号：&quot; + one.getId());

        Student two = new Student(&quot;水果姐&quot; ,20);
//        System.out.println();
        System.out.println(&quot;姓名：&quot; + two.getName() + &quot;,年龄：&quot;
                + two.getAge()+ &quot;,教室：&quot; + two.room
                +&quot;，学号：&quot; + two.getId());

    &amp;#125;
&amp;#125;
</code></pre>
<pre><code class="language-java">/*
Student类
*/
public class Student &amp;#123;

    private int id;//学号
    private String name;//姓名
    private int age;//年龄
    static String room;//教室
    static int idcounter = 0;//学号计数器

    public Student() &amp;#123;
        this.id = ++idcounter;
    &amp;#125;

    public Student(String name, int age) &amp;#123;
        this.name = name;
        this.age = age;
        this.id = ++idcounter;
    &amp;#125;

    public int getId() &amp;#123;
        return id;
    &amp;#125;

    public void setId(int id) &amp;#123;
        this.id = id;
    &amp;#125;

    public String getName() &amp;#123;
        return name;
    &amp;#125;

    public void setName(String name) &amp;#123;
        this.name = name;
    &amp;#125;

    public int getAge() &amp;#123;
        return age;
    &amp;#125;

    public void setAge(int age) &amp;#123;
        this.age = age;
    &amp;#125;
&amp;#125;
</code></pre>
<h3 id="修饰成员方法"><a class="header-anchor" href="#修饰成员方法">¶</a>修饰成员方法</h3>
<pre><code class="language-java">public class MyClass &amp;#123;

    int num;//成员变量
    static int numStatic;//静态变量

    //成员方法
    public void method()&amp;#123;
        System.out.println(&quot;这是一个成员方法&quot;);
        //成员方法可以访问成员变量
        System.out.println(num);
        //成员方法可以访问静态变量
        System.out.println(numStatic);
    &amp;#125;
    //静态方法
    public static void methodStatic()&amp;#123;
        System.out.println(&quot;这是一个静态方法&quot;);
        //静态方法可以访问静态变量
        System.out.println(numStatic);
        //静态方法不可以访问成员变量
//        System.out.println(num);
//        System.out.println(this);静态方法不能用this（当前方法调用）关键字
    &amp;#125;
&amp;#125;
</code></pre>
<pre><code class="language-java">/*
一旦使用static修饰成员方法，那么这就成为了静态方法。静态方法不属于对象，而是属于类的。

如果没有static关键字，那么必须首先创建对象，然后通过对象才能使用它。

无论是成员变量，还是成员方法。如果有了static,都推荐使用类名称进行调用。
静态变量:类名称.静态变量
静态方法:类名称.静态方法()

注意事项:
1.静态不能直接访问非静态。
原因:因为在内存当中是[先]有的静态内容，[后] 有的非静态内容。
“先人不知道后人，但是后人知道先人。”
2.静态方法当中不能用this。
原因: this代表当前对象，通过谁调用的方法，谁就是当前对象。
 */
public class Dome02StaticMethod &amp;#123;
    public static void main(String[] args) &amp;#123;
        MyClass obj = new MyClass();//首先创建对象
        //然后才能用没有static关键字的内容
        obj.method();

        //对于静态方法来说，可以通过对象名进行调用，也可以直接通过类名称来调用。
        obj.methodStatic();//正确，不推荐；这种写法在编译之后也会被javac翻译成为“类名称.静态方法名”
        MyClass.methodStatic();//正确，推荐

        //对于本来当中的静态方法，可以省略类名称
        Memethod();
        Dome02StaticMethod.Memethod();
    &amp;#125;
    public static void Memethod()&amp;#123;
        System.out.println(&quot;自己的方法&quot;);
    &amp;#125;
&amp;#125;
</code></pre>
<h3 id="内存图"><a class="header-anchor" href="#内存图">¶</a>内存图</h3>
<p><img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/stardust14/picture/master/img/20200727143255.png" alt="image-20200727143244285"></p>
<h3 id="静态代码块"><a class="header-anchor" href="#静态代码块">¶</a>静态代码块</h3>
<pre><code class="language-java">/*
静态代码块的格式是:

public class 类名称&amp;#123;
	static &amp;#123;
		//静态代码块的内容
	&amp;#125;
&amp;#125;
特点:当第一次用到本类时，静态代码块执行唯一的一 次。
静态内容总是优先于非静态，所以静态代码块比构造方法先执行。

静态代码块的典型用途:
用来一次性地对静态成员变量进行赋值。
*/
</code></pre>
<h2 id="数组工具类Arrays"><a class="header-anchor" href="#数组工具类Arrays">¶</a>数组工具类Arrays</h2>
<pre><code class="language-java">import java.util.Arrays;

/*
java. util.Arrays是一个与 数组相天的工具类，里面提供I大重静念万法，用来头现数组常见的操作。

public static String toString(数组): 将参数数组变成字符串(按照默认格式: [元素1, 元素2,元素3...]) .
public static void sort(数组):按照默认升序(从小到大)对数组的元素进行排序。

备注:
1.如果是数值，sort默认按照升序从小到大
29如果是字符串，sort默认按照字母升序
3.如果是自定义的类型，那么这个自定义的类需要有Comparable或者Comparator接口的支持。 (今后学习)
 */
public class Dome03Arrays &amp;#123;

    public static void main(String[] args) &amp;#123;
        int[] intArray = &amp;#123;10, 20, 30&amp;#125;;
        //将int[]数组按照默认格式变成字符串
        String intStr = Arrays.toString(intArray);
        System.out.println(intStr);

        int[] array1 =&amp;#123;1,6,8,9,2,3,5,4,7&amp;#125;;
        Arrays.sort(array1);
        System.out.println(Arrays.toString(array1));

        String[] str = &amp;#123;&quot;a&quot;,&quot;q&quot;,&quot;z&quot;,&quot;e&quot;,&quot;w&quot;,&quot;s&quot;,&quot;d&quot;,&quot;x&quot;,
                    &quot;c&quot;,&quot;f&quot;,&quot;r&quot;,&quot;t&quot;,&quot;g&quot;,&quot;v&quot;,&quot;b&quot;
                ,&quot;t&quot;,&quot;y&quot;,&quot;u&quot;,&quot;h&quot;,&quot;j&quot;,&quot;n&quot;,&quot;k&quot;,&quot;m&quot;,&quot;l&quot;,&quot;i&quot;,&quot;o&quot;,&quot;p&quot;&amp;#125;;
        Arrays.sort(str);
        System.out.println(Arrays.toString(str));

    &amp;#125;
&amp;#125;
</code></pre>
<h4 id="练习题-v6"><a class="header-anchor" href="#练习题-v6">¶</a>练习题</h4>
<pre><code class="language-java">import java.util.Arrays;
import java.util.Scanner;

/*
题目:
请使用Arrays相关的API, 将一个随机字符串中的所有字符升序排列，并倒序打印。
 */
public class Dome02ArraysPractise &amp;#123;
    public static void main(String[] args) &amp;#123;
        //升级：用键盘读取输入的字符串
        Scanner sc = new Scanner(System.in);
        System.out.println(&quot;请输入一个字符串：&quot;);
        String str = sc.next();

        //如何进行升序排列: sort
        //必须是一个数组，才能用Arrays. sort方法
        // String --&gt;数组，用toCharArray
        char[] chars = str.toCharArray();
        Arrays.sort(chars);
        System.out.println(Arrays.toString(chars));//这是顺序排列
        System.out.println(&quot;===============&quot;);
        
        //接下来需要逆序排列，倒序遍历
        for (int i = chars.length - 1; i &gt;= 0; i--) &amp;#123;
            System.out.print(chars[i]);
        &amp;#125;
    &amp;#125;
&amp;#125;
</code></pre>
<h2 id="数学工具类"><a class="header-anchor" href="#数学工具类">¶</a>数学工具类</h2>
<pre><code class="language-java">/*
java.lang.Math类是数学相关的工具类，里面提供了大量的静态方法，完成与数学运算相关的操作

public static double abs(double num): 获取绝对值。
public static double ceil(double num): 向.上取整。
public static double floor(double num):向下取整。
public static long round(double num): 四舍五入。

Math. PI代表近似的圆周率常量(double)。
 */
public class Dome04Math &amp;#123;
    public static void main(String[] args) &amp;#123;
        //获取绝对值
        System.out.println(Math.abs(3.14));//3.14
        System.out.println(Math.abs(-8));//8
        System.out.println(Math.abs(-5.1));//5.1
        System.out.println(&quot;==================&quot;);

        //向上取整
        System.out.println(Math.ceil(3.9));//4.0
        System.out.println(Math.ceil(3.0));//3.0
        System.out.println(Math.ceil(3.00000001));//4.0
        System.out.println(Math.ceil(3.0000000000000000001));//3.0
        System.out.println(&quot;===================&quot;);

        //向下取整，抹零
        System.out.println(Math.floor(6.666));//6.0
        System.out.println(Math.floor(6.00));//6.0
        System.out.println(Math.floor(6.999));//6.0
        System.out.println(&quot;==================&quot;);

        //四舍五入
        System.out.println(Math.round(5.5));//6.0
        System.out.println(Math.round(5.40000001));//5.0
        System.out.println(Math.round(5.3));//5.0
        System.out.println(&quot;=================&quot;);
        
        //pi
        System.out.println(Math.PI);//3.141592653589793
    &amp;#125;
&amp;#125;
</code></pre>
<h4 id="练习题-v7"><a class="header-anchor" href="#练习题-v7">¶</a>练习题</h4>
<p><img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/stardust14/picture/master/img/20200727155149.png" alt="image-20200727155147074"></p>
<pre><code class="language-java">/*
题目:
计算在-10.8到5.9之间，绝对值大于6或者小于2.1的整数有多少个?
分析:
1.既然已经确定了范围，for循环
2.起点位置-10.8应该转换成为-10， 两种办法:
    2.1可以使用Math.ceil方法，向上(向正方向)取整
    2.2强转成为int，自动舍弃所有小数位
3.每一个数字都是整数，所以步进表达式应该是num++， 这样每次都是+1的。
4.如何拿到绝对值: Math. abs方法。.
5.一旦发现了一个数字，需要让计数器+ +进行统计。
 */
public class Dome04MathPractise &amp;#123;
    public static void main(String[] args) &amp;#123;
        int count = 0;

        double min = -10.9;
        double max = 5.9;

        for (int i = (int) min; i &lt; max; i++) &amp;#123;
            int abs = Math.abs(i);
            if (abs &gt; 6 || abs &lt; 2.1) &amp;#123;
                System.out.println(&quot;符合要求的数字为：&quot; + i);
                count++;
            &amp;#125;
        &amp;#125;
        System.out.println(&quot;符合要求的个数为：&quot; + count + &quot;个&quot;);
    &amp;#125;
&amp;#125;
</code></pre>
<h1>继承性</h1>
<h2 id="概述-v5"><a class="header-anchor" href="#概述-v5">¶</a>概述</h2>
<p><img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/stardust14/picture/master/img/20200728102030.png" alt="image-20200728102028290"></p>
<h2 id="格式"><a class="header-anchor" href="#格式">¶</a>格式</h2>
<pre><code class="language-java">/*
在继承的关系中，“子类就是一一个父类”。也就是说，子类可以被当做父类看待。
例如父类是员工，子类是讲师，那么“讲师就是一个员工”。 关系: is-a。

定义父类的格式: (一个普通的类定义)
public class 父类名称&amp;#123;
    //...
&amp;#125;
定义子类的格式:
public class 子类名称extends 父类名称&amp;#123;
    //....
&amp;#125;
 */
</code></pre>
<h2 id="成员变量的访问特点"><a class="header-anchor" href="#成员变量的访问特点">¶</a>成员变量的访问特点</h2>
<pre><code class="language-java">public class Fu &amp;#123;
    int numFu = 10;

    int num = 100;


    public void methodFu()&amp;#123;
        //使用本类之中，不会向下找子类的
        System.out.println(num);
    &amp;#125;
&amp;#125;
</code></pre>
<pre><code class="language-java">public class Zi extends Fu &amp;#123;
    int numZi = 20;
    int num = 2000;

    public void methodZi()&amp;#123;
        //因为本类之中有num，所以优先使用本类中的num
        System.out.println(num);
    &amp;#125;
&amp;#125;
</code></pre>
<pre><code class="language-java">/*
在父子类的继承关系当中，如果成员变量重名，则创建子类对象时，访问有两种方式:

直接通过子类对象访问成员变量:
    等号左边是谁，就优先用谁，没有则向上找。
间接通过成员方法访问成员变量:
该方法属于谁，就优先用谁，没有则向上找。
 */
public class Dome01ExtendsField &amp;#123;

    public static void main(String[] args) &amp;#123;
        Fu fu =new Fu();//创建父类对象
        System.out.println(fu.numFu);//10，只能使用父类的东西，没有任何子类内容
        System.out.println(&quot;============&quot;);

        Zi zi=new Zi();
        System.out.println(zi.numZi);//20
        System.out.println(zi.numFu);//10
        System.out.println(&quot;============&quot;);

        //等号左边是谁，就优先用谁
        System.out.println(zi.num);//优先子类，2000
//        System.out.println(zi.aba);//到处都没有，编译报错
        System.out.println(&quot;++++++++&quot;);

        System.out.println(fu.num);//100
        System.out.println(&quot;=============&quot;);

        //这个方法是子类的，优先子类的，没有再向上找
        zi.methodZi();//2000
        //这个方法是在父类当中定义的
        zi.methodFu();//100

    &amp;#125;
&amp;#125;
</code></pre>
<h2 id="区分子类方法中重名的三种方法"><a class="header-anchor" href="#区分子类方法中重名的三种方法">¶</a>区分子类方法中重名的三种方法</h2>
<pre><code class="language-java">public class Zi extends Fu &amp;#123;
    int num = 20;

    public void method()&amp;#123;
        int num = 30;
        System.out.println(num);//30,局部变量
        System.out.println(this.num);//20，本类中的成员变量
        System.out.println(super.num);//10,父类中的成员变量
    &amp;#125;
&amp;#125;
</code></pre>
<pre><code class="language-java">/*
局部变量:           直接写成员变量名
本类的成员变量:      this.成员变量名
父类的成员变量:      super.成员变量名
 */
public class Dome02ExtendsField &amp;#123;
    public static void main(String[] args) &amp;#123;
        Zi zi = new Zi();
        zi.method();
    &amp;#125;
&amp;#125;
</code></pre>
<h2 id="成员方法的访问特点"><a class="header-anchor" href="#成员方法的访问特点">¶</a>成员方法的访问特点</h2>
<pre><code class="language-java">public class Fu01 &amp;#123;
    public void methodFu01()&amp;#123;
        System.out.println(&quot;父类方法执行！！！！！&quot;);
    &amp;#125;

    public void method()&amp;#123;
        System.out.println(&quot;父类重名方法执行！！！&quot;);
    &amp;#125;
&amp;#125;
</code></pre>
<pre><code class="language-java">public class Zi01 extends Fu01&amp;#123;
    public void methodZi01()&amp;#123;
        System.out.println(&quot;子类方法执行！！！！！&quot;);
    &amp;#125;

    public void method()&amp;#123;
        System.out.println(&quot;子类重名方法执行！！！&quot;);
    &amp;#125;
&amp;#125;
</code></pre>
<pre><code class="language-java">/*
在父子类的继承关系当中，创建子类对象，访问成员方法的规则:
    创建的对象是谁，就优先用谁，如果没有则向上找。

   注意事项:
无论是成员方法还是成员变量，如果没有都是向上找父类，绝对不会向下找子类的。
 */
public class Dome03ExtendsField01 &amp;#123;

    public static void main(String[] args) &amp;#123;
        Zi01 zi = new Zi01();

        zi.methodFu01();//父类方法执行！！！！！
        zi.methodZi01();//子类方法执行！！！！！

        //创建的是new了子类对象，所以优先用子类方法
        zi.method();//子类重名方法执行！！！
    &amp;#125;
&amp;#125;
</code></pre>
<h2 id="方法的覆盖重写"><a class="header-anchor" href="#方法的覆盖重写">¶</a>方法的覆盖重写</h2>
<h3 id="概念与特点"><a class="header-anchor" href="#概念与特点">¶</a>概念与特点</h3>
<pre><code class="language-java">/*
重写(Override)
概念:在继承关系当中，方法的名称一样，参数列表也一样。

重写(Override):方法的名称一样，参数列表[也一样]。覆盖、覆写。
重载(Overload) :方法的名称一样，参数列表[不一样]。

方法的覆盖重写特点:创建的是子类对象，则优先用子类方法。
*/
</code></pre>
<h3 id="注意事项"><a class="header-anchor" href="#注意事项">¶</a>注意事项</h3>
<pre><code class="language-java">/*
方法覆盖重写的注意事项:

1.必须保证父子类之间方法的名称相同，参数列表也相同。
@Override:写在方法前面，用来检测是不是有效的正确覆盖重写。
这个注解就算不写，只要满足要求，也是正确的方法覆盖重写。

2.子类方法的返回值必须[小于等于]父类方法的返回值范围。
小扩展提示: java. lang . object类是所有类的公共最高父类(祖宗类)，java. lang. String就是object的子类

3.子类方法的权限必须[大于等于]父类方法的权限修饰符。
小扩展提示: public &gt; protected &gt; (default) &gt; private
备注: (default)不是关键字default， 而是什么都不写，留空。
*/
</code></pre>
<h3 id="应用场景"><a class="header-anchor" href="#应用场景">¶</a>应用场景</h3>
<p><img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/stardust14/picture/master/img/20200728145141.png" alt="image-20200728143931983"></p>
<pre><code class="language-java">//本来的老款手机
public class Phone &amp;#123;
    public void call()&amp;#123;
        System.out.println(&quot;打电话&quot;);
    &amp;#125;

    public void send()&amp;#123;
        System.out.println(&quot;发短信&quot;);
    &amp;#125;

    public void show()&amp;#123;
        System.out.println(&quot;显示号码&quot;);
    &amp;#125;
&amp;#125;
</code></pre>
<pre><code class="language-java">//定义一个新手机，使用老手机作为父类
public class NewPhone extends Phone &amp;#123;
    @Override
    public void show() &amp;#123;
        super.show();//把父类中的show方法拿过来重复使用
        //自己子类再添加新的内容
        System.out.println(&quot;显示姓名&quot;);
        System.out.println(&quot;显示头像&quot;);
    &amp;#125;
&amp;#125;
</code></pre>
<pre><code class="language-java">public class Dome04Phone &amp;#123;

    public static void main(String[] args) &amp;#123;
        Phone phone = new Phone();
        phone.call();
        phone.send();
        phone.show();
        System.out.println(&quot;==================&quot;);

        NewPhone newPhone = new NewPhone();
        newPhone.call();
        newPhone.send();
        newPhone.show();
    &amp;#125;
&amp;#125;
</code></pre>
<h2 id="构造方法的访问特点"><a class="header-anchor" href="#构造方法的访问特点">¶</a>构造方法的访问特点</h2>
<pre><code class="language-java">/*
继承关系中，父子类构造方法的访问特点:

1.子类构造方法当中有一一个默认隐含的“super()&quot;调用，所以一-定是先调用的父类构造，后执行的子类构造。
2.子类构造可以通过super关键字来调用父类重载构造。
3. super的父类构造调用，必须是子类构造方法的第一个语句。 不能一个子类构造调用多次super构造。
总结:
子类必须调，用父类构造方法，不写则赠送super();写了则用写的指定的super调用，super只能有一个，还必须是第一个。
*/
</code></pre>
<h2 id="super关键字的三种用法"><a class="header-anchor" href="#super关键字的三种用法">¶</a>super关键字的三种用法</h2>
<pre><code class="language-java">/*
super关键字的用法有三种:
1.在子类的成员方法中，访问父类的成员变量。
2.在子类的成员方法中，访问父类的成员方法。
3.在子类的构造方法中，访问父类的构造方法。
 */
public class Zi02 extends Fu02 &amp;#123;
    int num = 20;

    public Zi02()&amp;#123;
        super();
    &amp;#125;

    public void methodZi02()&amp;#123;
        System.out.println(super.num);//父类中的num
    &amp;#125;

    public void method()&amp;#123;
        super.method();//访问父类中的method方法
        System.out.println(&quot;子类方法&quot;);//
    &amp;#125;
&amp;#125;
</code></pre>
<pre><code class="language-java">public class Fu02 &amp;#123;

    int num = 10;

    public void method()&amp;#123;
        System.out.println(&quot;父类方法&quot;);
    &amp;#125;
&amp;#125;
</code></pre>
<h2 id="this关键字的三种用法"><a class="header-anchor" href="#this关键字的三种用法">¶</a>this关键字的三种用法</h2>
<pre><code class="language-java">/*
super关键字用来访问父类内容，而this关键字用来访问本类内容。用法也有三种:

1.在本类的成员方法中，访问本类的成员变量。
2.在本类的成员方法中，访问本类的另一个成员方法。
3.在本类的构造方法中，访问本类的另- -个构造方法。
在第三种用法当中要注意:
    A. this(... )调用也必须是构造方法的第一个语句， 唯一-个。
    B. super和thi s两种构造调用，不能同时使用。
 */
public class Zi03 extends Fu03 &amp;#123;
    int num = 10;


    public Zi03()&amp;#123;
//        super();//这一行不再赠送
        this(100);//本类的无参构造，调用本类的有参构造
//        this(1,3);//错误写法/
    &amp;#125;

    public Zi03(int n)&amp;#123;
        
    &amp;#125;
    public Zi03(int n,int m)&amp;#123;

    &amp;#125;
    public void showNum()&amp;#123;
        int num = 20;
        System.out.println(num);//局部变量
        System.out.println(this.num);//本类中的成员变量
        System.out.println(super.num);//父类中的成员变量
    &amp;#125;

    public void methodA()&amp;#123;
        System.out.println(&quot;你最帅！&quot;);
    &amp;#125;

    public void methodB()&amp;#123;
        this.methodA();
        System.out.println(&quot;我最帅！！&quot;);
    &amp;#125;
&amp;#125;
</code></pre>
<h2 id="super和this关键字图解"><a class="header-anchor" href="#super和this关键字图解">¶</a>super和this关键字图解</h2>
<p><img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/stardust14/picture/master/img/20200728205348.png" alt="image-20200728205347121"></p>
<h2 id="Java继承的三个特点"><a class="header-anchor" href="#Java继承的三个特点">¶</a>Java继承的三个特点</h2>
<p><img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/stardust14/picture/master/img/20200728210954.png" alt="image-20200728210017817"></p>
<h2 id="抽象"><a class="header-anchor" href="#抽象">¶</a>抽象</h2>
<h3 id="概念"><a class="header-anchor" href="#概念">¶</a>概念</h3>
<p><img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/stardust14/picture/master/img/20200728210946.png" alt="image-20200728210458257"></p>
<h3 id="抽象方法和抽象类的格式和使用"><a class="header-anchor" href="#抽象方法和抽象类的格式和使用">¶</a>抽象方法和抽象类的格式和使用</h3>
<pre><code class="language-java">/*
抽象方法:就是加上abstract关键字，然后去掉大括号，直接分号结束。
抽象类:抽象方法所在的类，必须是抽象类才行。在class之前写上abstract即可。

如何使用抽象类和抽象方法:
19不能直接创建new抽象类对象。
2.必须用一个子类来继承抽象父类。
3.子类必须覆盖重写抽象父类当中所有的抽象方法。
覆盖重写(实现) :子类去掉抽象方法的abstract关键字，然后补上方法体大括号。
4.创建子类对象进行使用。
 */
public abstract class Animal &amp;#123;

    //这是一个抽象方法，代表吃东西，但是具体吃什么(大括号的内容)不确定。
    public abstract void eat();

    //这是一个普通的成员方法
    public void method()&amp;#123;

    &amp;#125;
&amp;#125;
</code></pre>
<pre><code class="language-java">public class Cat extends Animal &amp;#123;

    public void eat()&amp;#123;
        System.out.println(&quot;猫吃鱼&quot;);
    &amp;#125;
&amp;#125;
</code></pre>
<pre><code class="language-java">public class Dome05Main &amp;#123;

    public static void main(String[] args) &amp;#123;
        Cat cat = new Cat();
        cat.eat();
    &amp;#125;
&amp;#125;
</code></pre>
<h3 id="注意事项-v2"><a class="header-anchor" href="#注意事项-v2">¶</a>注意事项</h3>
<p>关于抽象类的使用，以下为语法上要注意的细节，虽然条目较多,但若理解了抽象的本质，无需死记硬背。<br>
1.抽象类<strong>不能创建对象</strong>，如果创建,编译无法通过而报错。只能创建其非抽象子类的对象。</p>
<blockquote>
<p>理解: 假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。</p>
</blockquote>
<p>2.抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。</p>
<blockquote>
<p>理解: 子类的构造方法中，有默认的super(),需要访问父类构造方法。</p>
</blockquote>
<p>3.抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</p>
<blockquote>
<p>理解:未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。</p>
</blockquote>
<p>4.抽象类的子类，必须重写抽象父类中<strong>所有的</strong>抽象方法，否则，编译无法通过而报错。除非该子类也是抽象类。</p>
<blockquote>
<p>理解:假设不重写所有抽象方法,则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义。</p>
</blockquote>
<h2 id="练习题-v8"><a class="header-anchor" href="#练习题-v8">¶</a>练习题</h2>
<h3 id="综合案例-群主发普通红包"><a class="header-anchor" href="#综合案例-群主发普通红包">¶</a>综合案例:群主发普通红包</h3>
<p>群主发普通红包。某群有多名成员，群主给成员发普通红包。普通红包的规则:<br>
1.群主的一笔金额，从群主余额中扣除，平均分成n等份，让成员领取。<br>
2.成员领取红包后，保存到成员余额中。<br>
请根据描述,完成案例中所有类的定义以及指定类之间的继承关系，并完成发红包的操作。</p>
<p><img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/stardust14/picture/master/img/20200728214035.png" alt="image-20200728214033747"></p>
<h4 id="实现："><a class="header-anchor" href="#实现：">¶</a>实现：</h4>
<pre><code class="language-java">public class User &amp;#123;

    private String name;//姓名
    private int money;//余额，也就是当前的所拥有的钱数

    public User() &amp;#123;
    &amp;#125;

    public User(String name, int money) &amp;#123;
        this.name = name;
        this.money = money;
    &amp;#125;

    //展示一下用户有多少钱
    public void show()&amp;#123;
        System.out.println(&quot;我叫：&quot; + name + &quot;,我有&quot; + money + &quot;钱&quot;);
    &amp;#125;

    public String getName() &amp;#123;
        return name;
    &amp;#125;

    public void setName(String name) &amp;#123;
        this.name = name;
    &amp;#125;

    public int getMoney() &amp;#123;
        return money;
    &amp;#125;

    public void setMoney(int money) &amp;#123;
        this.money = money;
    &amp;#125;
&amp;#125;
</code></pre>
<pre><code class="language-java">import java.util.ArrayList;
//群主的类
public class Manager extends User &amp;#123;
    public Manager()&amp;#123;

    &amp;#125;

    public Manager(String name, int money) &amp;#123;
        super(name, money);
    &amp;#125;

    public ArrayList&lt;Integer&gt; send(int totalMoney,int count)&amp;#123;
        //首先需要一个集合，用来存储若干个红包的余额
        ArrayList&lt;Integer&gt; redList = new ArrayList&lt;&gt;();

        //先看一下群主自己的余额
        int leftMoney = super.getMoney();//群主当前余额
        if (totalMoney &gt;leftMoney)&amp;#123;
            System.out.println(&quot;您的余额不足，请及时充值！！！&quot;);
            return redList;//返回空集合
        &amp;#125;

        //扣钱，就是重新设置余额
        super.setMoney(leftMoney - totalMoney);

        //发红包需要平均拆分成count份
        int avg = totalMoney/count;
        int mod  = totalMoney % count;//余数，也就是剩下的零头

        //除不开的零头放在最后一个红包里
        //下面把红包一个一个放在集合里
        for (int i = 0; i &lt; count - 1; i++) &amp;#123;
            redList.add(avg);
        &amp;#125;

        //最后一个红包
        int last = avg + mod;
        redList.add(last);

        return redList;
    &amp;#125;
&amp;#125;
</code></pre>
<pre><code class="language-java">import java.util.ArrayList;
import java.util.Random;
//群员的类
public class Member extends User &amp;#123;

    public Member() &amp;#123;
    &amp;#125;

    public Member(String name, int money) &amp;#123;
        super(name, money);
    &amp;#125;

    public void receive(ArrayList&lt;Integer&gt; list)&amp;#123;
        //从多个红包当中随便抽取一个，给我自己。
        //随机获取一一个集合当中的索引编号
        int index = new Random().nextInt(list.size());
        //根据索引，从集合当中删除，并且得到被删除的红包，给我自己
        int delta = list.remove(index);
        //当前成员有多少钱
        int money = super.getMoney();
        //加法，并重新设置回去
        super.setMoney(delta + money);
    &amp;#125;
&amp;#125;
</code></pre>
<pre><code class="language-java">import java.util.ArrayList;

public class MainRedPacket &amp;#123;

    public static void main(String[] args) &amp;#123;
        Manager manager = new Manager(&quot;乔布斯&quot;,1000000000);

        Member one = new Member(&quot;比尔·盖茨&quot;,999999);
        Member two = new Member(&quot;巴菲特&quot;,8888888);
        Member three = new Member(&quot;库克&quot;,666666);
        Member four = new Member(&quot;川普&quot;,222222);

        manager.show();
        one.show();
        two.show();
        three.show();
        four.show();
        System.out.println(&quot;===============&quot;);

        //群主总共发66666块钱，分成四个红包
        ArrayList&lt;Integer&gt; redList = manager.send(66666,4);
        //四个普通成员收红包
        one.receive(redList);
        two.receive(redList);
        three.receive(redList);
        four.receive(redList);

        manager.show();//随机分排
        one.show();
        two.show();
        three.show();
        four.show();


    &amp;#125;
&amp;#125;
</code></pre>
<h1>接口</h1>
<h2 id="概述与生活例举"><a class="header-anchor" href="#概述与生活例举">¶</a>概述与生活例举</h2>
<p><img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/stardust14/picture/master/img/20200729214057.png" alt="image-20200729214055457"></p>
<h2 id="定义的基本格式"><a class="header-anchor" href="#定义的基本格式">¶</a>定义的基本格式</h2>
<pre><code class="language-java">/*
在任何放本的Java中，接口都能正义抽象万法。
格式:
public abstract返回值类型方法名称(参数列表);

主意事项:
1.接口当中的抽象方法，修饰符必须是两个固定的关键字: public abstract
2.这两个关键字修饰符，可以选择性地省略。(今天刚学， 所以不推荐。)
3.方法的三要素，可以随意定义。
 */
</code></pre>
<blockquote>
<p>与类名相同才是构造方法</p>
<p>接口主要是做一些规范</p>
</blockquote>
<h2 id="接口的抽象方法的使用"><a class="header-anchor" href="#接口的抽象方法的使用">¶</a>接口的抽象方法的使用</h2>
<pre><code class="language-java">/*
接口使用步骤:
1.接口不能直接使用，必须有一个“实现类&quot;来“实现&quot;该接口。
格式:
public class 实现类名称implements 接口名称&amp;#123;
    //.....
&amp;#125;
2.接口的实现类必须覆盖重写(实现)接口中所有的抽象方法。
实现:去掉abstract关键字，加上方法体大括号。
3.创建实现类的对象，进行使用。

注意事项:
如果实现类并没有覆盖重写接口中所有的抽象方法，那么这个实现类自己就必须是抽象类。
 */
public class Dome01Interface &amp;#123;

    public static void main(String[] args) &amp;#123;
        //错误写法！不能直接new接口对象使用。
//        MyInterfaceAbstract inter = new MyInterfaceAbstract();

        //创建实现类的对象使用
        MyInterfaceAbstractImpl impl = new MyInterfaceAbstractImpl();
        impl.methodAbs();

    &amp;#125;
&amp;#125;
</code></pre>
<pre><code class="language-java">public interface MyInterfaceAbstract &amp;#123;

    public abstract void methodAbs();//public和abstract可以省略其一，或着全部省略

&amp;#125;
</code></pre>
<pre><code class="language-java">public class MyInterfaceAbstractImpl  implements MyInterfaceAbstract&amp;#123;
    @Override//辨识重写
    public void methodAbs() &amp;#123;
        System.out.println(&quot;implements方法执行了！&quot;);
    &amp;#125;
&amp;#125;
</code></pre>
<h2 id="接口的默认方法定义与使用"><a class="header-anchor" href="#接口的默认方法定义与使用">¶</a>接口的默认方法定义与使用</h2>
<pre><code class="language-java">/*
从Java 8开始，接口里允许定义默认方法。
格式:
public default 返回值类型方法名称(参数列表) &amp;#123;
    方法体
&amp;#125;

备注:接口当中的默认方法，可以解决接口升级的问题。
 */
public interface MyInterfaceDefault &amp;#123;
    //抽象方法
    public abstract void methodAbsA();

    //新添加一个抽象方法
//    public abstract void methodAbsB();

    //新添加的方法，改写为默认方法
    //新添加的这个方法，不需要去修改AorB
    public default void methodDefault()&amp;#123;
        System.out.println(&quot;这是新添加的默认方法&quot;);
    &amp;#125;
&amp;#125;
</code></pre>
<pre><code class="language-java">public class MyInterfaceDefaultA implements MyInterfaceDefault &amp;#123;
    @Override
    public void methodAbsA() &amp;#123;
        System.out.println(&quot;这个抽象方法执行了：AAAAAAAAAA&quot;);
    &amp;#125;
&amp;#125;
</code></pre>
<pre><code class="language-java">public class MyInterfaceDefaultB implements MyInterfaceDefault &amp;#123;
    @Override
    public void methodAbsA() &amp;#123;
        System.out.println(&quot;这个抽象方法执行了：BBBBBBBB&quot;);
    &amp;#125;

    @Override
    public void methodDefault() &amp;#123;
        System.out.println(&quot;实现B类覆盖重写了接口的默认方法&quot;);
    &amp;#125;
&amp;#125;
</code></pre>
<pre><code class="language-java">public class Dome02Interface &amp;#123;

    public static void main(String[] args) &amp;#123;
        MyInterfaceDefaultA a = new MyInterfaceDefaultA();

        a.methodAbsA();//调用抽象方法，实际运行的是右侧实现类。

        //调用默认方法，如果实现类当中没有，会向上找接口
        a.methodDefault();//这是新添加的默认方法
        System.out.println(&quot;===========&quot;);

        MyInterfaceDefaultB b = new MyInterfaceDefaultB();
        b.methodAbsA();//这个抽象方法执行了：BBBBBBBB
        b.methodDefault();//实现B类覆盖重写了接口的默认方法

    &amp;#125;
&amp;#125;
</code></pre>
<blockquote>
<p>抽象类利于代码的复写，接口利于代码的维护</p>
<p>接口可以看成一种特殊的抽象类</p>
</blockquote>
<h2 id="接口的静态方法定义与使用"><a class="header-anchor" href="#接口的静态方法定义与使用">¶</a>接口的静态方法定义与使用</h2>
<pre><code class="language-java">/*
从Java 8开始，接口当中允许定义静态方法。
格式:
public static 返回值类型方法名称(参数列表) &amp;#123;
    方法体
&amp;#125;
提示:就是将abstract或者default换成static即可，带上方法体。
 */
public interface MyInterfaceStatic &amp;#123;

    public static void method()&amp;#123;
        System.out.println(&quot;这是接口的静态方法&quot;);
    &amp;#125;
&amp;#125;
</code></pre>
<pre><code class="language-java">/*
注意事项:不能通过接口实现类的对象来调用接口当中的静态方法。
正确用法:通过接口名称，直接调用其中的静态方法。
格式:
接口名称.静态方法名(参数);
 */
public class Dome03Interface &amp;#123;

    public static void main(String[] args) &amp;#123;
        //直接通过接口名称调用静态方法
        MyInterfaceStatic.method();
    &amp;#125;
&amp;#125;
</code></pre>
<h2 id="接口的私有方法定义与使用"><a class="header-anchor" href="#接口的私有方法定义与使用">¶</a>接口的私有方法定义与使用</h2>
<pre><code class="language-java">/*
问题描述:
我们需要抽取一个共有方法，用来解快两个默认方法之间重复代码的问题。
但是这个共有方法不应该让实现类使用，应该是私有化的。

解决方案:
从Java 9开始，接口当中允许定义私有方法。
1. 普通私有方法，解决多个默认方法之间重复代码问题
格式:
private 返回值类型方法名称(参数列表) &amp;#123;
    方法体
&amp;#125;
2.静态私有方法，解决多个静态方法之间重复代码问题
格式:
private static 返回值类型方法名称(参数列表) &amp;#123;
    方法体
&amp;#125;
 */
public interface MyInterfacePrivateA &amp;#123;

    public default void methodDefacult1()&amp;#123;
        System.out.println(&quot;默认方法1&quot;);
        methodCommon();
    &amp;#125;

    public default void methodDefacult2()&amp;#123;
        System.out.println(&quot;默认方法2&quot;);
        methodCommon();
    &amp;#125;

    private void methodCommon()&amp;#123;
        System.out.println(&quot;AAAA&quot;);
        System.out.println(&quot;BBBB&quot;);
        System.out.println(&quot;CCCC&quot;);
    &amp;#125;
&amp;#125;
</code></pre>
<pre><code class="language-java">public interface MyInterfacePrivateB &amp;#123;

    public static void methodStatic1()&amp;#123;
        System.out.println(&quot;静态方法1&quot;);
        methodStaticCommon();
    &amp;#125;

    public static void methodStatic2()&amp;#123;
        System.out.println(&quot;静态方法2&quot;);
        methodStaticCommon();
    &amp;#125;

    private static void methodStaticCommon()&amp;#123;
        System.out.println(&quot;AAAA&quot;);
        System.out.println(&quot;BBBB&quot;);
        System.out.println(&quot;CCCC&quot;);
    &amp;#125;
&amp;#125;
</code></pre>
<h2 id="接口的常量定义和使用"><a class="header-anchor" href="#接口的常量定义和使用">¶</a>接口的常量定义和使用</h2>
<pre><code class="language-java">/*
接口:当中也可以定义“成员变量”，但是必须使用public static final三个关键字进行修饰。
从效果上看，这其实就是接口的【常量】。
格式:
public static final 数据类型常量名称=数据值;

备注:
一旦使用final关键字进行修饰，说明不可改变。

注意事项:
1.接口当中的常量，可以省略public static final, 注意:不写也照样是这样。
2.接口当中的常量，必须进行赋值;不能不赋值。
3.接口中常量的名称，使用完全大写的字母，用下划线进行分隔。(推荐命名规则)
 */
public interface MyInterfaceConst &amp;#123;

    public static final int NUM_OF_MYCLASS= 10;
&amp;#125;
</code></pre>
<h2 id="小结"><a class="header-anchor" href="#小结">¶</a>小结</h2>
<p>在Java 9+版本中，接口的内容可以有:<br>
1.成员变量其实是常量，格式:[public] [static] [final] 数据类型常量名称=数据值;</p>
<blockquote>
<p>注意:<br>
常量必须进行赋值，而且一旦赋值不能改变。<br>
常量名称完全大写，用下划线进行分隔。</p>
</blockquote>
<p>2.接口中最重要的就是抽象方法，格式:<br>
[public] [abstract] 返回值类型方法名称(参数列表);</p>
<blockquote>
<p>注意:实现类必须覆盖重写接口所有的抽象方法，除非实现类是抽象类。</p>
</blockquote>
<p>3.从Java 8开始，接口里允许定义默认方法，格式:<br>
[public] default 返回值类型方法名称(参数列表) {方法体}</p>
<blockquote>
<p>注意:默认方法也可以被覆盖重写</p>
</blockquote>
<p>4.从Java 8开始，接口里允许定义静态方法，格式:<br>
[public] static 返回值类型方法名称(参数列表) {方法体}</p>
<blockquote>
<p>注意:应该通过接口名称进行调用，不能通过实现类对象调用接口静态方法</p>
</blockquote>
<p>5.从Java 9开始，接口里允许定义私有很乏，格式:<br>
普通私有方法: private 返回值类型方法名称(参数列表) {方法体}<br>
静态私有方法: private static 返回值类型方法名称(参数列表) {方法体}</p>
<blockquote>
<p>注意:private的方法只有接口自己才能调用，不能被实现类或别人使用。</p>
</blockquote>
<h2 id="继承父类并实现多种接口"><a class="header-anchor" href="#继承父类并实现多种接口">¶</a>继承父类并实现多种接口</h2>
<pre><code class="language-java">/*
使用接口的时候，需要注意:
1.接口是没有静态代码块或者构造方法的。
2.一个类的直接父类是唯一的，但是一个类可以同时实现多个接口。
格式:
public class MyInterfaceImpl impl ements MyInterfaceA, MyInterfaceB &amp;#123;
	//覆盖重写所有抽象方法
&amp;#125;
3.如果实现类所实现的多个接口当中，存在重复的抽象方法，那么只需要覆盖重写一次即可。
4.如果实现类没有覆盖重写所有接口当中的所有抽象方法，那么实现类就必须是一个抽象类。
5.如果实现类锁实现的多个接口当中，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写。
6.一个类如果直接父类当中的方法，和接口当中的默认方法产生了冲突，优先用父类当中的方法。
*/
</code></pre>
<h2 id="接口之间的多继承"><a class="header-anchor" href="#接口之间的多继承">¶</a>接口之间的多继承</h2>
<p>1.类与类之间是单继承的。直接父类只有一个 。<br>
2.类与接口之间是多实现的。一个类可以实现多个接口。<br>
3.接口与接口之间是多继承的。</p>
<p>注意事项:<br>
1.多个父接口当中的抽象方法如果重复，没关系。<br>
2.多个父接口当中的默认方法如果重复，那么子接口必须进行默认方法的覆盖重写， <strong>【而且带着default关键字】</strong>。</p>
<h1>多态性</h1>
<h2 id="概述-v6"><a class="header-anchor" href="#概述-v6">¶</a>概述</h2>
<p><img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/stardust14/picture/master/img/20200802215932.png" alt="image-20200802215928812"></p>
<h2 id="格式与使用"><a class="header-anchor" href="#格式与使用">¶</a>格式与使用</h2>
<pre><code class="language-java">/*
代码当中体现多态性，其实就是一句话: 父类引用指向子类对象。

格式:
父类名称对象名= new 子类名称();
或者:
接口名称对象名= new 实现类名称();
*/
</code></pre>
<blockquote>
<p>左父右子</p>
</blockquote>
<h2 id="成员变量的使用特点"><a class="header-anchor" href="#成员变量的使用特点">¶</a>成员变量的使用特点</h2>
<p>访问成员变量的两种方式:<br>
1.直接通过对象名称访问成员变量:看等号左边是谁，优先用谁，没有则向上找。<br>
2.间接通过成员方法访问成员变量:看该方法属于谁，优先用谁，没有则向上找。</p>
<blockquote>
<p>访问成员变量不能覆盖重写，访问成员方法可以覆盖重写</p>
<p>永远不会向下找</p>
</blockquote>
<h2 id="成员方法的使用特点"><a class="header-anchor" href="#成员方法的使用特点">¶</a>成员方法的使用特点</h2>
<p>在多态的代码当中，成员方法的访问规则是:<br>
看new的是谁，就优先用谁，没有则向上找。</p>
<blockquote>
<p>口诀:编译看左边，运行看右边。成员变量不在此列，规则不同</p>
</blockquote>
<p><em>对比一下:</em><br>
成员变量:编译看左边，运行还看左边。<br>
成员方法:编译看左边，运行看右边。</p>
<h2 id="使用多态的好处"><a class="header-anchor" href="#使用多态的好处">¶</a>使用多态的好处</h2>
<p><img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/stardust14/picture/master/img/20200802223437.png" alt="image-20200802223149584"></p>
<h2 id="对象的向上转型和向下转型"><a class="header-anchor" href="#对象的向上转型和向下转型">¶</a>对象的向上转型和向下转型</h2>
<p><img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/stardust14/picture/master/img/20200803144143.png" alt="image-20200803144141656"></p>
<h2 id="用instanceof关键字进行判断"><a class="header-anchor" href="#用instanceof关键字进行判断">¶</a>用instanceof关键字进行判断</h2>
<p>如何才能知道-个父类引用的对象，本来是什么子类?<br>
<strong>格式:</strong><br>
对象<code>instanceof</code> 类名称<br>
这将会得到一个<strong>boolean值</strong>结果， 也就是判断前面的对象能不能当做后面类型的实例。</p>
<blockquote>
<p>这样的好处：向下转型防止发生异常</p>
</blockquote>
<h2 id="笔记本USB接口案例"><a class="header-anchor" href="#笔记本USB接口案例">¶</a>笔记本USB接口案例</h2>
<h3 id="笔记本电脑"><a class="header-anchor" href="#笔记本电脑">¶</a>笔记本电脑</h3>
<p>笔记本电脑(laptop) 通常具备使用USB设备的功能。在生产时，笔记本都预留了可以插入USB设备的USB接口,<br>
但具体是什么USB设备，笔记本厂商并不关心，只要符合USB规格的设备都可以。</p>
<p>定义USB接口，具备最基本的开启功能和关闭功能。鼠标和键盘要想能在电脑上使用，那么鼠标和键盘也必须遵守<br>
USB规范，实现USB接口，否则鼠标和键盘的生产出来也无法使用。</p>
<h3 id="案例分析"><a class="header-anchor" href="#案例分析">¶</a>案例分析</h3>
<p>进行描述笔记本类，实现笔记本使用USB鼠标、USB键盘<br>
●USB接口，包含打开设备功能、关闭设备功能<br>
●笔记本类，包含开机功能、关机功能、使用USB设备功能<br>
●鼠标类，要实现USB接口,并具备点击的方法<br>
●键盘类，要实现USB接口，具备敲击的方法</p>
<p><img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/stardust14/picture/master/img/20200803232808.png" alt="image-20200803145842708"></p>
<h3 id="案例实现"><a class="header-anchor" href="#案例实现">¶</a>案例实现</h3>
<pre><code class="language-java">public interface USB &amp;#123;

    public abstract void open();//打开设备
    public abstract void close();//关闭设备
&amp;#125;
</code></pre>
<pre><code class="language-Java">public class Computer &amp;#123;

    public void poweron()&amp;#123;
        System.out.println(&quot;笔记本电脑开机&quot;);
    &amp;#125;

    public void poweroff()&amp;#123;
        System.out.println(&quot;笔记本电脑关机&quot;);
    &amp;#125;

    public void useDevice(USB usb)&amp;#123;
        usb.open();//打开设备
        if (usb instanceof Mouse)&amp;#123;//一定要先进行判断
            Mouse mouse = (Mouse) usb;//向下转型
            mouse.click();
        &amp;#125;
        if (usb instanceof Keyboard)&amp;#123;
            Keyboard keyboard =(Keyboard) usb;//向下转型
            keyboard.type();
        &amp;#125;
        usb.close();//关闭设备
    &amp;#125;
&amp;#125;
</code></pre>
<pre><code class="language-java">//鼠标就是一个USB设备
public class Mouse implements USB &amp;#123;
    @Override
    public void open() &amp;#123;
        System.out.println(&quot;打开鼠标&quot;);
    &amp;#125;

    @Override
    public void close() &amp;#123;
        System.out.println(&quot;关闭鼠标&quot;);
    &amp;#125;

    public void click()&amp;#123;
        System.out.println(&quot;点击鼠标&quot;);
    &amp;#125;
&amp;#125;
</code></pre>
<pre><code class="language-java">//键盘就是一个USB设备
public class Keyboard implements USB &amp;#123;
    @Override
    public void open() &amp;#123;
        System.out.println(&quot;打开键盘&quot;);
    &amp;#125;

    @Override
    public void close() &amp;#123;
        System.out.println(&quot;关闭键盘&quot;);
    &amp;#125;

    public void type()&amp;#123;
        System.out.println(&quot;键盘输入&quot;);
    &amp;#125;
&amp;#125;
</code></pre>
<pre><code class="language-java">public class DomeMain &amp;#123;

    public static void main(String[] args) &amp;#123;
        //首先创建一个笔记本电脑
        Computer compuer = new Computer();
        compuer.poweron();

        //准备一个竖标，供电脑使用
//        Mouse mouse = new Mouse();//这是一种方法
        //首先准备向上转型
        USB usbMouse = new Mouse();//这是另一种方法,多态写法
        //参数是USB类型，我正好传递进去的就是USB鼠标
        compuer.useDevice(usbMouse);

        Keyboard keyboard = new Keyboard();//没有使用多态写法
        //方法参数是USB类型，传递进去的是实现类对象
        compuer.useDevice(keyboard);//正确写法!也发生了向上转型
        //
//        compuer.useDevice(new Keyboard());//这也是正确写法
        compuer.poweroff();
        System.out.println(&quot;============&quot;);

        //对于没有使用多态写法的解释
        method(10.0);//正确写法，double --&gt; double
        method(20);//正确写法，int--&gt;double
        int a = 30;
        method(a);//正确写法，int--&gt;double
    &amp;#125;

    public static void method(double num)&amp;#123;
        System.out.println(num);
    &amp;#125;
&amp;#125;
</code></pre>
<h1>final关键字</h1>
<h2 id="概念及用法"><a class="header-anchor" href="#概念及用法">¶</a>概念及用法</h2>
<p>final关键字代表最终、不可改变的。<br>
常见四种用法:<br>
1.可以用来修饰一个类<br>
2.可以用来修饰一个方法<br>
3.可以用来修饰一个局部变量<br>
4.还可以用来修饰一一个成员变量</p>
<h2 id="用于修饰类"><a class="header-anchor" href="#用于修饰类">¶</a>用于修饰类</h2>
<pre><code class="language-java">/*
当final天键字用来修饰一个类的时候，格式:
public final class类名称&amp;#123;
    //...
&amp;#125;

含义:当前这个类不能有任何的子类。(太监类)
注意:一个类如果是final的，那么其中所有的成员方法都无法进行覆盖重写(因为没儿子。)
 */
public final class Myclass &amp;#123;
    public void method()&amp;#123;
        System.out.println(&quot;final方法类&quot;);
    &amp;#125;

&amp;#125;
</code></pre>
<h2 id="用于修饰成员方法"><a class="header-anchor" href="#用于修饰成员方法">¶</a>用于修饰成员方法</h2>
<pre><code class="language-java">/*
当final关键字用来修饰一一个方法的时候，这个方法就是最终方法，也就是不能被覆盖重写。
格式:
修饰符final 返回值类型方法名称(参数列表) &amp;#123;
    //方法体
&amp;#125;

注意事项:
对于类、方法来说，abstract关键字和final关键字不能同时使用，因为矛盾。
 */
public abstract class Fu &amp;#123;

    public final void method()&amp;#123;
        System.out.println(&quot;父类方法执行&quot;);
    &amp;#125;
    
    public abstract /*final*/ void methodAbs();
&amp;#125;
</code></pre>
<h2 id="用于修饰局部变量"><a class="header-anchor" href="#用于修饰局部变量">¶</a>用于修饰局部变量</h2>
<pre><code class="language-java">public class Dome01Final &amp;#123;

    public static void main(String[] args) &amp;#123;
        int num1 = 10;
        System.out.println(num1);//10
        num1 = 20;
        System.out.println(num1);//20

        //一旦使用final用来修饰局部变量，那么这个变量就不能进行更改。
        //“一次赋值，终生不变
        final int num2 = 100;
        System.out.println(num2);

//        num2 = 250;//错误写法，不能改变
//        num2 = 100;//错误写法！

        //正确写法，只要保证有唯一一次赋值即可
        final int num3;
        num3 = 300;

        //对于基本类型来说， 不可变说的是变量当中的数据不 可改变
        //对于引用类型来说，不可变说的是变量当中的地址值不可改变
        Student stu1 = new Student(&quot;Rose&quot;);
        System.out.println(stu1.getName());//Rose
        System.out.println(stu1);
        stu1 = new Student(&quot;Rechal&quot;);
        System.out.println(stu1);
        System.out.println(stu1.getName());//Rechal
        System.out.println(&quot;==========&quot;);

        final Student stu2 = new Student(&quot;Jeoy&quot;);//Jeoy
        //错误写法！final的引用类型变量，其中的地址不可改变
//        stu2 = new Student(&quot;Pheebs&quot;);
        stu2.setName(&quot;Chandler&quot;);//Chandler

    &amp;#125;
&amp;#125;
</code></pre>
<h2 id="用于修饰成员变量"><a class="header-anchor" href="#用于修饰成员变量">¶</a>用于修饰成员变量</h2>
<pre><code class="language-java">/*
对于成员变量来说，如果使用final关键字修饰，那么这个变量也照样是不可变。

1.由于成员变量具有默认值，所以用了final之后必须手动赋值，不会再给默认值了。
2.对于final的成员变量，要么使用直接赋值，要么通过构造方法赋值。二者选其一
3.必须保证类当中所有重载的构造方法，都最终会对final的成员变量进行赋值。
 */
public class Person &amp;#123;

    final private String name/* = &quot;Mon&quot;*/;

    public Person() &amp;#123;
        name =&quot;Chandler&quot;;
    &amp;#125;

    public Person(String name) &amp;#123;
        this.name = name;
    &amp;#125;

    public String getName() &amp;#123;
        return name;
    &amp;#125;

   /* public void setName(String name) &amp;#123;
        this.name = name;
    &amp;#125;*/
&amp;#125;
</code></pre>
<h2 id="四种权限修饰符"><a class="header-anchor" href="#四种权限修饰符">¶</a>四种权限修饰符</h2>
<p><strong>Java中有四种权限修饰符:</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>public &gt;</th>
<th>protected &gt;</th>
<th>(default) &gt;</th>
<th style="text-align:center">private</th>
</tr>
</thead>
<tbody>
<tr>
<td>同一个类(我自己)</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
<td style="text-align:center">YES</td>
</tr>
<tr>
<td>同一个包(我邻居)</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
<td style="text-align:center">NO</td>
</tr>
<tr>
<td>不同包子类(我儿子)</td>
<td>YES</td>
<td>YES</td>
<td>NO</td>
<td style="text-align:center">NO</td>
</tr>
<tr>
<td>不同包非子类(陌生人)</td>
<td>YES</td>
<td>NO</td>
<td>NO</td>
<td style="text-align:center">NO</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注意事项: (default)并不是关键字“default&quot;， 而是根本不写。</p>
</blockquote>
<h1>内部类</h1>
<h2 id="概念与分类"><a class="header-anchor" href="#概念与分类">¶</a>概念与分类</h2>
<p>如果一个事物的内部包含另一个事物，那么这就是一个类内部包含另一个类。<br>
例如:身体和心脏的关系。又如:汽车和发动机的关系。</p>
<p>分类:<br>
1.成员内部类<br>
2.局部内部类(包含匿名内部类)</p>
<h2 id="成员内部类的定义"><a class="header-anchor" href="#成员内部类的定义">¶</a>成员内部类的定义</h2>
<p>成员内部类的定义格式:	<br>
修饰符class 外部类名称{<br>
修饰符class 内部类名称{<br>
//…<br>
}<br>
//…<br>
}</p>
<pre><code class="language-java">public class Body &amp;#123;//外部类

    public class Heart&amp;#123;//成员内部类
        //内部类的方法
        public void beat()&amp;#123;
            System.out.println(&quot;心脏跳动：咚咚咚~~~&quot;);
            System.out.println(&quot;我叫&quot; + name);
        &amp;#125;
    &amp;#125;
    //外部类的成员变量
    private String name;

    //外部类的方法
    public void methodBody()&amp;#123;
        System.out.println(&quot;外部类的方法&quot;);
    &amp;#125;

    public String getName() &amp;#123;
        return name;
    &amp;#125;

    public void setName(String name) &amp;#123;
        this.name = name;
    &amp;#125;
&amp;#125;
</code></pre>
<blockquote>
<p>注意:内用外，随意访问;外用内，需要内部类对象。需要命令Recompile命令Ctrl+Shift+F9</p>
</blockquote>
<h2 id="成员内部类的使用"><a class="header-anchor" href="#成员内部类的使用">¶</a>成员内部类的使用</h2>
<pre><code class="language-java">public class Body &amp;#123;//外部类

    public class Heart&amp;#123;//成员内部类
        //内部类的方法
        public void beat()&amp;#123;
            System.out.println(&quot;心脏跳动：咚咚咚~~~&quot;);
            System.out.println(&quot;我叫&quot; + name);
        &amp;#125;
    &amp;#125;
    //外部类的成员变量
    private String name;

    //外部类的方法
    public void methodBody()&amp;#123;
        System.out.println(&quot;外部类的方法&quot;);
        //新添加的调用内部类的一种方法
        /*Heart heart = new Heart();
        heart.beat();*/
        new Heart().beat();//这是另一种方法
    &amp;#125;

    public String getName() &amp;#123;
        return name;
    &amp;#125;

    public void setName(String name) &amp;#123;
        this.name = name;
    &amp;#125;
&amp;#125;
</code></pre>
<pre><code class="language-java">/*
如何使用成员内部类?有两种方式:
1.间接方式:在外部类的方法当中，使用内部类;然后main只是调用外部类的方法。
2.直接方式，公式:
类名称对象名= new类名称();
【外部类名称.内部类名称对象名= new 外部类名称().new内部类名称();】
 */
public class Dome01InnerClass &amp;#123;

    public static void main(String[] args) &amp;#123;
        Body body = new Body();//外部类的对象
        //通过外部类的对象，调用外部类的方法，里面间接在使用内部类Heart
        body.methodBody();
        System.out.println(&quot;=============&quot;);

        //按照公式写
        Body.Heart heart = new Body().new Heart();
        heart.beat();
    &amp;#125;
&amp;#125;
</code></pre>
<h2 id="内部类的同名变量访问"><a class="header-anchor" href="#内部类的同名变量访问">¶</a>内部类的同名变量访问</h2>
<pre><code class="language-java">/*
如果出现了重名现象，那么格式是:外部类名称. this .外部类成员变量名
 */
public class Outer &amp;#123;

    int num = 10;//外部类的成员变量
    public class Inner&amp;#123;
        int num = 20;

        public void methodInner()&amp;#123;
            int num = 30;//内部类方法的局部变量
            System.out.println(num);//局部变量，就近原则
            System.out.println(this.num);//内部类的成员变量
            System.out.println(Outer.this.num);//外部类的成员变量
        &amp;#125;
    &amp;#125;
&amp;#125;
</code></pre>
<pre><code class="language-java">public class Dome02InnerClass &amp;#123;

    public static void main(String[] args) &amp;#123;
        //外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称();
        Outer.Inner obj = new Outer().new Inner();
        obj.methodInner();
    &amp;#125;
&amp;#125;
</code></pre>
<h2 id="局部内部类定义"><a class="header-anchor" href="#局部内部类定义">¶</a>局部内部类定义</h2>
<pre><code class="language-java">/*
如果一个类是定义在一 个方法内部的，那么这就是一个局部内部类。
“局部”:只有当前所属的方法才能使用它，出了这个方法外面就不能用了。

定义格式:
修饰符class外部类名称&amp;#123;
    修饰符返回值类型外部类方法名称(参数列表) &amp;#123;
        class局部内部类名称&amp;#123;
            // ...
        &amp;#125;
    &amp;#125;
&amp;#125;

小节一下类的权限修饰符:
public &gt; protected &gt; (default) &gt; private
定义一个类的时候，权限修饰符规则:
1.外部类: public / (default)
2.成员内部类: public / protected / (default) / private
3.局部内部类:什么都不能写
 */
public class Outer01 &amp;#123;

    public void methodOuter()&amp;#123;
        class Inner&amp;#123;//局部内部类
            int num = 10;
            public void mothodInner()&amp;#123;
                System.out.println(num);//10
            &amp;#125;
        &amp;#125;
        //使用局部类，除了当前方法，谁用都不行
        Inner inner = new Inner();
        inner.mothodInner();
    &amp;#125;
&amp;#125;
</code></pre>
<pre><code class="language-java">public class DomeMain &amp;#123;

    public static void main(String[] args) &amp;#123;
        Outer01 obj = new Outer01();
        obj.methodOuter();
    &amp;#125;
&amp;#125;
</code></pre>
<h2 id="局部内部类的final问题"><a class="header-anchor" href="#局部内部类的final问题">¶</a>局部内部类的final问题</h2>
<pre><code class="language-java">/*
局部内部类，如果希望访问所在方法的局部变量，那么这个局部变量必须是【有效final的】。

备注:从Java 8+开始，只要局部变量事实不变，那么final关键字可以省略。

原因:
1. new出来的对象在堆内存当中。
2.局部变量是跟着方法走的，在栈内存当中。
3.方法运行结束之后，立刻出栈，局部变量就会立刻消失。
4.但是new出来的对象会在堆当中持续存在，直到垃圾回收消失。
 */
public class MyOuter &amp;#123;

    public void methodOuter()&amp;#123;
        int num = 10;//所在方法的局部变量

        class MyInnner&amp;#123;
            public void methodInner()&amp;#123;
                System.out.println(num);
            &amp;#125;
        &amp;#125;
    &amp;#125;
&amp;#125;
</code></pre>
<h2 id="匿名内部类及其注意事项"><a class="header-anchor" href="#匿名内部类及其注意事项">¶</a>匿名内部类及其注意事项</h2>
<pre><code class="language-java">/*
如果接口的实现类(或者是父类的子类)只需要使用唯一的一次，
那么这种情况下就可以省略掉该类的定义，而改为使用【匿名内部类】

匿名内部类的定义格式:
接口名称对象名= new 接口名称() &amp;#123;
    // 覆盖重写所有抽象方法
&amp;#125;;

对格式“new接口名称() &amp;#123;... &amp;#125;进行解析:
1. new代表创建对象的动作
2.接口名称就是匿名内部类需要实现哪个接口
3. &amp;#123;... &amp;#125;这才是匿名内部类的内容

另外还要注意几点问题:
1.匿名内部类，在【创建对象】的时候，只能使用唯一次。
如果希望多次创建对象，而且类的内容一样的话， 那么就必须使用单独定义的实现类了。
2.匿名对象，在【调用方法】的时候，只能调用唯一次。
如果希望同一个对象，调用多次方法，那么必须给对象起个名字。
3.匿名内部类是省略了【实现类子类名称】，但是匿名对象是省略了【对象名称】
强调:匿名内部类和匿名对象不是一回事！！！
 */
public class Dome01Main &amp;#123;

    public static void main(String[] args) &amp;#123;
        //使用匿名内部类,但不是匿名对象，对象名称就叫objA
        MyInterface objA = new MyInterface() &amp;#123;
            @Override
            public void method1() &amp;#123;
                System.out.println(&quot;匿名内部类实现了方法!111-A&quot;);
            &amp;#125;
            @Override
            public void method2() &amp;#123;
                System.out.println(&quot;匿名内部类实现了方法！222-A&quot;);
            &amp;#125;
        &amp;#125;;
        objA.method1();
        objA.method2();
        System.out.println(&quot;==========&quot;);

    //使用了匿名对象类，而且省略了对象名称，也是匿名对象
    new MyInterface() &amp;#123;
        @Override
        public void method1() &amp;#123;
            System.out.println(&quot;匿名内部类实现了方法!111-B&quot;);
        &amp;#125;
        @Override
        public void method2() &amp;#123;
            System.out.println(&quot;匿名内部类实现了方法！222-B&quot;);
        &amp;#125;
    &amp;#125;.method1();

    //因为匿名对象无法调用第二次方法，所以需要在创建一个匿名内部类的匿名对象
        new MyInterface() &amp;#123;
            @Override
            public void method1() &amp;#123;
                System.out.println(&quot;匿名内部类实现了方法!111-B&quot;);
            &amp;#125;
            @Override
            public void method2() &amp;#123;
                System.out.println(&quot;匿名内部类实现了方法！222-B&quot;);
            &amp;#125;
        &amp;#125;.method2();
    &amp;#125;
&amp;#125;
</code></pre>
<h2 id="类作为成员变量类型"><a class="header-anchor" href="#类作为成员变量类型">¶</a>类作为成员变量类型</h2>
<pre><code class="language-java">//游戏当中的英雄角色类
public class Hero &amp;#123;

    private String name;//英雄的名字
    private int age;//英雄的年龄
    private Weapon weapon;//英雄的武器

    public Hero() &amp;#123;
    &amp;#125;

    public Hero(String name, int age, Weapon weapon) &amp;#123;
        this.name = name;
        this.age = age;
        this.weapon = weapon;
    &amp;#125;

    public void attack()&amp;#123;
        System.out.println(&quot;年龄为&quot; + age + &quot;的&quot; + name + &quot;用&quot; +weapon.getCode() + &quot;击败了敌方英雄&quot;);
    &amp;#125;
    public String getName() &amp;#123;
        return name;
    &amp;#125;

    public void setName(String name) &amp;#123;
        this.name = name;
    &amp;#125;

    public int getAge() &amp;#123;
        return age;
    &amp;#125;

    public void setAge(int age) &amp;#123;
        this.age = age;
    &amp;#125;

    public Weapon getWeapon() &amp;#123;
        return weapon;
    &amp;#125;

    public void setWeapon(Weapon weapon) &amp;#123;
        this.weapon = weapon;
    &amp;#125;
&amp;#125;
</code></pre>
<pre><code class="language-java">//英雄的武器类
public class Weapon &amp;#123;

    private String code;//英雄的武器代号

    public Weapon() &amp;#123;
    &amp;#125;

    public Weapon(String code) &amp;#123;
        this.code = code;
    &amp;#125;

    public String getCode() &amp;#123;
        return code;
    &amp;#125;

    public void setCode(String code) &amp;#123;
        this.code = code;
    &amp;#125;
&amp;#125;
</code></pre>
<pre><code class="language-java">public class Dome02Main &amp;#123;

    public static void main(String[] args) &amp;#123;
        //创建一个英雄角色
        Hero hero = new Hero();
        //为英雄起一个名字，并设置年龄
        hero.setName(&quot;盖伦&quot;);
        hero.setAge(20);

        //创建一个英雄武器
        Weapon weapon = new Weapon(&quot;多兰剑&quot;);
        hero.setWeapon(weapon);

        hero.attack();
    &amp;#125;
&amp;#125;
</code></pre>
<h2 id="接口作为成员变量类型"><a class="header-anchor" href="#接口作为成员变量类型">¶</a>接口作为成员变量类型</h2>
<pre><code class="language-java">public class Hero01 &amp;#123;

    private String name;//英雄的名字
    private Skill skill;//英雄的技能

    public Hero01() &amp;#123;
    &amp;#125;

    public Hero01(String name, Skill skill) &amp;#123;
        this.name = name;
        this.skill = skill;
    &amp;#125;

    public void attack()&amp;#123;
        System.out.println(&quot;我叫&quot; + name + &quot;,开始释放技能：&quot;);
        skill.use();//调用接口中的抽象方法
        System.out.println(&quot;释放技能完成！&quot;);
    &amp;#125;

    public String getName() &amp;#123;
        return name;
    &amp;#125;

    public void setName(String name) &amp;#123;
        this.name = name;
    &amp;#125;

    public Skill getSkill() &amp;#123;
        return skill;
    &amp;#125;

    public void setSkill(Skill skill) &amp;#123;
        this.skill = skill;
    &amp;#125;
&amp;#125;
</code></pre>
<pre><code class="language-java">public interface Skill &amp;#123;

    void use();//释放技能的抽象方法
&amp;#125;
</code></pre>
<pre><code class="language-java">public class SkillImpl implements Skill &amp;#123;
    @Override
    public void use() &amp;#123;
        System.out.println(&quot;Biu~Biu~Biu~&quot;);
    &amp;#125;
&amp;#125;
</code></pre>
<pre><code class="language-java">public class DomeGame &amp;#123;

    public static void main(String[] args) &amp;#123;
        Hero01 hero01 = new Hero01();
        hero01.setName(&quot;艾希&quot;);

        //设置英雄技能
//        hero01.setSkill(new SkillImpl());//使用单独定义的实现类

        //还可以改成使用匿名内部类
        /*Skill skill = new Skill() &amp;#123;
            @Override
            public void use() &amp;#123;
                System.out.println(&quot;Pia~Pia~Pia~&quot;);
            &amp;#125;
        &amp;#125;;
        hero01.setSkill(skill);*/

        //进一步简化
        hero01.setSkill(new Skill() &amp;#123;
            @Override
            public void use() &amp;#123;
                System.out.println(&quot;Biu~Pia~Biu~Pia~&quot;);
            &amp;#125;
        &amp;#125;);
        hero01.attack();
    &amp;#125;
&amp;#125;
</code></pre>
<h2 id="接口作为方法的参数或返回值"><a class="header-anchor" href="#接口作为方法的参数或返回值">¶</a>接口作为方法的参数或返回值</h2>
<pre><code class="language-java">import java.util.ArrayList;
import java.util.List;
/*
java.util.List正是ArrayList所实现的接口。
 */
public class DomeInterface &amp;#123;

    public static void main(String[] args) &amp;#123;
        //左边是接口名称，右边是实现类名称，这就是多态写法
        List&lt;String&gt; list = new ArrayList&lt;&gt;();

        List&lt;String&gt; result = addNames(list);
        for (int i = 0; i &lt; result.size(); i++) &amp;#123;
            System.out.println(result.get(i));
        &amp;#125;
    &amp;#125;
        //给了一个空集合，进来之后添加了，出去之后就有新东西了
    public static List&lt;String&gt; addNames(List&lt;String&gt; list)&amp;#123;
        list.add(&quot;Rose&quot;);
        list.add(&quot;Rechal&quot;);
        list.add(&quot;霉霉&quot;);
        return list;
    &amp;#125;
&amp;#125;
</code></pre>
<h2 id="发红包案例"><a class="header-anchor" href="#发红包案例">¶</a>发红包案例</h2>
<h3 id="分析"><a class="header-anchor" href="#分析">¶</a>分析</h3>
<pre><code class="language-java">import cn.itcast.day.demo01.red.OpenMode;

/*
场景说明:
    红包发出去之后，所有人都有红包，大家抢完了之后，最后一个红包给群主自己。
大多数代码都是现成的，我们需要做的就是填空题。
我们自己要做的事情有:
    1.设置一下程序的标题，通过构造方法的字符串参数
    2.设置群主名称I
    3.设置分发策略:平均，还是随机? |

红包分发的策略:
    1.普通红包(平均) : totalMoney / totalCount, 余数放在最后一个红包当 中。
    2.手气红包(随机);最少1分钱，最多不超过平均数的2倍。应该越发越少。
 */
public class Bootstrap &amp;#123;

    public static void main(String[] args) &amp;#123;
        MyRed red = new MyRed(&quot;红包发发发&quot;);
        //设置群主名称
        red.setOwnerName(&quot;乔布斯&quot;);

        /*//普通红包
        OpenMode normal = new NormalMode();
        red.setOpenWay(normal);*/

        //手气红包
        OpenMode random = new RandomMode();
        red.setOpenWay(random);
    &amp;#125;
&amp;#125;
</code></pre>
<h3 id="普通红包平均分发"><a class="header-anchor" href="#普通红包平均分发">¶</a>普通红包平均分发</h3>
<p><img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/stardust14/picture/master/img/20200804215918.png" alt="image-20200804215912112"></p>
<p><img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/stardust14/picture/master/img/20200804215944.png" alt="image-20200804215943078"></p>
<p><img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/stardust14/picture/master/img/20200804220210.png" alt="image-20200804220009753"></p>
<pre><code class="language-java">import cn.itcast.day.demo01.red.OpenMode;

import java.util.ArrayList;

public class NormalMode implements OpenMode &amp;#123;
    @Override
    public ArrayList&lt;Integer&gt; divide(final int totalMoney, final int totalCount) &amp;#123;
        ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();

        int avg = totalMoney / totalCount;//平均值
        int mod = totalMoney % totalCount;//余数，模，零头

        //注意totallCount - 1代表，最后一个先留着
        for (int i = 0; i &lt; totalCount - 1; i++) &amp;#123;
            list.add(avg);
        &amp;#125;

        //有零头，需要先放在最后一个红包里
        list.add(avg + mod);
        return list;
    &amp;#125;
&amp;#125;
</code></pre>
<h3 id="手气红包随机分发"><a class="header-anchor" href="#手气红包随机分发">¶</a>手气红包随机分发</h3>
<p><img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/stardust14/picture/master/img/20200804222622.png" alt="image-20200804222621272"></p>
<p><img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/stardust14/picture/master/img/20200804222641.png" alt="image-20200804222639346"></p>
<p><img src= "/stardust14.github.io/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/stardust14/picture/master/img/20200804222835.png" alt="image-20200804222655186"></p>
<pre><code class="language-java">import cn.itcast.day.demo01.red.OpenMode;

import java.util.ArrayList;
import java.util.Random;

public class RandomMode implements OpenMode &amp;#123;
    @Override
    public ArrayList&lt;Integer&gt; divide(int totalMoney, int totalCount) &amp;#123;
        ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();

        //随机分配，有可能多，有可能少
        //最少一分钱，最多不超过“剩下金额平均数的2倍”
        // 第一次友红包，随札范围是0. 01元~6.66元
        //第一次发完之后，剩下的至少是3.34元。
        //此时还需要再发2个红包
        //此时的再发范围应该是0.01元~3.34元(取不到右边，剩下0. 01)


        //总结一下，范围的[公式]是: 1 + random. nextInt(leftMoney / leftCount * 2);
        Random r = new Random();//首先创建一个随机数生成器
        // totalMoney是 总金额，totalCount是总份数，不变
        //额外定义两个变量，分别代表剩下多少钱，剩下多少份
        int leftMoney = totalMoney;
        int leftCount = totalCount;

        //随机发n - 1个，最后一个不需要随机
        for (int i = 0; i &lt; totalCount - 1; i++) &amp;#123;
            //按照公式生成随机金额
            int money = r.nextInt(leftMoney / leftCount * 2) + 1;
            list.add(money);//将一个随机红包包好放入集合
            leftMoney -=money;//剩下的金额越发越少
            leftCount--;//剩下还应该再发的红包个数，递减
        &amp;#125;

        //最后一个不需要随机，直接放进去就行了
        list.add(leftMoney);
        return list;
    &amp;#125;
&amp;#125;
</code></pre>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:邮箱">stardust</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://stardust14.com/2020/07/08/java%E5%AD%A6%E4%B9%A0/">http://stardust14.com/2020/07/08/java%E5%AD%A6%E4%B9%A0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://stardust14.com" target="_blank">STAR</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/stardust14.github.io/tags/java/">java</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg3.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/images/wechat.png" target="_blank"><img class="post-qr-code-img" data-lazy-src="/stardust14.github.io/images/wechat.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/images/alipay.jpg" target="_blank"><img class="post-qr-code-img" data-lazy-src="/stardust14.github.io/images/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/stardust14.github.io/2020/07/28/Python%E5%AD%A6%E4%B9%A0/"><img class="prev-cover" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/stardust14.github.io/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Python基础知识</div></div></a></div><div class="next-post pull-right"><a href="/stardust14.github.io/2020/07/06/hexo%E5%8D%9A%E5%AE%A2%E9%81%87%E5%88%B0%E7%9A%84%E9%94%99%E8%AF%AF/"><img class="next-cover" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/stardust14.github.io/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">hexo出现的问题</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></article></main><footer id="footer" style="background-image: url(https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg3.png)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 By stardust</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://stardust14.github.io/">blog</a>!</div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/stardust14.github.io/js/utils.js"></script><script src="/stardust14.github.io/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/stardust14.github.io/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    window.valine = new Valine({
      el: '#vcomment',
      appId: 'HTNDsPzD87VFJzxigXr0LgQT-gzGzoHsz',
      appKey: 'rujMRAYTJMNb3muoM0nm6YCs',
      placeholder: '请留下你的足迹~',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'en',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '//i0.hdslb.com/bfs/emote/',
      emojiMaps: {"tv_doge":"6ea59c827c414b4a2955fe79e0f6fd3dcd515e24.png","tv_亲亲":"a8111ad55953ef5e3be3327ef94eb4a39d535d06.png","tv_偷笑":"bb690d4107620f1c15cff29509db529a73aee261.png","tv_再见":"180129b8ea851044ce71caf55cc8ce44bd4a4fc8.png","tv_冷漠":"b9cbc755c2b3ee43be07ca13de84e5b699a3f101.png","tv_发怒":"34ba3cd204d5b05fec70ce08fa9fa0dd612409ff.png","tv_发财":"34db290afd2963723c6eb3c4560667db7253a21a.png","tv_可爱":"9e55fd9b500ac4b96613539f1ce2f9499e314ed9.png","tv_吐血":"09dd16a7aa59b77baa1155d47484409624470c77.png","tv_呆":"fe1179ebaa191569b0d31cecafe7a2cd1c951c9d.png","tv_呕吐":"9f996894a39e282ccf5e66856af49483f81870f3.png","tv_困":"241ee304e44c0af029adceb294399391e4737ef2.png","tv_坏笑":"1f0b87f731a671079842116e0991c91c2c88645a.png","tv_大佬":"093c1e2c490161aca397afc45573c877cdead616.png","tv_大哭":"23269aeb35f99daee28dda129676f6e9ea87934f.png","tv_委屈":"d04dba7b5465779e9755d2ab6f0a897b9b33bb77.png","tv_害羞":"a37683fb5642fa3ddfc7f4e5525fd13e42a2bdb1.png","tv_尴尬":"7cfa62dafc59798a3d3fb262d421eeeff166cfa4.png","tv_微笑":"70dc5c7b56f93eb61bddba11e28fb1d18fddcd4c.png","tv_思考":"90cf159733e558137ed20aa04d09964436f618a1.png","tv_惊吓":"0d15c7e2ee58e935adc6a7193ee042388adc22af.png"},
      enableQQ: false,
      path: window.location.pathname,
    });
    if ('nick,mail') { valine.config.requiredFields= 'nick,mail'.split(',') }
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="https://cdn.jsdelivr.net/gh/sviptzk/StaticFile_HEXO@latest/butterfly/js/pool.min.js"></script><script src="https://myhkw.cn/player/js/player.js" id="myhk" key="159721473362" m="1"></script><canvas class="fireworks"></canvas><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/stardust14.github.io/js/third-party/fireworks.js"></script><script src="/stardust14.github.io/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
document.body.addEventListener('input', POWERMODE);
</script></div></body></html>